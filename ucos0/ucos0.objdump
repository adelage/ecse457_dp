
ucos0.elf:     file format elf32-littlenios2
ucos0.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x004641e0

Program Header:
    LOAD off    0x00001000 vaddr 0x00464000 paddr 0x00464000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00464020 paddr 0x00464020 align 2**12
         filesz 0x0001227c memsz 0x0001227c flags r-x
    LOAD off    0x0001329c vaddr 0x0047629c paddr 0x00477da0 align 2**12
         filesz 0x00001b04 memsz 0x00001b04 flags rw-
    LOAD off    0x000158a4 vaddr 0x004798a4 paddr 0x004798a4 align 2**12
         filesz 0x00000000 memsz 0x00003590 flags rw-
    LOAD off    0x00015000 vaddr 0x04200000 paddr 0x04200000 align 2**12
         filesz 0x00001000 memsz 0x00001000 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00464000  00464000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   000001c0  00464020  00464020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .critical     00001000  04200000  04200000  00015000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .text         00011de4  004641e0  004641e0  000011e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000002d8  00475fc4  00475fc4  00012fc4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .rwdata       00001b04  0047629c  00477da0  0001329c  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  6 .bss          00003590  004798a4  004798a4  000158a4  2**2
                  ALLOC, SMALL_DATA
  7 .comment      00000023  00000000  00000000  00016000  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000db8  00000000  00000000  00016028  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   0002668d  00000000  00000000  00016de0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 000092d6  00000000  00000000  0003d46d  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   0000a8e2  00000000  00000000  00046743  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  000022c4  00000000  00000000  00051028  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00003d51  00000000  00000000  000532ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00008a5a  00000000  00000000  0005703d  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000020  00000000  00000000  0005fa98  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00000590  00000000  00000000  0005fab8  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000006  00000000  00000000  000649ad  2**0
                  CONTENTS, READONLY
 18 .cpu          00000011  00000000  00000000  000649b3  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  000649c4  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  000649c5  2**0
                  CONTENTS, READONLY
 21 .sysid_hash   00000004  00000000  00000000  000649c6  2**0
                  CONTENTS, READONLY
 22 .sysid_base   00000004  00000000  00000000  000649ca  2**0
                  CONTENTS, READONLY
 23 .sysid_time   00000004  00000000  00000000  000649ce  2**0
                  CONTENTS, READONLY
 24 .stderr_dev   00000016  00000000  00000000  000649d2  2**0
                  CONTENTS, READONLY
 25 .stdin_dev    00000016  00000000  00000000  000649e8  2**0
                  CONTENTS, READONLY
 26 .stdout_dev   00000016  00000000  00000000  000649fe  2**0
                  CONTENTS, READONLY
 27 .sopc_system_name 0000000b  00000000  00000000  00064a14  2**0
                  CONTENTS, READONLY
 28 .quartus_project_dir 0000003a  00000000  00000000  00064a1f  2**0
                  CONTENTS, READONLY
 29 .sopcinfo     00179073  00000000  00000000  00064a59  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00464000 l    d  .entry	00000000 .entry
00464020 l    d  .exceptions	00000000 .exceptions
04200000 l    d  .critical	00000000 .critical
004641e0 l    d  .text	00000000 .text
00475fc4 l    d  .rodata	00000000 .rodata
0047629c l    d  .rwdata	00000000 .rwdata
004798a4 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../ucos0_bsp//obj/HAL/src/crt0.o
00464218 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 hello_ucosii_0.c
0046421c l     F .text	000000bc handle_cpu1_interrupt
004642d8 l     F .text	00000030 init_cpu1_isr
00000000 l    df *ABS*	00000000 tlb.c
00000000 l    df *ABS*	00000000 fingerprint.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 impure.c
0047629c l     O .rwdata	00000400 impure_data
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
00466610 l     F .text	00000008 __fp_lock
00466618 l     F .text	00000008 __fp_unlock
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 alt_close.c
00467618 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dev.c
00467734 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
00467760 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
00467bac l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_load.c
00467ca0 l     F .text	0000006c alt_load_section
00000000 l    df *ABS*	00000000 alt_lseek.c
00467d8c l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_read.c
00467f7c l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
00477d10 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_write.c
00468248 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_env_lock.c
00477d14 l     O .rwdata	00000004 lockid
004798e8 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00477d18 l     O .rwdata	00000004 lockid
004798f0 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
0046a150 l     F .text	00000044 OS_InitMisc
0046a194 l     F .text	0000006c OS_InitRdyList
0046a2f8 l     F .text	000000e0 OS_InitTCBList
0046a074 l     F .text	000000dc OS_InitEventList
0046a200 l     F .text	0000007c OS_InitTaskIdle
0046a27c l     F .text	0000007c OS_InitTaskStat
0046a590 l     F .text	00000070 OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
0046ca5c l     F .text	0000010c OS_FlagTaskRdy
0046c7b8 l     F .text	000001c0 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00472140 l     F .text	00000038 alt_dev_reg
00472178 l     F .text	00000050 alt_get_errno
004721c8 l     F .text	000000a4 alt_avalon_mutex_reg
00476c4c l     O .rwdata	0000106c processor0_0_jtag_uart
00477cb8 l     O .rwdata	00000014 mutex_0
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
004725d0 l     F .text	000002ac altera_avalon_jtag_uart_irq
0047287c l     F .text	0000010c altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_mutex.c
004730d0 l     F .text	00000050 alt_get_errno
00473120 l     F .text	0000007c alt_mutex_trylock
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
00473424 l     F .text	000000a0 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_timer_ts.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_vars.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00473944 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
00473bac l     F .text	000000e0 alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
00473d04 l     F .text	00000050 alt_get_errno
00473d54 l     F .text	000000f0 alt_file_locked
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 os_cpu_a.o
00000040 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fp-bit.c
00474d20 l     F .text	00000354 _fpadd_parts
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00475814 l     F .text	00000074 udivmodsi4
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 alt_exit.c
00000000 l    df *ABS*	00000000 
00477d66 g     O .rwdata	00000002 OSTaskNameSize
004674b4 g     F .text	00000064 _isatty_r
00467eb0 g     F .text	000000cc alt_main
00464ab0 g       .text	00000000 get_gp
00475f3c g     F .text	00000044 __ashldi3
00464ad4 g     F .text	00000084 _puts_r
02500000 g       *ABS*	00000000 __alt_mem_shared_memory
00479980 g     O .bss	00000100 alt_irq
00467518 g     F .text	0000006c _lseek_r
0046d44c g     F .text	000000d8 OS_MemInit
004646b0 g     F .text	00000028 set_enable
00477da0 g       *ABS*	00000000 __flash_rwdata_start
004720b0 g     F .text	00000090 OSTimeSet
00468a4c g     F .text	00000718 OSEventPendMulti
0047ce34 g       *ABS*	00000000 __alt_heap_start
004798a8 g     O .bss	00000004 preempt_sem_2
00474548 g     F .text	00000020 OSTaskCreateHook
00477d3e g     O .rwdata	00000002 OSMboxEn
004691b8 g     F .text	000000a8 OSIntEnter
004671c8 g     F .text	0000005c __sseek
004666b4 g     F .text	0000010c __sinit
00477d4e g     O .rwdata	00000002 OSQEn
0046662c g     F .text	00000078 __sfmoreglue
0046860c g     F .text	00000158 __malloc_unlock
004745a4 g     F .text	0000001c OSTaskStatHook
004798f8 g     O .bss	00000001 OSLockNesting
00477d8c g     O .rwdata	00000002 OSDataSize
004798f9 g     O .bss	00000001 OSRunning
0047994c g     O .bss	00000004 altera_avalon_timer_ts_freq
00465a98 g     F .text	0000018c memmove
004745dc g     F .text	0000001c OSInitHookBegin
004647c0 g     F .text	00000028 get_spmtable_entry
00477d84 g     O .rwdata	00000002 OSTmrSize
004666a4 g     F .text	00000010 _cleanup
00473278 g     F .text	00000080 altera_avalon_mutex_trylock
004798fc g     O .bss	00000004 OSIdleCtr
00464764 g     F .text	00000028 get_cputable_entry
00474230 g       .text	00000000 OSStartTsk
00000000  w      *UND*	00000000 __errno
0046a914 g     F .text	0000035c OS_TCBInit
04200000 g     O .critical	00001000 critical_task_stk
00464000 g     F .entry	0000001c __reset
00477d8a g     O .rwdata	00000002 OSTmrWheelTblSize
00473360 g     F .text	00000074 altera_avalon_mutex_is_mine
00464020 g       *ABS*	00000000 __flash_exceptions_start
00477d2a g     O .rwdata	00000002 OSEventSize
00479900 g     O .bss	00000001 OSPrioHighRdy
0046744c g     F .text	00000068 _fstat_r
00474568 g     F .text	00000020 OSTaskDelHook
00464628 g     F .text	00000010 enable_tlb
004798d0 g     O .bss	00000004 errno
004798ac g     O .bss	00000004 mbox
0046478c g     F .text	00000034 set_spmtable_entry
00474210 g       .text	00000000 OSStartHighRdy
00470194 g     F .text	000002a4 OSTaskCreateExt
0046c1f0 g     F .text	00000094 OSFlagPendGetFlagsRdy
00477d6a g     O .rwdata	00000002 OSTaskStatStkSize
004798b0 g     O .bss	00000004 preempt_sem_3
0046adfc g     F .text	000003e4 OSFlagAccept
0046dc8c g     F .text	000000e4 OSQFlush
0046d524 g     F .text	0000016c OSQAccept
004798e0 g     O .bss	00000004 alt_argv
0047fccc g       *ABS*	00000000 _gp
004646e4 g     F .text	0000000c get_enable
0046ff28 g     F .text	0000026c OSTaskCreate
0046f950 g     F .text	000005d8 OSTaskChangePrio
004798f4 g     O .bss	00000004 alt_heapsem
00477cd0 g     O .rwdata	00000004 LINE_ENABLE_REG
0046ac70 g     F .text	0000018c OSDebugInit
00470438 g     F .text	0000048c OSTaskDel
00464724 g     F .text	0000000c get_valid
00476acc g     O .rwdata	00000180 alt_fd_list
00479a80 g     O .bss	00000370 OSFlagTbl
00469e64 g     F .text	000000b0 OS_EventTaskRemove
00473aec g     F .text	00000090 alt_find_dev
00465958 g     F .text	00000140 memcpy
00477d54 g     O .rwdata	00000002 OSRdyTblSize
00466620 g     F .text	0000000c _cleanup_r
00473c8c g     F .text	00000078 alt_io_redirect
00475fc4 g       *ABS*	00000000 __DTOR_END__
00464718 g     F .text	0000000c reset_valid
00464b58 g     F .text	00000014 puts
00468764 g     F .text	0000014c OSEventNameGet
00477d38 g     O .rwdata	00000002 OSFlagMax
00469260 g     F .text	000001bc OSIntExit
00477d72 g     O .rwdata	00000002 OSTCBSize
00479901 g     O .bss	00000001 OSPrioCur
00472ae4 g     F .text	000002f0 altera_avalon_jtag_uart_read
00000000  w      *UND*	00000000 malloc
00475934 g     F .text	00000008 __udivsi3
00467bfc g     F .text	000000a4 isatty
00477d58 g     O .rwdata	00000002 OSStkWidth
04200000 g       *ABS*	00000000 __alt_mem_processor0_0_scratchpad
00477d4c g     O .rwdata	00000002 OSPtrSize
00477d2c g     O .rwdata	00000002 OSEventTblSize
00474c9c g     F .text	00000084 __fixunsdfsi
00474184 g       .text	00000000 OSCtxSw
00474878 g     F .text	0000008c alt_icache_flush
004798cc g     O .bss	00000004 __malloc_top_pad
00479904 g     O .bss	00000004 OSTCBList
004798d4 g     O .bss	00000004 alt_fd_list_lock
00464bf8 g     F .text	000004e4 __sfvwrite_r
00479df0 g     O .bss	00000c30 OSMemTbl
00479908 g     O .bss	00000001 OSTickStepState
00466220 g     F .text	00000064 _sbrk_r
00477d50 g     O .rwdata	00000002 OSQMax
0047aa20 g     O .bss	00000800 OSTaskStatStk
0046cf70 g     F .text	00000124 OSMemNameGet
00477d30 g     O .rwdata	00000002 OSFlagEn
00467584 g     F .text	0000006c _read_r
00477d76 g     O .rwdata	00000002 OSTimeTickHookEn
0046e2bc g     F .text	000001ec OSQPost
0046cb68 g     F .text	000000a0 OS_FlagUnlink
00477d04 g     O .rwdata	00000004 alt_max_fd
0046a42c g     F .text	0000006c OS_MemCopy
00475d24 g     F .text	00000104 __unpack_d
0046a498 g     F .text	000000f8 OS_Sched
004672fc g     F .text	0000013c _fclose_r
0046ce28 g     F .text	00000148 OSMemGet
00470cf8 g     F .text	00000274 OSTaskNameSet
004665e0 g     F .text	00000030 fflush
004798c8 g     O .bss	00000004 __malloc_max_sbrked_mem
0047990c g     O .bss	00000004 OSCtxSwCtr
004745c0 g     F .text	0000001c OSTimeTickHook
00477d3a g     O .rwdata	00000002 OSFlagNameSize
00469f14 g     F .text	000000f8 OS_EventTaskRemoveMulti
00475074 g     F .text	00000054 __adddf3
00469d1c g     F .text	00000148 OS_EventTaskWaitMulti
00477d52 g     O .rwdata	00000002 OSQSize
00467ddc g     F .text	000000d4 lseek
004733d4 g     F .text	00000050 altera_avalon_mutex_first_lock
0046f090 g     F .text	000002f0 OSSemPend
00477ce4 g     O .rwdata	00000004 _global_impure_ptr
00465c24 g     F .text	000005fc _realloc_r
00477d3c g     O .rwdata	00000002 OSLowestPrio
0047ce34 g       *ABS*	00000000 __bss_end
00467a90 g     F .text	0000011c alt_iic_isr_register
00474630 g     F .text	00000020 OSTCBInitHook
00477d82 g     O .rwdata	00000002 OSTmrCfgTicksPerSec
00474060 g     F .text	00000104 alt_tick
00477d24 g     O .rwdata	00000002 OSEventEn
00477d7e g     O .rwdata	00000002 OSTmrCfgNameSize
004756f8 g     F .text	0000011c __floatunsidf
00400000 g       *ABS*	00000000 __alt_mem_memory_0_onchip_memoryMain
004668cc g     F .text	00000018 __fp_lock_all
00477cd8 g     O .rwdata	00000004 VIRT_ADDR_TABLE
00467a44 g     F .text	0000004c alt_ic_irq_enabled
00464940 g     F .text	00000028 fprint_set_block_size
004646f0 g     F .text	00000028 set_valid
0046c978 g     F .text	000000e4 OS_FlagInit
00473f9c g     F .text	000000c4 alt_alarm_stop
00477d60 g     O .rwdata	00000002 OSTaskIdleStkSize
004798d8 g     O .bss	00000004 alt_irq_active
0046eb68 g     F .text	000000dc OSSemAccept
0046d208 g     F .text	00000130 OSMemPut
0046cc08 g     F .text	00000220 OSMemCreate
00479910 g     O .bss	00000004 OSIdleCtrMax
00464110 g     F .exceptions	000000d0 alt_irq_handler
00476aa4 g     O .rwdata	00000028 alt_dev_null
00477d74 g     O .rwdata	00000002 OSTicksPerSec
0047319c g     F .text	00000050 altera_avalon_mutex_open
00474184 g       .text	00000000 OSIntCtxSw
00473928 g     F .text	0000001c alt_dcache_flush_all
00475624 g     F .text	000000d4 __fixdfsi
00479914 g     O .bss	00000004 OSTCBFreeList
00477da0 g       *ABS*	00000000 __ram_rwdata_end
0046f380 g     F .text	000001cc OSSemPendAbort
00477cfc g     O .rwdata	00000008 alt_dev_list
00468298 g     F .text	000000f0 write
00477d78 g     O .rwdata	00000002 OSVersionNbr
00473794 g     F .text	00000028 alt_timestamp_freq
00477d90 g     O .rwdata	00000008 alt_mutex_list
0047629c g       *ABS*	00000000 __ram_rodata_end
004677b0 g     F .text	000000b0 fstat
00475ef8 g     F .text	00000044 __lshrdi3
00464a48 g       .text	00000000 context_switch
004647e8 g     F .text	00000098 set_task_directory
00477d20 g     O .rwdata	00000004 OSEndiannessTest
0047593c g     F .text	00000008 __umodsi3
00477d32 g     O .rwdata	00000002 OSFlagGrpSize
004798b4 g     O .bss	00000004 mutex
0047ce34 g       *ABS*	00000000 end
00472494 g     F .text	0000013c altera_avalon_jtag_uart_init
0046a758 g     F .text	000000f4 OS_TaskStat
00464880 g     F .text	0000002c enable_fprint_task
00475fc4 g       *ABS*	00000000 __CTOR_LIST__
00496000 g       *ABS*	00000000 __alt_stack_pointer
004734c4 g     F .text	00000088 alt_avalon_timer_sc_init
00475a54 g     F .text	000000ac __clzsi2
00472dd4 g     F .text	000002fc altera_avalon_jtag_uart_write
00464ac8 g       .text	00000000 restore_gp
004668bc g     F .text	00000004 __sfp_lock_acquire
00465860 g     F .text	000000f8 memchr
0046a3d8 g     F .text	00000054 OS_MemClr
00474254 g     F .text	000002f4 OSTaskStkInit
00466a38 g     F .text	000002d0 _free_r
00464a8c g       .text	00000000 context_restore
00469a7c g     F .text	00000198 OS_EventTaskRdy
00474afc g     F .text	000001a0 __call_exitprocs
00479918 g     O .bss	00000001 OSCPUUsage
00477cec g     O .rwdata	00000004 __malloc_sbrk_base
004641e0 g     F .text	0000003c _start
00479950 g     O .bss	00000004 _alt_tick_rate
0046dd70 g     F .text	00000380 OSQPend
004719a0 g     F .text	00000174 OSTimeDly
0046449c g     F .text	0000003c init_tlb
004798b8 g     O .bss	00000004 ct
00479954 g     O .bss	00000004 _alt_nticks
00467fcc g     F .text	000000f4 read
004722a0 g     F .text	00000090 alt_sys_init
00464abc g       .text	00000000 set_gp
004749cc g     F .text	00000130 __register_exitproc
00479919 g     O .bss	00000001 OSTaskCtr
004732f8 g     F .text	00000068 altera_avalon_mutex_unlock
00471b14 g     F .text	00000244 OSTimeDlyHMSM
00464968 g     F .text	0000004c set_core_assignment
004649b4 g     F .text	00000094 set_core_assignment_table
00472988 g     F .text	00000068 altera_avalon_jtag_uart_close
004675f0 g     F .text	00000028 __mulsi3
0047629c g       *ABS*	00000000 __ram_rwdata_start
00475fc4 g       *ABS*	00000000 __ram_rodata_start
00479958 g     O .bss	00000028 __malloc_current_mallinfo
00477d26 g     O .rwdata	00000002 OSEventMax
0046f54c g     F .text	00000194 OSSemPost
004694d0 g     F .text	00000188 OSSchedUnlock
00477ccc g     O .rwdata	00000004 isr_0_ptr
00472330 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
00474764 g     F .text	00000114 alt_get_fd
0047991c g     O .bss	00000004 OSMemFreeList
004696c4 g     F .text	00000104 OSStatInit
0046c6c8 g     F .text	000000f0 OSFlagQuery
00475e28 g     F .text	000000d0 __fpcmp_parts_d
00477d5c g     O .rwdata	00000002 OSTaskCreateExtEn
00467298 g     F .text	00000064 _close_r
004648ac g     F .text	00000024 disable_fprint_task
00474950 g     F .text	0000007c memcmp
00469a60 g     F .text	0000001c OS_Dummy
004723f0 g     F .text	00000050 altera_avalon_jtag_uart_close_fd
0047ce34 g       *ABS*	00000000 __alt_stack_base
00472440 g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
00466284 g     F .text	00000174 __swsetup_r
0047b220 g     O .bss	000001e0 OSQTbl
0047540c g     F .text	000001b4 __divdf3
004667c0 g     F .text	000000fc __sfp
0047669c g     O .rwdata	00000408 __malloc_av_
004668c8 g     F .text	00000004 __sinit_lock_release
00475128 g     F .text	000002e4 __muldf3
00479920 g     O .bss	00000004 OSTCBHighRdy
004670ec g     F .text	00000054 __sread
00479924 g     O .bss	00000004 OSQFreeList
00474650 g     F .text	00000114 alt_find_file
00473994 g     F .text	000000a0 alt_dev_llist_insert
004684a0 g     F .text	0000016c __malloc_lock
00468140 g     F .text	00000108 sbrk
004688b0 g     F .text	0000019c OSEventNameSet
004663f8 g     F .text	000001e8 _fflush_r
00479928 g     O .bss	00000001 OSRdyGrp
00464638 g     F .text	00000064 reset_tlb
0046469c g     F .text	00000014 tlb_is_on
004798a4 g       *ABS*	00000000 __bss_start
00467010 g     F .text	000000dc memset
004798bc g     O .bss	00000001 err
004644d8 g     F .text	00000144 main
004798e4 g     O .bss	00000004 alt_envp
004798c4 g     O .bss	00000004 __malloc_max_total_mem
0046461c g     F .text	0000000c disable_tlb
00472390 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
00476038 g     O .rodata	00000100 OSUnMapTbl
004648d0 g     F .text	00000020 fprint_reset_irq
00477d56 g     O .rwdata	00000002 OSSemEn
0046c284 g     F .text	00000444 OSFlagPost
00467224 g     F .text	00000008 __sclose
00496000 g       *ABS*	00000000 __alt_heap_limit
00467438 g     F .text	00000014 fclose
00469c14 g     F .text	00000108 OS_EventTaskWait
0047354c g     F .text	000000a8 alt_timestamp_start
0046a84c g     F .text	000000c8 OS_TaskStatStkChk
0047cca4 g     O .bss	00000190 _atexit0
00473210 g     F .text	00000068 altera_avalon_mutex_lock
004708c4 g     F .text	00000208 OSTaskDelReq
004650dc g     F .text	00000784 _malloc_r
00477cdc g     O .rwdata	00000004 PHYS_ADDR_TABLE
00477d08 g     O .rwdata	00000004 alt_errno
00469658 g     F .text	0000006c OSStart
00468440 g     F .text	00000060 __env_unlock
00466d08 g     F .text	000000a8 _fwalk
00470f6c g     F .text	000002fc OSTaskResume
0046d338 g     F .text	00000114 OSMemQuery
00477d68 g     O .rwdata	00000002 OSTaskStatEn
00477d42 g     O .rwdata	00000002 OSMemMax
0046e4a8 g     F .text	000001f4 OSQPostFront
00475888 g     F .text	00000050 __divsi3
00479929 g     O .bss	00000003 OSRdyTbl
00477d1c g     O .rwdata	00000002 OSDebugEn
00476188 g     O .rodata	00000014 __thenan_df
004668fc g     F .text	0000013c _malloc_trim_r
00475fc4 g       *ABS*	00000000 __CTOR_END__
00477d34 g     O .rwdata	00000002 OSFlagNodeSize
00477d7c g     O .rwdata	00000002 OSTmrCfgMax
0046d690 g     F .text	0000027c OSQCreate
00470acc g     F .text	0000022c OSTaskNameGet
00475fc4 g       *ABS*	00000000 __flash_rodata_start
0046e69c g     F .text	00000290 OSQPostOpt
004697c8 g     F .text	00000278 OSTimeTick
00477d64 g     O .rwdata	00000002 OSTaskMax
00475fc4 g       *ABS*	00000000 __DTOR_LIST__
0046ec44 g     F .text	0000012c OSSemCreate
00477d88 g     O .rwdata	00000002 OSTmrWheelSize
004798a4 g     O .bss	00000004 count
00477d5e g     O .rwdata	00000002 OSTaskDelEn
0046f6e0 g     F .text	00000144 OSSemQuery
0046d90c g     F .text	00000380 OSQDel
0046e0f0 g     F .text	000001cc OSQPendAbort
0047226c g     F .text	00000034 alt_irq_init
004680c0 g     F .text	00000080 alt_release_fd
00477ce0 g     O .rwdata	00000004 TLB_ACTIVATE_REG
004648f0 g     F .text	00000050 fprint_status
0047619c g     O .rodata	00000100 __clz_tab
00474904 g     F .text	00000014 atexit
0046722c g     F .text	0000006c _write_r
0046941c g     F .text	000000b4 OSSchedLock
00464308 g     F .text	00000194 preemption_task
0046b1e0 g     F .text	00000180 OSFlagCreate
00477ce8 g     O .rwdata	00000004 _impure_ptr
004798dc g     O .bss	00000004 alt_argc
00479948 g     O .bss	00000004 altera_avalon_timer_ts_base
00473a90 g     F .text	0000005c _do_dtors
00477d2e g     O .rwdata	00000002 OSEventMultiEn
0046b360 g     F .text	00000320 OSFlagDel
0047992c g     O .bss	00000004 OSEventFreeList
00464020 g       .exceptions	00000000 alt_irq_entry
0046b9e0 g     F .text	00000810 OSFlagPend
00477d7a g     O .rwdata	00000002 OSTmrEn
004668e4 g     F .text	00000018 __fp_unlock_all
00477cf4 g     O .rwdata	00000008 alt_fs_list
0046a600 g     F .text	0000007c OS_StrCopy
00477d44 g     O .rwdata	00000002 OSMemNameSize
004745f8 g     F .text	0000001c OSInitHookEnd
00464020 g       *ABS*	00000000 __ram_exceptions_start
00477d70 g     O .rwdata	00000002 OSTCBPrioTblMax
004735f4 g     F .text	000001a0 alt_timestamp
00477d6c g     O .rwdata	00000002 OSTaskStatStkChkEn
00467860 g     F .text	00000050 alt_ic_isr_register
00477d40 g     O .rwdata	00000002 OSMemEn
00477d4a g     O .rwdata	00000002 OSMutexEn
00477da0 g       *ABS*	00000000 _edata
0047ce34 g       *ABS*	00000000 _end
00479930 g     O .bss	00000001 OSIntNesting
004641e0 g       *ABS*	00000000 __ram_exceptions_end
004729f0 g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
00471d58 g     F .text	000002c8 OSTimeDlyResume
0046b808 g     F .text	000001d8 OSFlagNameSet
00471268 g     F .text	00000284 OSTaskStkChk
00467978 g     F .text	000000cc alt_ic_irq_disable
00477d46 g     O .rwdata	00000002 OSMemSize
00467140 g     F .text	00000088 __swrite
00477cf0 g     O .rwdata	00000004 __malloc_trim_threshold
00474164 g     F .text	00000020 altera_nios2_qsys_irq_init
00479934 g     O .bss	00000004 OSTCBCur
00474918 g     F .text	00000038 exit
00477d48 g     O .rwdata	00000002 OSMemTblSize
00466db0 g     F .text	000000b8 _fwalk_reent
004758d8 g     F .text	0000005c __modsi3
00496000 g       *ABS*	00000000 __alt_data_end
00464020 g     F .exceptions	00000000 alt_exception
004668c0 g     F .text	00000004 __sfp_lock_release
00469164 g     F .text	00000054 OSInit
00471780 g     F .text	000001b0 OSTaskQuery
0046eabc g     F .text	000000ac OS_QInit
0046a67c g     F .text	00000054 OS_StrLen
0046d094 g     F .text	00000174 OSMemNameSet
00477d62 g     O .rwdata	00000002 OSTaskProfileEn
00479938 g     O .bss	00000004 OSTime
0047b400 g     O .bss	00000800 OSTaskIdleStk
00475f80 g     F .text	00000044 _exit
004737bc g     F .text	0000016c alt_alarm_start
0046b680 g     F .text	00000188 OSFlagNameGet
00472020 g     F .text	00000090 OSTimeGet
00475944 g     F .text	00000110 __muldi3
00466e68 g     F .text	000001a8 __smakebuf_r
00464b6c g     F .text	0000008c strlen
00474588 g     F .text	0000001c OSTaskSwHook
00473e44 g     F .text	00000158 open
0047bc00 g     O .bss	00000b40 OSEventTbl
004755c0 g     F .text	00000064 __gedf2
0047c740 g     O .bss	00000510 OSTCBTbl
0046f824 g     F .text	0000012c OSSemSet
00473b7c g     F .text	00000030 alt_icache_flush_all
00477cd4 g     O .rwdata	00000004 LINE_VALID_REG
00477d0c g     O .rwdata	00000004 alt_priority_mask
0046ed70 g     F .text	00000320 OSSemDel
0047993c g     O .bss	00000004 OSFlagFreeList
004678b0 g     F .text	000000c8 alt_ic_irq_enable
00477d28 g     O .rwdata	00000002 OSEventNameSize
00479940 g     O .bss	00000001 OSStatRdy
004731ec g     F .text	00000024 altera_avalon_mutex_close
004798c0 g     O .bss	00000004 preempt_sem
0047cc50 g     O .bss	00000054 OSTCBPrioTbl
00468388 g     F .text	000000b8 __env_lock
00477d6e g     O .rwdata	00000002 OSTaskSwHookEn
004750c8 g     F .text	00000060 __subdf3
00477d98 g     O .rwdata	00000008 alt_alarm_list
00477d36 g     O .rwdata	00000002 OSFlagWidth
00473a34 g     F .text	0000005c _do_ctors
00464730 g     F .text	00000034 set_cputable_entry
00467668 g     F .text	000000cc close
004798ec g     O .bss	00000004 alt_envsem
00479944 g     O .bss	00000004 OSIdleCtrRun
00469a40 g     F .text	00000020 OSVersion
00477d80 g     O .rwdata	00000002 OSTmrCfgWheelSize
00467d0c g     F .text	00000080 alt_load
00471930 g     F .text	00000070 OS_TaskStkClr
00475b00 g     F .text	00000224 __pack_d
00477d5a g     O .rwdata	00000002 OSTaskCreateEn
0046a00c g     F .text	00000068 OS_EventWaitListInit
00474614 g     F .text	0000001c OSTaskIdleHook
00000000  w      *UND*	00000000 free
004668c4 g     F .text	00000004 __sinit_lock_acquire
004646d8 g     F .text	0000000c reset_enable
004714ec g     F .text	00000294 OSTaskSuspend
0046a6d0 g     F .text	00000088 OS_TaskIdle
00477d86 g     O .rwdata	00000002 OSTmrTblSize
0046e92c g     F .text	00000190 OSQQuery



Disassembly of section .entry:

00464000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && !defined(ALT_SIM_OPTIMIZE)
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
  464000:	00810014 	movui	r2,1024
#endif

0:
    initi r2
  464004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
  464008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
  46400c:	00bffd16 	blt	zero,r2,464004 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
  464010:	004011b4 	movhi	at,70
    ori r1, r1, %lo(_start)
  464014:	08507814 	ori	at,at,16864
    jmp r1
  464018:	0800683a 	jmp	at
  46401c:	00000000 	call	0 <OSTCBStkPtr_OFFSET>

Disassembly of section .exceptions:

00464020 <alt_exception>:
         * Process an exception.  For all exceptions we must preserve all
         * caller saved registers on the stack (See the Nios2 ABI
         * documentation for details).
         */

        addi  sp, sp, -80
  464020:	deffec04 	addi	sp,sp,-80

#endif

#endif

        stw   ra,  0(sp)
  464024:	dfc00015 	stw	ra,0(sp)
        movhi ra,  %hi(0x8100000)
  464028:	07c20434 	movhi	ra,2064
        ori   ra,  ra, 8
  46402c:	ffc00214 	ori	ra,ra,8
        ldw   ra,    0(ra)
  464030:	ffc00017 	ldw	ra,0(ra)
         /*
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */

        stw   r1,   8(sp)
  464034:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
  464038:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
  46403c:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
  464040:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
  464044:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
  464048:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
  46404c:	d9c00815 	stw	r7,32(sp)

        rdctl r5, estatus
  464050:	000b307a 	rdctl	r5,estatus

        stw   r8,  36(sp)
  464054:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
  464058:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
  46405c:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
  464060:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
  464064:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
  464068:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
  46406c:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
  464070:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
  464074:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
  464078:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
  46407c:	dbc01215 	stw	r15,72(sp)

        stw   gp,   76(sp)
  464080:	de801315 	stw	gp,76(sp)
        movhi gp, %hi(_gp)
  464084:	068011f4 	movhi	gp,71
        ori gp, gp, %lo(_gp)
  464088:	d6bf3314 	ori	gp,gp,64716
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
  46408c:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
  464090:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
  464094:	10000326 	beq	r2,zero,4640a4 <alt_exception+0x84>
        beq   r4, zero, .Lnot_irq
  464098:	20000226 	beq	r4,zero,4640a4 <alt_exception+0x84>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
  46409c:	04641100 	call	464110 <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
  4640a0:	00000306 	br	4640b0 <alt_exception+0x90>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
  4640a4:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
  4640a8:	e8bfff17 	ldw	r2,-4(ea)
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
  4640ac:	003da03a 	break	0

        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */
        movhi ra,  %hi(0x8100000)
  4640b0:	07c20434 	movhi	ra,2064
        ori   ra,  ra, 12
  4640b4:	ffc00314 	ori	ra,ra,12
        ldw   ra,    0(ra)
  4640b8:	ffc00017 	ldw	ra,0(ra)
        ldw   r5,  68(sp)
  4640bc:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
  4640c0:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
  4640c4:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
  4640c8:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
  4640cc:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
  4640d0:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
  4640d4:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
  4640d8:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
  4640dc:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
  4640e0:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
  4640e4:	d9c00817 	ldw	r7,32(sp)
#ifdef ALT_STACK_CHECK
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif
#endif

        ldw   r8,  36(sp)
  4640e8:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
  4640ec:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
  4640f0:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
  4640f4:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
  4640f8:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
  4640fc:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
  464100:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
  464104:	dbc01017 	ldw	r15,64(sp)
#endif
        ldw   gp,  76(sp)
        ldw   sp,  80(sp)

#else
        addi  sp, sp, 80
  464108:	dec01404 	addi	sp,sp,80

        /*
         * Return to the interrupted instruction.
         */

        eret
  46410c:	ef80083a 	eret

00464110 <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
  464110:	defff904 	addi	sp,sp,-28
  464114:	dfc00615 	stw	ra,24(sp)
  464118:	df000515 	stw	fp,20(sp)
  46411c:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
  464120:	04691b80 	call	4691b8 <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  464124:	0005313a 	rdctl	r2,ipending
  464128:	e0bffe15 	stw	r2,-8(fp)

  return active;
  46412c:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
  464130:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
  464134:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
  464138:	00800044 	movi	r2,1
  46413c:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
  464140:	e0fffb17 	ldw	r3,-20(fp)
  464144:	e0bffc17 	ldw	r2,-16(fp)
  464148:	1884703a 	and	r2,r3,r2
  46414c:	10001726 	beq	r2,zero,4641ac <alt_irq_handler+0x9c>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
  464150:	00c01234 	movhi	r3,72
  464154:	18e66004 	addi	r3,r3,-26240
  464158:	e0bffd17 	ldw	r2,-12(fp)
  46415c:	100490fa 	slli	r2,r2,3
  464160:	1885883a 	add	r2,r3,r2
  464164:	10c00017 	ldw	r3,0(r2)
  464168:	01001234 	movhi	r4,72
  46416c:	21266004 	addi	r4,r4,-26240
  464170:	e0bffd17 	ldw	r2,-12(fp)
  464174:	100490fa 	slli	r2,r2,3
  464178:	2085883a 	add	r2,r4,r2
  46417c:	10800104 	addi	r2,r2,4
  464180:	10800017 	ldw	r2,0(r2)
  464184:	1009883a 	mov	r4,r2
  464188:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
  46418c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  464190:	0005313a 	rdctl	r2,ipending
  464194:	e0bfff15 	stw	r2,-4(fp)

  return active;
  464198:	e0bfff17 	ldw	r2,-4(fp)
      mask <<= 1;
      i++;

    } while (1);

    active = alt_irq_pending ();
  46419c:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
  4641a0:	e0bffb17 	ldw	r2,-20(fp)
  4641a4:	103fe31e 	bne	r2,zero,464134 <alt_irq_handler+0x24>
  4641a8:	00000706 	br	4641c8 <alt_irq_handler+0xb8>
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
  4641ac:	e0bffc17 	ldw	r2,-16(fp)
  4641b0:	1085883a 	add	r2,r2,r2
  4641b4:	e0bffc15 	stw	r2,-16(fp)
      i++;
  4641b8:	e0bffd17 	ldw	r2,-12(fp)
  4641bc:	10800044 	addi	r2,r2,1
  4641c0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
  4641c4:	003fde06 	br	464140 <alt_irq_handler+0x30>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
  4641c8:	04692600 	call	469260 <OSIntExit>
}
  4641cc:	e037883a 	mov	sp,fp
  4641d0:	dfc00117 	ldw	ra,4(sp)
  4641d4:	df000017 	ldw	fp,0(sp)
  4641d8:	dec00204 	addi	sp,sp,8
  4641dc:	f800283a 	ret

Disassembly of section .text:

004641e0 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
  4641e0:	06c01274 	movhi	sp,73
    ori sp, sp, %lo(__alt_stack_pointer)
  4641e4:	ded80014 	ori	sp,sp,24576
    movhi gp, %hi(_gp)
  4641e8:	068011f4 	movhi	gp,71
    ori gp, gp, %lo(_gp)
  4641ec:	d6bf3314 	ori	gp,gp,64716
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
  4641f0:	008011f4 	movhi	r2,71
    ori r2, r2, %lo(__bss_start)
  4641f4:	10a62914 	ori	r2,r2,39076

    movhi r3, %hi(__bss_end)
  4641f8:	00c011f4 	movhi	r3,71
    ori r3, r3, %lo(__bss_end)
  4641fc:	18f38d14 	ori	r3,r3,52788

    beq r2, r3, 1f
  464200:	10c00326 	beq	r2,r3,464210 <_start+0x30>

0:
    stw zero, (r2)
  464204:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
  464208:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
  46420c:	10fffd36 	bltu	r2,r3,464204 <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
  464210:	0467d0c0 	call	467d0c <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
  464214:	0467eb00 	call	467eb0 <alt_main>

00464218 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
  464218:	003fff06 	br	464218 <alt_after_alt_main>

0046421c <handle_cpu1_interrupt>:
OS_EVENT* preempt_sem_3;
/*
 * Interrupt Handler and Initializer
 */
int count = 0;
static void handle_cpu1_interrupt(void* context) {
  46421c:	defffc04 	addi	sp,sp,-16
  464220:	dfc00315 	stw	ra,12(sp)
  464224:	d9000215 	stw	r4,8(sp)
	unsigned short task_id;
	altera_avalon_mutex_lock(mutex, 1);
  464228:	d0a6fa17 	ldw	r2,-25624(gp)
  46422c:	1009883a 	mov	r4,r2
  464230:	01400044 	movi	r5,1
  464234:	04732100 	call	473210 <altera_avalon_mutex_lock>
	{

		CriticalFunctionPointers* cp = (CriticalFunctionPointers*)SHARED_MEMORY_BASE;
  464238:	00809434 	movhi	r2,592
  46423c:	d8800015 	stw	r2,0(sp)
		task_id = cp->task_id0;
  464240:	d8800017 	ldw	r2,0(sp)
  464244:	1080030b 	ldhu	r2,12(r2)
  464248:	d880010d 	sth	r2,4(sp)
		*isr_0_ptr = 0;
  46424c:	d0a00017 	ldw	r2,-32768(gp)
  464250:	10000015 	stw	zero,0(r2)

	}
	altera_avalon_mutex_unlock(mutex);
  464254:	d0a6fa17 	ldw	r2,-25624(gp)
  464258:	1009883a 	mov	r4,r2
  46425c:	04732f80 	call	4732f8 <altera_avalon_mutex_unlock>
	if(task_id == CRITICAL_TASK_PRIORITY)
  464260:	d880010b 	ldhu	r2,4(sp)
  464264:	10800158 	cmpnei	r2,r2,5
  464268:	1000041e 	bne	r2,zero,46427c <handle_cpu1_interrupt+0x60>
		OSSemPost(mbox);
  46426c:	d0a6f817 	ldw	r2,-25632(gp)
  464270:	1009883a 	mov	r4,r2
  464274:	046f54c0 	call	46f54c <OSSemPost>
  464278:	00001406 	br	4642cc <handle_cpu1_interrupt+0xb0>
	else if(task_id == PREEMPT_TASK_PRIORITY)
  46427c:	d880010b 	ldhu	r2,4(sp)
  464280:	10800118 	cmpnei	r2,r2,4
  464284:	1000041e 	bne	r2,zero,464298 <handle_cpu1_interrupt+0x7c>
		OSSemPost(preempt_sem);
  464288:	d0a6fd17 	ldw	r2,-25612(gp)
  46428c:	1009883a 	mov	r4,r2
  464290:	046f54c0 	call	46f54c <OSSemPost>
  464294:	00000d06 	br	4642cc <handle_cpu1_interrupt+0xb0>
	else if(task_id == PREEMPT_TASK_PRIORITY_2)
  464298:	d880010b 	ldhu	r2,4(sp)
  46429c:	10800098 	cmpnei	r2,r2,2
  4642a0:	1000041e 	bne	r2,zero,4642b4 <handle_cpu1_interrupt+0x98>
		OSSemPost(preempt_sem_2);
  4642a4:	d0a6f717 	ldw	r2,-25636(gp)
  4642a8:	1009883a 	mov	r4,r2
  4642ac:	046f54c0 	call	46f54c <OSSemPost>
  4642b0:	00000606 	br	4642cc <handle_cpu1_interrupt+0xb0>
	else if(task_id == PREEMPT_TASK_PRIORITY_3)
  4642b4:	d880010b 	ldhu	r2,4(sp)
  4642b8:	108000d8 	cmpnei	r2,r2,3
  4642bc:	1000031e 	bne	r2,zero,4642cc <handle_cpu1_interrupt+0xb0>
		OSSemPost(preempt_sem_3);
  4642c0:	d0a6f917 	ldw	r2,-25628(gp)
  4642c4:	1009883a 	mov	r4,r2
  4642c8:	046f54c0 	call	46f54c <OSSemPost>
}
  4642cc:	dfc00317 	ldw	ra,12(sp)
  4642d0:	dec00404 	addi	sp,sp,16
  4642d4:	f800283a 	ret

004642d8 <init_cpu1_isr>:

static void init_cpu1_isr(void) {
  4642d8:	defffe04 	addi	sp,sp,-8
  4642dc:	dfc00115 	stw	ra,4(sp)
	alt_ic_isr_register(PROCESSOR0_0_CPU_IRQ_0_IRQ_INTERRUPT_CONTROLLER_ID,
  4642e0:	d8000015 	stw	zero,0(sp)
  4642e4:	0009883a 	mov	r4,zero
  4642e8:	01400044 	movi	r5,1
  4642ec:	018011b4 	movhi	r6,70
  4642f0:	31908704 	addi	r6,r6,16924
  4642f4:	000f883a 	mov	r7,zero
  4642f8:	04678600 	call	467860 <alt_ic_isr_register>
			PROCESSOR0_0_CPU_IRQ_0_IRQ, handle_cpu1_interrupt, (void*) NULL,
			(void*) NULL);
}
  4642fc:	dfc00117 	ldw	ra,4(sp)
  464300:	dec00204 	addi	sp,sp,8
  464304:	f800283a 	ret

00464308 <preemption_task>:
 * waiting for an activation message. This is necessary
 * to guarantee the stack matches on both cores.
 */

INT8U err;
void preemption_task(void* pdata){
  464308:	deffee04 	addi	sp,sp,-72
  46430c:	dfc01115 	stw	ra,68(sp)
  464310:	d9001015 	stw	r4,64(sp)
	int* p = pdata;
  464314:	d8801017 	ldw	r2,64(sp)
  464318:	d8800215 	stw	r2,8(sp)
	int priority = *p;
  46431c:	d8800217 	ldw	r2,8(sp)
  464320:	10800017 	ldw	r2,0(r2)
  464324:	d8800315 	stw	r2,12(sp)
	void (*pt)(int) = (void*)*(p + 1);
  464328:	d8800217 	ldw	r2,8(sp)
  46432c:	10800104 	addi	r2,r2,4
  464330:	10800017 	ldw	r2,0(r2)
  464334:	d8800415 	stw	r2,16(sp)

	while(1){
		if(priority == PREEMPT_TASK_PRIORITY)
  464338:	d8800317 	ldw	r2,12(sp)
  46433c:	10800118 	cmpnei	r2,r2,4
  464340:	1000061e 	bne	r2,zero,46435c <preemption_task+0x54>
			OSSemPend(preempt_sem, 0, &err);
  464344:	d0a6fd17 	ldw	r2,-25612(gp)
  464348:	1009883a 	mov	r4,r2
  46434c:	000b883a 	mov	r5,zero
  464350:	d1a6fc04 	addi	r6,gp,-25616
  464354:	046f0900 	call	46f090 <OSSemPend>
  464358:	00001a06 	br	4643c4 <preemption_task+0xbc>
		else if(priority == PREEMPT_TASK_PRIORITY_2)
  46435c:	d8800317 	ldw	r2,12(sp)
  464360:	10800098 	cmpnei	r2,r2,2
  464364:	1000061e 	bne	r2,zero,464380 <preemption_task+0x78>
			OSSemPend(preempt_sem_2, 0, &err);
  464368:	d0a6f717 	ldw	r2,-25636(gp)
  46436c:	1009883a 	mov	r4,r2
  464370:	000b883a 	mov	r5,zero
  464374:	d1a6fc04 	addi	r6,gp,-25616
  464378:	046f0900 	call	46f090 <OSSemPend>
  46437c:	00001106 	br	4643c4 <preemption_task+0xbc>
		else if(priority == PREEMPT_TASK_PRIORITY_3)
  464380:	d8800317 	ldw	r2,12(sp)
  464384:	108000d8 	cmpnei	r2,r2,3
  464388:	1000061e 	bne	r2,zero,4643a4 <preemption_task+0x9c>
			OSSemPend(preempt_sem_3, 0, &err);
  46438c:	d0a6f917 	ldw	r2,-25628(gp)
  464390:	1009883a 	mov	r4,r2
  464394:	000b883a 	mov	r5,zero
  464398:	d1a6fc04 	addi	r6,gp,-25616
  46439c:	046f0900 	call	46f090 <OSSemPend>
  4643a0:	00000806 	br	4643c4 <preemption_task+0xbc>
		else if(priority == CRITICAL_TASK_PRIORITY)
  4643a4:	d8800317 	ldw	r2,12(sp)
  4643a8:	10800158 	cmpnei	r2,r2,5
  4643ac:	1000051e 	bne	r2,zero,4643c4 <preemption_task+0xbc>
			OSSemPend(mbox, 0, &err);
  4643b0:	d0a6f817 	ldw	r2,-25632(gp)
  4643b4:	1009883a 	mov	r4,r2
  4643b8:	000b883a 	mov	r5,zero
  4643bc:	d1a6fc04 	addi	r6,gp,-25616
  4643c0:	046f0900 	call	46f090 <OSSemPend>



		int done = 0;
  4643c4:	d8000015 	stw	zero,0(sp)
		int first = 0;
  4643c8:	d8000115 	stw	zero,4(sp)
		//barrier function
		CriticalFunctionPointers* cp =
  4643cc:	00809434 	movhi	r2,592
  4643d0:	d8800515 	stw	r2,20(sp)
				(CriticalFunctionPointers*) SHARED_MEMORY_BASE;
		while (done == 0) {
  4643d4:	00001606 	br	464430 <preemption_task+0x128>
			altera_avalon_mutex_lock(mutex, 1); //Acquire the hardware mutex
  4643d8:	d0a6fa17 	ldw	r2,-25624(gp)
  4643dc:	1009883a 	mov	r4,r2
  4643e0:	01400044 	movi	r5,1
  4643e4:	04732100 	call	473210 <altera_avalon_mutex_lock>
			{
				if(first == 0){
  4643e8:	d8800117 	ldw	r2,4(sp)
  4643ec:	1000051e 	bne	r2,zero,464404 <preemption_task+0xfc>
					cp->checkout0 = 1;
  4643f0:	d8800517 	ldw	r2,20(sp)
  4643f4:	00c00044 	movi	r3,1
  4643f8:	10c00815 	stw	r3,32(r2)
					first = 1;
  4643fc:	00800044 	movi	r2,1
  464400:	d8800115 	stw	r2,4(sp)
				}
				if( cp->checkout1 == 1){
  464404:	d8800517 	ldw	r2,20(sp)
  464408:	10800917 	ldw	r2,36(r2)
  46440c:	10800058 	cmpnei	r2,r2,1
  464410:	1000041e 	bne	r2,zero,464424 <preemption_task+0x11c>
					cp->checkout1 = 0;
  464414:	d8800517 	ldw	r2,20(sp)
  464418:	10000915 	stw	zero,36(r2)
					done = 1;
  46441c:	00800044 	movi	r2,1
  464420:	d8800015 	stw	r2,0(sp)
				}

			}
			altera_avalon_mutex_unlock(mutex);
  464424:	d0a6fa17 	ldw	r2,-25624(gp)
  464428:	1009883a 	mov	r4,r2
  46442c:	04732f80 	call	4732f8 <altera_avalon_mutex_unlock>
		int done = 0;
		int first = 0;
		//barrier function
		CriticalFunctionPointers* cp =
				(CriticalFunctionPointers*) SHARED_MEMORY_BASE;
		while (done == 0) {
  464430:	d8800017 	ldw	r2,0(sp)
  464434:	103fe826 	beq	r2,zero,4643d8 <preemption_task+0xd0>
				}

			}
			altera_avalon_mutex_unlock(mutex);
		}
		if (alt_timestamp_start() < 0)
  464438:	047354c0 	call	47354c <alt_timestamp_start>
  46443c:	1000030e 	bge	r2,zero,46444c <preemption_task+0x144>
				{
				printf ("No timestamp device available\n");
  464440:	010011f4 	movhi	r4,71
  464444:	2117f104 	addi	r4,r4,24516
  464448:	0464b580 	call	464b58 <puts>
				}

				long registers[8];
				context_switch(registers);
  46444c:	d8800804 	addi	r2,sp,32
  464450:	1009883a 	mov	r4,r2
  464454:	0464a480 	call	464a48 <context_switch>
				set_gp();
  464458:	0464abc0 	call	464abc <set_gp>
				pt(priority);
  46445c:	d8800417 	ldw	r2,16(sp)
  464460:	d9000317 	ldw	r4,12(sp)
  464464:	103ee83a 	callr	r2
				restore_gp();
  464468:	0464ac80 	call	464ac8 <restore_gp>
				context_restore(registers);
  46446c:	d8800804 	addi	r2,sp,32
  464470:	1009883a 	mov	r4,r2
  464474:	0464a8c0 	call	464a8c <context_restore>
				alt_u64 t = alt_timestamp();
  464478:	04735f40 	call	4735f4 <alt_timestamp>
  46447c:	d8800615 	stw	r2,24(sp)
  464480:	d8c00715 	stw	r3,28(sp)
				cp->core_time[0] = t;
  464484:	d8800517 	ldw	r2,20(sp)
  464488:	d8c00617 	ldw	r3,24(sp)
  46448c:	10c01a15 	stw	r3,104(r2)
  464490:	d8c00717 	ldw	r3,28(sp)
  464494:	10c01b15 	stw	r3,108(r2)
	}
  464498:	003fa706 	br	464338 <preemption_task+0x30>

0046449c <init_tlb>:
}

void init_tlb(){
  46449c:	deffff04 	addi	sp,sp,-4
  4644a0:	dfc00015 	stw	ra,0(sp)
	set_cputable_entry(0, 0x00431000);
  4644a4:	0009883a 	mov	r4,zero
  4644a8:	014010f4 	movhi	r5,67
  4644ac:	29440004 	addi	r5,r5,4096
  4644b0:	04647300 	call	464730 <set_cputable_entry>
	set_spmtable_entry(0, 0x04203000);
  4644b4:	0009883a 	mov	r4,zero
  4644b8:	01410834 	movhi	r5,1056
  4644bc:	294c0004 	addi	r5,r5,12288
  4644c0:	046478c0 	call	46478c <set_spmtable_entry>

	//Enable these 4 translations
	set_enable(0x1);
  4644c4:	01000044 	movi	r4,1
  4644c8:	04646b00 	call	4646b0 <set_enable>

}
  4644cc:	dfc00017 	ldw	ra,0(sp)
  4644d0:	dec00104 	addi	sp,sp,4
  4644d4:	f800283a 	ret

004644d8 <main>:


/*
 * Main
 */
int main(void) {
  4644d8:	defff604 	addi	sp,sp,-40
  4644dc:	dfc00915 	stw	ra,36(sp)

	init_tlb();
  4644e0:	046449c0 	call	46449c <init_tlb>
	enable_tlb();
  4644e4:	04646280 	call	464628 <enable_tlb>
	void (*pt)(int);
	 printf("Hello from Nios II!\n");
  4644e8:	010011f4 	movhi	r4,71
  4644ec:	2117f904 	addi	r4,r4,24548
  4644f0:	0464b580 	call	464b58 <puts>
		mutex = altera_avalon_mutex_open(MUTEX_0_NAME);			//Initialize the hardware mutex
  4644f4:	010011f4 	movhi	r4,71
  4644f8:	2117fe04 	addi	r4,r4,24568
  4644fc:	047319c0 	call	47319c <altera_avalon_mutex_open>
  464500:	d0a6fa15 	stw	r2,-25624(gp)
		mbox = OSSemCreate(0);				//Initialize the message box
  464504:	0009883a 	mov	r4,zero
  464508:	046ec440 	call	46ec44 <OSSemCreate>
  46450c:	d0a6f815 	stw	r2,-25632(gp)
		preempt_sem = OSSemCreate(0);
  464510:	0009883a 	mov	r4,zero
  464514:	046ec440 	call	46ec44 <OSSemCreate>
  464518:	d0a6fd15 	stw	r2,-25612(gp)
		preempt_sem_2 = OSSemCreate(0);
  46451c:	0009883a 	mov	r4,zero
  464520:	046ec440 	call	46ec44 <OSSemCreate>
  464524:	d0a6f715 	stw	r2,-25636(gp)
		preempt_sem_3 = OSSemCreate(0);
  464528:	0009883a 	mov	r4,zero
  46452c:	046ec440 	call	46ec44 <OSSemCreate>
  464530:	d0a6f915 	stw	r2,-25628(gp)
		CriticalFunctionPointers* cp = (CriticalFunctionPointers*)SHARED_MEMORY_BASE;
  464534:	00809434 	movhi	r2,592
  464538:	d8800515 	stw	r2,20(sp)
		while(cp->init_complete == 0);
  46453c:	0001883a 	nop
  464540:	d8800517 	ldw	r2,20(sp)
  464544:	10800717 	ldw	r2,28(r2)
  464548:	103ffd26 	beq	r2,zero,464540 <main+0x68>
		altera_avalon_mutex_lock(mutex, 1);				//Acquire the hardware mutex
  46454c:	d0a6fa17 	ldw	r2,-25624(gp)
  464550:	1009883a 	mov	r4,r2
  464554:	01400044 	movi	r5,1
  464558:	04732100 	call	473210 <altera_avalon_mutex_lock>
		{


			ct = cp->critical;
  46455c:	d8800517 	ldw	r2,20(sp)
  464560:	10800117 	ldw	r2,4(r2)
  464564:	d0a6fb15 	stw	r2,-25620(gp)
			pt = cp->preempt;
  464568:	d8800517 	ldw	r2,20(sp)
  46456c:	10800217 	ldw	r2,8(r2)
  464570:	d8800615 	stw	r2,24(sp)
		}
		altera_avalon_mutex_unlock(mutex);				//Memory
  464574:	d0a6fa17 	ldw	r2,-25624(gp)
  464578:	1009883a 	mov	r4,r2
  46457c:	04732f80 	call	4732f8 <altera_avalon_mutex_unlock>


	init_cpu1_isr();										//Initialize the ISR
  464580:	04642d80 	call	4642d8 <init_cpu1_isr>

	fprint_set_block_size(0x3ff);
  464584:	0100ffc4 	movi	r4,1023
  464588:	04649400 	call	464940 <fprint_set_block_size>



	void* arg_5[2] = {(void*)CRITICAL_TASK_PRIORITY,pt};
  46458c:	00800144 	movi	r2,5
  464590:	d8800715 	stw	r2,28(sp)
  464594:	d8800617 	ldw	r2,24(sp)
  464598:	d8800815 	stw	r2,32(sp)
		OSTaskCreateExt(preemption_task, &arg_5, &critical_task_stk[TASK_STACKSIZE - 1],
  46459c:	d8800704 	addi	r2,sp,28
  4645a0:	00c00144 	movi	r3,5
  4645a4:	d8c00015 	stw	r3,0(sp)
  4645a8:	00c10834 	movhi	r3,1056
  4645ac:	18c00004 	addi	r3,r3,0
  4645b0:	d8c00115 	stw	r3,4(sp)
  4645b4:	00c10004 	movi	r3,1024
  4645b8:	d8c00215 	stw	r3,8(sp)
  4645bc:	d8000315 	stw	zero,12(sp)
  4645c0:	d8000415 	stw	zero,16(sp)
  4645c4:	010011b4 	movhi	r4,70
  4645c8:	2110c204 	addi	r4,r4,17160
  4645cc:	100b883a 	mov	r5,r2
  4645d0:	01810834 	movhi	r6,1056
  4645d4:	3183ff04 	addi	r6,r6,4092
  4645d8:	01c00144 	movi	r7,5
  4645dc:	04701940 	call	470194 <OSTaskCreateExt>
//				PREEMPT_TASK_PRIORITY_2, PREEMPT_TASK_PRIORITY_2, preempt_task_stk_2, TASK_STACKSIZE, NULL,0);
//	void* arg_3[2] = {(void*)PREEMPT_TASK_PRIORITY_3,pt};
//		OSTaskCreateExt(preemption_task, (void*) &arg_3, (void *) &preempt_task_stk_3[TASK_STACKSIZE - 1],
//				PREEMPT_TASK_PRIORITY_3, PREEMPT_TASK_PRIORITY_3, preempt_task_stk_3, TASK_STACKSIZE, NULL,0);
	//Start OS
	altera_avalon_mutex_lock(mutex, 1);				//Acquire the hardware mutex
  4645e0:	d0a6fa17 	ldw	r2,-25624(gp)
  4645e4:	1009883a 	mov	r4,r2
  4645e8:	01400044 	movi	r5,1
  4645ec:	04732100 	call	473210 <altera_avalon_mutex_lock>
	{
		cp->core0_ready = 1;
  4645f0:	d8800517 	ldw	r2,20(sp)
  4645f4:	00c00044 	movi	r3,1
  4645f8:	10c01215 	stw	r3,72(r2)
	}
	altera_avalon_mutex_unlock(mutex);				//Memory
  4645fc:	d0a6fa17 	ldw	r2,-25624(gp)
  464600:	1009883a 	mov	r4,r2
  464604:	04732f80 	call	4732f8 <altera_avalon_mutex_unlock>

	OSStart();
  464608:	04696580 	call	469658 <OSStart>
	return 0;
  46460c:	0005883a 	mov	r2,zero
}
  464610:	dfc00917 	ldw	ra,36(sp)
  464614:	dec00a04 	addi	sp,sp,40
  464618:	f800283a 	ret

0046461c <disable_tlb>:
unsigned int *TLB_ACTIVATE_REG = (unsigned int*)(TLB_BASE + (TLB_SEL_OFFSET << 2));
/*
 * Disables the TLB by setting its control register to 0.
 */
void disable_tlb() {
	*TLB_ACTIVATE_REG = 0x00000000;
  46461c:	d0a00517 	ldw	r2,-32748(gp)
  464620:	10000015 	stw	zero,0(r2)
}
  464624:	f800283a 	ret

00464628 <enable_tlb>:

/*
 * Enables the TLB by setting its control register to a non-zero value.
 */
void enable_tlb() {
	*TLB_ACTIVATE_REG = 0x00001000;
  464628:	d0a00517 	ldw	r2,-32748(gp)
  46462c:	00c40004 	movi	r3,4096
  464630:	10c00015 	stw	r3,0(r2)
}
  464634:	f800283a 	ret

00464638 <reset_tlb>:

/*
 * Clears the entries in the CPU and SPM tables, starting with index 0
 * and ending before the position given by the 'count' variable.
 */
void reset_tlb(int count) {
  464638:	defffe04 	addi	sp,sp,-8
  46463c:	d9000115 	stw	r4,4(sp)
	int i = 0;
  464640:	d8000015 	stw	zero,0(sp)
	for(i = 0; i < count; i++) {
  464644:	d8000015 	stw	zero,0(sp)
  464648:	00000f06 	br	464688 <reset_tlb+0x50>
		*(VIRT_ADDR_TABLE + i) = 0;
  46464c:	d0e00317 	ldw	r3,-32756(gp)
  464650:	d8800017 	ldw	r2,0(sp)
  464654:	1085883a 	add	r2,r2,r2
  464658:	1085883a 	add	r2,r2,r2
  46465c:	1885883a 	add	r2,r3,r2
  464660:	10000015 	stw	zero,0(r2)
		*(PHYS_ADDR_TABLE + i) = 0;
  464664:	d0e00417 	ldw	r3,-32752(gp)
  464668:	d8800017 	ldw	r2,0(sp)
  46466c:	1085883a 	add	r2,r2,r2
  464670:	1085883a 	add	r2,r2,r2
  464674:	1885883a 	add	r2,r3,r2
  464678:	10000015 	stw	zero,0(r2)
 * Clears the entries in the CPU and SPM tables, starting with index 0
 * and ending before the position given by the 'count' variable.
 */
void reset_tlb(int count) {
	int i = 0;
	for(i = 0; i < count; i++) {
  46467c:	d8800017 	ldw	r2,0(sp)
  464680:	10800044 	addi	r2,r2,1
  464684:	d8800015 	stw	r2,0(sp)
  464688:	d8c00017 	ldw	r3,0(sp)
  46468c:	d8800117 	ldw	r2,4(sp)
  464690:	18bfee16 	blt	r3,r2,46464c <reset_tlb+0x14>
		*(VIRT_ADDR_TABLE + i) = 0;
		*(PHYS_ADDR_TABLE + i) = 0;
	}
}
  464694:	dec00204 	addi	sp,sp,8
  464698:	f800283a 	ret

0046469c <tlb_is_on>:

/*
 * Checks if the TLB is on or off.
 */
unsigned int tlb_is_on() {
	return (*TLB_ACTIVATE_REG != 0x00000000);
  46469c:	d0a00517 	ldw	r2,-32748(gp)
  4646a0:	10800017 	ldw	r2,0(r2)
  4646a4:	1004c03a 	cmpne	r2,r2,zero
  4646a8:	10803fcc 	andi	r2,r2,255
}
  4646ac:	f800283a 	ret

004646b0 <set_enable>:

/*
 * Turns on the selected bits in the Enable register.
 * Does not affect any other bits in the register.
 */
void set_enable(unsigned int line) {
  4646b0:	deffff04 	addi	sp,sp,-4
  4646b4:	d9000015 	stw	r4,0(sp)
	*LINE_ENABLE_REG = *LINE_ENABLE_REG | line;
  4646b8:	d0a00117 	ldw	r2,-32764(gp)
  4646bc:	d0e00117 	ldw	r3,-32764(gp)
  4646c0:	19000017 	ldw	r4,0(r3)
  4646c4:	d8c00017 	ldw	r3,0(sp)
  4646c8:	20c6b03a 	or	r3,r4,r3
  4646cc:	10c00015 	stw	r3,0(r2)
}
  4646d0:	dec00104 	addi	sp,sp,4
  4646d4:	f800283a 	ret

004646d8 <reset_enable>:

/*
 * Turns off every bit in the Enable register.
 */
void reset_enable() {
	*LINE_ENABLE_REG = 0;
  4646d8:	d0a00117 	ldw	r2,-32764(gp)
  4646dc:	10000015 	stw	zero,0(r2)
}
  4646e0:	f800283a 	ret

004646e4 <get_enable>:

/*
 * Returns the contents of the Enable register as an unsigned integer.
 */
unsigned int get_enable() {
	return(*LINE_ENABLE_REG);
  4646e4:	d0a00117 	ldw	r2,-32764(gp)
  4646e8:	10800017 	ldw	r2,0(r2)
}
  4646ec:	f800283a 	ret

004646f0 <set_valid>:

/*
 * Turns on the selected bits in the Valid register.
 * Does not affect any other bits in the register.
 */
void set_valid(unsigned int line) {
  4646f0:	deffff04 	addi	sp,sp,-4
  4646f4:	d9000015 	stw	r4,0(sp)
	*LINE_VALID_REG = *LINE_VALID_REG | line;
  4646f8:	d0a00217 	ldw	r2,-32760(gp)
  4646fc:	d0e00217 	ldw	r3,-32760(gp)
  464700:	19000017 	ldw	r4,0(r3)
  464704:	d8c00017 	ldw	r3,0(sp)
  464708:	20c6b03a 	or	r3,r4,r3
  46470c:	10c00015 	stw	r3,0(r2)
}
  464710:	dec00104 	addi	sp,sp,4
  464714:	f800283a 	ret

00464718 <reset_valid>:

/*
 * Turns off every bit in the Valid register.
 */
void reset_valid() {
	*LINE_VALID_REG = 0;
  464718:	d0a00217 	ldw	r2,-32760(gp)
  46471c:	10000015 	stw	zero,0(r2)
}
  464720:	f800283a 	ret

00464724 <get_valid>:

/*
 * Returns the contents of the Valid register as an unsigned integer.
 */
unsigned int get_valid() {
	return(*LINE_VALID_REG);
  464724:	d0a00217 	ldw	r2,-32760(gp)
  464728:	10800017 	ldw	r2,0(r2)
}
  46472c:	f800283a 	ret

00464730 <set_cputable_entry>:
/*
 * Takes an address, and writes its tag to a specific entry in the CPU table, where
 *'index' is the position that will be written to, relative to the address pointed
 * to by the CTRL_2 pointer (i.e. index 0 of the CPU table).
 */
void set_cputable_entry(int index, unsigned int address) {
  464730:	defffe04 	addi	sp,sp,-8
  464734:	d9000015 	stw	r4,0(sp)
  464738:	d9400115 	stw	r5,4(sp)
	*(VIRT_ADDR_TABLE + index) = (address  >> PAGE_SIZE);
  46473c:	d0e00317 	ldw	r3,-32756(gp)
  464740:	d8800017 	ldw	r2,0(sp)
  464744:	1085883a 	add	r2,r2,r2
  464748:	1085883a 	add	r2,r2,r2
  46474c:	1885883a 	add	r2,r3,r2
  464750:	d8c00117 	ldw	r3,4(sp)
  464754:	1806d33a 	srli	r3,r3,12
  464758:	10c00015 	stw	r3,0(r2)

}
  46475c:	dec00204 	addi	sp,sp,8
  464760:	f800283a 	ret

00464764 <get_cputable_entry>:

/*
 * Reads the contents of the CPU table at the specified index, relative to the
 * address pointed to by the CTRL_2 pointer.
 */
unsigned int get_cputable_entry(int index) {
  464764:	deffff04 	addi	sp,sp,-4
  464768:	d9000015 	stw	r4,0(sp)
	return *(VIRT_ADDR_TABLE + index);
  46476c:	d0e00317 	ldw	r3,-32756(gp)
  464770:	d8800017 	ldw	r2,0(sp)
  464774:	1085883a 	add	r2,r2,r2
  464778:	1085883a 	add	r2,r2,r2
  46477c:	1885883a 	add	r2,r3,r2
  464780:	10800017 	ldw	r2,0(r2)
}
  464784:	dec00104 	addi	sp,sp,4
  464788:	f800283a 	ret

0046478c <set_spmtable_entry>:
/*
 * Takes an address, and writes its tag to a specific entry in the SPM table,
 * where 'index' is the position that will be written to, relative to the address
 * pointed to by the CTRL_3 pointer (i.e. index 0 of the SPM table).
 */
void set_spmtable_entry(int index, unsigned int address) {
  46478c:	defffe04 	addi	sp,sp,-8
  464790:	d9000015 	stw	r4,0(sp)
  464794:	d9400115 	stw	r5,4(sp)
	*(PHYS_ADDR_TABLE + index) = (address  >> PAGE_SIZE);
  464798:	d0e00417 	ldw	r3,-32752(gp)
  46479c:	d8800017 	ldw	r2,0(sp)
  4647a0:	1085883a 	add	r2,r2,r2
  4647a4:	1085883a 	add	r2,r2,r2
  4647a8:	1885883a 	add	r2,r3,r2
  4647ac:	d8c00117 	ldw	r3,4(sp)
  4647b0:	1806d33a 	srli	r3,r3,12
  4647b4:	10c00015 	stw	r3,0(r2)
}
  4647b8:	dec00204 	addi	sp,sp,8
  4647bc:	f800283a 	ret

004647c0 <get_spmtable_entry>:

/*
 * Reads the contents of the SPM table at the specified index, relative to the
 * address pointed to by the CTRL_3 pointer.
 */
unsigned int get_spmtable_entry(int index) {
  4647c0:	deffff04 	addi	sp,sp,-4
  4647c4:	d9000015 	stw	r4,0(sp)
	return *(PHYS_ADDR_TABLE + index);
  4647c8:	d0e00417 	ldw	r3,-32752(gp)
  4647cc:	d8800017 	ldw	r2,0(sp)
  4647d0:	1085883a 	add	r2,r2,r2
  4647d4:	1085883a 	add	r2,r2,r2
  4647d8:	1885883a 	add	r2,r3,r2
  4647dc:	10800017 	ldw	r2,0(r2)
}
  4647e0:	dec00104 	addi	sp,sp,4
  4647e4:	f800283a 	ret

004647e8 <set_task_directory>:
//*********************************

#define COMPARATOR_BASE_ADDRESS CFPU_0_CSR_BASE
#define FPRINT_BASE_ADDRESS		0x8100000

void set_task_directory(Directory_Init_Struct* d){
  4647e8:	defffd04 	addi	sp,sp,-12
  4647ec:	d9000215 	stw	r4,8(sp)

	//Place the start pointer for the given task
	uint32_t* start = (uint32_t*)(COMPARATOR_BASE_ADDRESS \
			+ CRC_DIRECTORY_START_BASE) + d->key + (d->core_id << 6);
  4647f0:	d8800217 	ldw	r2,8(sp)
  4647f4:	10c00217 	ldw	r3,8(r2)
  4647f8:	d8800217 	ldw	r2,8(sp)
  4647fc:	10800317 	ldw	r2,12(r2)
  464800:	100491ba 	slli	r2,r2,6
  464804:	1885883a 	add	r2,r3,r2
  464808:	1085883a 	add	r2,r2,r2
  46480c:	1085883a 	add	r2,r2,r2
  464810:	1007883a 	mov	r3,r2
#define FPRINT_BASE_ADDRESS		0x8100000

void set_task_directory(Directory_Init_Struct* d){

	//Place the start pointer for the given task
	uint32_t* start = (uint32_t*)(COMPARATOR_BASE_ADDRESS \
  464814:	00809034 	movhi	r2,576
  464818:	10801004 	addi	r2,r2,64
  46481c:	1885883a 	add	r2,r3,r2
  464820:	d8800015 	stw	r2,0(sp)
			+ CRC_DIRECTORY_START_BASE) + d->key + (d->core_id << 6);
	*start = d->start_ptr;
  464824:	d8800217 	ldw	r2,8(sp)
  464828:	10c00017 	ldw	r3,0(r2)
  46482c:	d8800017 	ldw	r2,0(sp)
  464830:	10c00015 	stw	r3,0(r2)
	//Place the end pointer for the given task
	uint32_t* end   = (uint32_t*)(COMPARATOR_BASE_ADDRESS \
			+ CRC_DIRECTORY_END_BASE) + d->key + (d->core_id << 6);
  464834:	d8800217 	ldw	r2,8(sp)
  464838:	10c00217 	ldw	r3,8(r2)
  46483c:	d8800217 	ldw	r2,8(sp)
  464840:	10800317 	ldw	r2,12(r2)
  464844:	100491ba 	slli	r2,r2,6
  464848:	1885883a 	add	r2,r3,r2
  46484c:	1085883a 	add	r2,r2,r2
  464850:	1085883a 	add	r2,r2,r2
  464854:	1007883a 	mov	r3,r2
	//Place the start pointer for the given task
	uint32_t* start = (uint32_t*)(COMPARATOR_BASE_ADDRESS \
			+ CRC_DIRECTORY_START_BASE) + d->key + (d->core_id << 6);
	*start = d->start_ptr;
	//Place the end pointer for the given task
	uint32_t* end   = (uint32_t*)(COMPARATOR_BASE_ADDRESS \
  464858:	00809034 	movhi	r2,576
  46485c:	10802004 	addi	r2,r2,128
  464860:	1885883a 	add	r2,r3,r2
  464864:	d8800115 	stw	r2,4(sp)
			+ CRC_DIRECTORY_END_BASE) + d->key + (d->core_id << 6);
	*end = d->end_ptr;
  464868:	d8800217 	ldw	r2,8(sp)
  46486c:	10c00117 	ldw	r3,4(r2)
  464870:	d8800117 	ldw	r2,4(sp)
  464874:	10c00015 	stw	r3,0(r2)

}
  464878:	dec00304 	addi	sp,sp,12
  46487c:	f800283a 	ret

00464880 <enable_fprint_task>:


void enable_fprint_task(int task){
  464880:	defffe04 	addi	sp,sp,-8
  464884:	d9000115 	stw	r4,4(sp)
	//When enabling, the current state register
	//takes the key with a 1 in the MSB.
	uint32_t* fprint_currentstate = (uint32_t*)(FPRINT_BASE_ADDRESS \
  464888:	00820434 	movhi	r2,2064
  46488c:	d8800015 	stw	r2,0(sp)
											+ FPRINT_SPR_CURRENTSTATE);
	*fprint_currentstate = 0x10 | task;
  464890:	d8800117 	ldw	r2,4(sp)
  464894:	10800414 	ori	r2,r2,16
  464898:	1007883a 	mov	r3,r2
  46489c:	d8800017 	ldw	r2,0(sp)
  4648a0:	10c00015 	stw	r3,0(r2)

}
  4648a4:	dec00204 	addi	sp,sp,8
  4648a8:	f800283a 	ret

004648ac <disable_fprint_task>:
void disable_fprint_task(int task){
  4648ac:	defffe04 	addi	sp,sp,-8
  4648b0:	d9000115 	stw	r4,4(sp)

	//When a task is checked in, the task number
	//must be rewritten to the current state register
	//with the MSB set to 0.
	uint32_t* fprint_currentstate = (uint32_t*)(FPRINT_BASE_ADDRESS \
  4648b4:	00820434 	movhi	r2,2064
  4648b8:	d8800015 	stw	r2,0(sp)
											+ FPRINT_SPR_CURRENTSTATE);
	*fprint_currentstate = task;
  4648bc:	d8c00117 	ldw	r3,4(sp)
  4648c0:	d8800017 	ldw	r2,0(sp)
  4648c4:	10c00015 	stw	r3,0(r2)

}
  4648c8:	dec00204 	addi	sp,sp,8
  4648cc:	f800283a 	ret

004648d0 <fprint_reset_irq>:
void fprint_reset_irq(void){
  4648d0:	deffff04 	addi	sp,sp,-4
	//In the case of a collision
	//Reset the exception register in the fingerprint unit.
	uint32_t* fprint_collision = (uint32_t*)(COMPARATOR_BASE_ADDRESS \
  4648d4:	00809034 	movhi	r2,576
  4648d8:	10803004 	addi	r2,r2,192
  4648dc:	d8800015 	stw	r2,0(sp)
											+ COMPARATOR_EXCEPTION_OFFSET);
	*fprint_collision = 0;
  4648e0:	d8800017 	ldw	r2,0(sp)
  4648e4:	10000015 	stw	zero,0(r2)
}
  4648e8:	dec00104 	addi	sp,sp,4
  4648ec:	f800283a 	ret

004648f0 <fprint_status>:

int fprint_status(Fprint_Status* fps){
  4648f0:	defffe04 	addi	sp,sp,-8
  4648f4:	d9000115 	stw	r4,4(sp)
		Fprint_Status* f = (uint32_t*)(COMPARATOR_BASE_ADDRESS \
  4648f8:	00809034 	movhi	r2,576
  4648fc:	10803004 	addi	r2,r2,192
  464900:	d8800015 	stw	r2,0(sp)
												+ COMPARATOR_EXCEPTION_OFFSET);
		fps->status_reg = f->status_reg;
  464904:	d8800017 	ldw	r2,0(sp)
  464908:	10c00017 	ldw	r3,0(r2)
  46490c:	d8800117 	ldw	r2,4(sp)
  464910:	10c00015 	stw	r3,0(r2)
		fps->successful_reg = f->successful_reg;
  464914:	d8800017 	ldw	r2,0(sp)
  464918:	10c00117 	ldw	r3,4(r2)
  46491c:	d8800117 	ldw	r2,4(sp)
  464920:	10c00115 	stw	r3,4(r2)
		fps->failed_reg = f->failed_reg;
  464924:	d8800017 	ldw	r2,0(sp)
  464928:	10c00217 	ldw	r3,8(r2)
  46492c:	d8800117 	ldw	r2,4(sp)
  464930:	10c00215 	stw	r3,8(r2)
		return 0;
  464934:	0005883a 	mov	r2,zero

}
  464938:	dec00204 	addi	sp,sp,8
  46493c:	f800283a 	ret

00464940 <fprint_set_block_size>:
//	int x = *fprint_collision;
//	return x;
//
//}

void fprint_set_block_size(int size){
  464940:	defffe04 	addi	sp,sp,-8
  464944:	d9000115 	stw	r4,4(sp)
	uint32_t* fprint_blocksize_reg = (uint32_t*)(FPRINT_BASE_ADDRESS \
  464948:	00820434 	movhi	r2,2064
  46494c:	10800404 	addi	r2,r2,16
  464950:	d8800015 	stw	r2,0(sp)
												+ 0x10);

	*fprint_blocksize_reg = size;
  464954:	d8c00117 	ldw	r3,4(sp)
  464958:	d8800017 	ldw	r2,0(sp)
  46495c:	10c00015 	stw	r3,0(r2)

}
  464960:	dec00204 	addi	sp,sp,8
  464964:	f800283a 	ret

00464968 <set_core_assignment>:

void set_core_assignment(int table_column, int core_id, int task_id){
  464968:	defffc04 	addi	sp,sp,-16
  46496c:	d9000115 	stw	r4,4(sp)
  464970:	d9400215 	stw	r5,8(sp)
  464974:	d9800315 	stw	r6,12(sp)
	uint32_t* fprint_core_entry = (uint32_t*)(COMPARATOR_BASE_ADDRESS \
													+ (table_column << 8) + COMPARATOR_CORE_ASSIGNMENT_OFFSET);
  464978:	d8800117 	ldw	r2,4(sp)
  46497c:	1006923a 	slli	r3,r2,8
  464980:	00809034 	movhi	r2,576
  464984:	10803404 	addi	r2,r2,208
  464988:	1885883a 	add	r2,r3,r2
	*fprint_blocksize_reg = size;

}

void set_core_assignment(int table_column, int core_id, int task_id){
	uint32_t* fprint_core_entry = (uint32_t*)(COMPARATOR_BASE_ADDRESS \
  46498c:	d8800015 	stw	r2,0(sp)
													+ (table_column << 8) + COMPARATOR_CORE_ASSIGNMENT_OFFSET);

    *fprint_core_entry = (task_id << 4) + core_id;
  464990:	d8800317 	ldw	r2,12(sp)
  464994:	1006913a 	slli	r3,r2,4
  464998:	d8800217 	ldw	r2,8(sp)
  46499c:	1885883a 	add	r2,r3,r2
  4649a0:	1007883a 	mov	r3,r2
  4649a4:	d8800017 	ldw	r2,0(sp)
  4649a8:	10c00015 	stw	r3,0(r2)
}
  4649ac:	dec00404 	addi	sp,sp,16
  4649b0:	f800283a 	ret

004649b4 <set_core_assignment_table>:

void set_core_assignment_table(Core_Assignment_Table* ca){
  4649b4:	defffb04 	addi	sp,sp,-20
  4649b8:	dfc00415 	stw	ra,16(sp)
  4649bc:	d9000315 	stw	r4,12(sp)

	int i,j;
	for(i = 0; i < CA_TABLE_MAX_REDUNDANCY; i++){
  4649c0:	d8000015 	stw	zero,0(sp)
  4649c4:	00001a06 	br	464a30 <set_core_assignment_table+0x7c>
		for(j = 0; j < CA_TABLE_NUM_TASKS; j++){
  4649c8:	d8000115 	stw	zero,4(sp)
  4649cc:	00001206 	br	464a18 <set_core_assignment_table+0x64>
			uint32_t a = ca->table[i][j];
  4649d0:	d8c00317 	ldw	r3,12(sp)
  4649d4:	d8800017 	ldw	r2,0(sp)
  4649d8:	1008913a 	slli	r4,r2,4
  4649dc:	d8800117 	ldw	r2,4(sp)
  4649e0:	2085883a 	add	r2,r4,r2
  4649e4:	1085883a 	add	r2,r2,r2
  4649e8:	1085883a 	add	r2,r2,r2
  4649ec:	1885883a 	add	r2,r3,r2
  4649f0:	10800017 	ldw	r2,0(r2)
  4649f4:	d8800215 	stw	r2,8(sp)
			set_core_assignment(i,a,j);
  4649f8:	d8800217 	ldw	r2,8(sp)
  4649fc:	d9000017 	ldw	r4,0(sp)
  464a00:	100b883a 	mov	r5,r2
  464a04:	d9800117 	ldw	r6,4(sp)
  464a08:	04649680 	call	464968 <set_core_assignment>

void set_core_assignment_table(Core_Assignment_Table* ca){

	int i,j;
	for(i = 0; i < CA_TABLE_MAX_REDUNDANCY; i++){
		for(j = 0; j < CA_TABLE_NUM_TASKS; j++){
  464a0c:	d8800117 	ldw	r2,4(sp)
  464a10:	10800044 	addi	r2,r2,1
  464a14:	d8800115 	stw	r2,4(sp)
  464a18:	d8800117 	ldw	r2,4(sp)
  464a1c:	10800410 	cmplti	r2,r2,16
  464a20:	103feb1e 	bne	r2,zero,4649d0 <set_core_assignment_table+0x1c>
}

void set_core_assignment_table(Core_Assignment_Table* ca){

	int i,j;
	for(i = 0; i < CA_TABLE_MAX_REDUNDANCY; i++){
  464a24:	d8800017 	ldw	r2,0(sp)
  464a28:	10800044 	addi	r2,r2,1
  464a2c:	d8800015 	stw	r2,0(sp)
  464a30:	d8800017 	ldw	r2,0(sp)
  464a34:	10800090 	cmplti	r2,r2,2
  464a38:	103fe31e 	bne	r2,zero,4649c8 <set_core_assignment_table+0x14>
		for(j = 0; j < CA_TABLE_NUM_TASKS; j++){
			uint32_t a = ca->table[i][j];
			set_core_assignment(i,a,j);
		}
	}
}
  464a3c:	dfc00417 	ldw	ra,16(sp)
  464a40:	dec00504 	addi	sp,sp,20
  464a44:	f800283a 	ret

00464a48 <context_switch>:
	.text
	.globl context_switch

context_switch:
	 	stw   r16,  0(r4)
  464a48:	24000015 	stw	r16,0(r4)
	 	stw   r17,  4(r4)
  464a4c:	24400115 	stw	r17,4(r4)
	 	stw   r18,  8(r4)
  464a50:	24800215 	stw	r18,8(r4)
	 	stw   r19,  12(r4)
  464a54:	24c00315 	stw	r19,12(r4)
	 	stw   r20,  16(r4)
  464a58:	25000415 	stw	r20,16(r4)
	 	stw   r21,  20(r4)
  464a5c:	25400515 	stw	r21,20(r4)
	 	stw   r22,  24(r4)
  464a60:	25800615 	stw	r22,24(r4)
	 	stw   r23,  28(r4)
  464a64:	25c00715 	stw	r23,28(r4)

      	movi r16, 0
  464a68:	04000004 	movi	r16,0
		movi r17, 0
  464a6c:	04400004 	movi	r17,0
		movi r18, 0
  464a70:	04800004 	movi	r18,0
		movi r19, 0
  464a74:	04c00004 	movi	r19,0
		movi r20, 0
  464a78:	05000004 	movi	r20,0
		movi r21, 0
  464a7c:	05400004 	movi	r21,0
		movi r22, 0
  464a80:	05800004 	movi	r22,0
		movi r23, 0
  464a84:	05c00004 	movi	r23,0

		ret
  464a88:	f800283a 	ret

00464a8c <context_restore>:

	.globl context_restore

context_restore:
	 	ldw   r16,  0(r4)
  464a8c:	24000017 	ldw	r16,0(r4)
        ldw   r17,  4(r4)
  464a90:	24400117 	ldw	r17,4(r4)
        ldw   r18,  8(r4)
  464a94:	24800217 	ldw	r18,8(r4)
        ldw   r19,  12(r4)
  464a98:	24c00317 	ldw	r19,12(r4)
        ldw   r20,  16(r4)
  464a9c:	25000417 	ldw	r20,16(r4)
        ldw   r21,  20(r4)
  464aa0:	25400517 	ldw	r21,20(r4)
        ldw   r22,  24(r4)
  464aa4:	25800617 	ldw	r22,24(r4)
        ldw   r23,  28(r4)
  464aa8:	25c00717 	ldw	r23,28(r4)

		ret
  464aac:	f800283a 	ret

00464ab0 <get_gp>:
	.text
	.globl get_gp

get_gp:
    	movhi r2, %hi(_gp)
  464ab0:	008011f4 	movhi	r2,71
    	ori r2, r2, %lo(_gp)
  464ab4:	10bf3314 	ori	r2,r2,64716
		ret
  464ab8:	f800283a 	ret

00464abc <set_gp>:
	.globl set_gp
set_gp:
	   	movhi r2,  0x0300
  464abc:	0080c034 	movhi	r2,768
	   	ldw gp, 0(r2)
  464ac0:	16800017 	ldw	gp,0(r2)
		ret
  464ac4:	f800283a 	ret

00464ac8 <restore_gp>:
	.globl restore_gp
restore_gp:
		movhi gp, %hi(_gp)
  464ac8:	068011f4 	movhi	gp,71
		ori gp, gp, %lo(_gp)
  464acc:	d6bf3314 	ori	gp,gp,64716
		ret
  464ad0:	f800283a 	ret

00464ad4 <_puts_r>:
  464ad4:	defff604 	addi	sp,sp,-40
  464ad8:	dc400815 	stw	r17,32(sp)
  464adc:	2023883a 	mov	r17,r4
  464ae0:	2809883a 	mov	r4,r5
  464ae4:	dc000715 	stw	r16,28(sp)
  464ae8:	dfc00915 	stw	ra,36(sp)
  464aec:	2821883a 	mov	r16,r5
  464af0:	0464b6c0 	call	464b6c <strlen>
  464af4:	10c00044 	addi	r3,r2,1
  464af8:	d8800115 	stw	r2,4(sp)
  464afc:	89400217 	ldw	r5,8(r17)
  464b00:	008011f4 	movhi	r2,71
  464b04:	10980204 	addi	r2,r2,24584
  464b08:	d8800215 	stw	r2,8(sp)
  464b0c:	00800044 	movi	r2,1
  464b10:	d8800315 	stw	r2,12(sp)
  464b14:	8809883a 	mov	r4,r17
  464b18:	00800084 	movi	r2,2
  464b1c:	d9800404 	addi	r6,sp,16
  464b20:	dc000015 	stw	r16,0(sp)
  464b24:	d8c00615 	stw	r3,24(sp)
  464b28:	dec00415 	stw	sp,16(sp)
  464b2c:	d8800515 	stw	r2,20(sp)
  464b30:	0464bf80 	call	464bf8 <__sfvwrite_r>
  464b34:	1000061e 	bne	r2,zero,464b50 <_puts_r+0x7c>
  464b38:	00800284 	movi	r2,10
  464b3c:	dfc00917 	ldw	ra,36(sp)
  464b40:	dc400817 	ldw	r17,32(sp)
  464b44:	dc000717 	ldw	r16,28(sp)
  464b48:	dec00a04 	addi	sp,sp,40
  464b4c:	f800283a 	ret
  464b50:	00bfffc4 	movi	r2,-1
  464b54:	003ff906 	br	464b3c <_puts_r+0x68>

00464b58 <puts>:
  464b58:	008011f4 	movhi	r2,71
  464b5c:	109f3a04 	addi	r2,r2,31976
  464b60:	200b883a 	mov	r5,r4
  464b64:	11000017 	ldw	r4,0(r2)
  464b68:	0464ad41 	jmpi	464ad4 <_puts_r>

00464b6c <strlen>:
  464b6c:	208000cc 	andi	r2,r4,3
  464b70:	10001f1e 	bne	r2,zero,464bf0 <strlen+0x84>
  464b74:	20800017 	ldw	r2,0(r4)
  464b78:	01ffbff4 	movhi	r7,65279
  464b7c:	39ffbfc4 	addi	r7,r7,-257
  464b80:	01a02074 	movhi	r6,32897
  464b84:	31a02004 	addi	r6,r6,-32640
  464b88:	11c7883a 	add	r3,r2,r7
  464b8c:	0084303a 	nor	r2,zero,r2
  464b90:	1886703a 	and	r3,r3,r2
  464b94:	1986703a 	and	r3,r3,r6
  464b98:	2005883a 	mov	r2,r4
  464b9c:	1800101e 	bne	r3,zero,464be0 <strlen+0x74>
  464ba0:	10800104 	addi	r2,r2,4
  464ba4:	10c00017 	ldw	r3,0(r2)
  464ba8:	19cb883a 	add	r5,r3,r7
  464bac:	00c6303a 	nor	r3,zero,r3
  464bb0:	28c6703a 	and	r3,r5,r3
  464bb4:	1986703a 	and	r3,r3,r6
  464bb8:	1800091e 	bne	r3,zero,464be0 <strlen+0x74>
  464bbc:	10800104 	addi	r2,r2,4
  464bc0:	10c00017 	ldw	r3,0(r2)
  464bc4:	19cb883a 	add	r5,r3,r7
  464bc8:	00c6303a 	nor	r3,zero,r3
  464bcc:	28c6703a 	and	r3,r5,r3
  464bd0:	1986703a 	and	r3,r3,r6
  464bd4:	183ff226 	beq	r3,zero,464ba0 <strlen+0x34>
  464bd8:	00000106 	br	464be0 <strlen+0x74>
  464bdc:	10800044 	addi	r2,r2,1
  464be0:	10c00007 	ldb	r3,0(r2)
  464be4:	183ffd1e 	bne	r3,zero,464bdc <strlen+0x70>
  464be8:	1105c83a 	sub	r2,r2,r4
  464bec:	f800283a 	ret
  464bf0:	2005883a 	mov	r2,r4
  464bf4:	003ffa06 	br	464be0 <strlen+0x74>

00464bf8 <__sfvwrite_r>:
  464bf8:	30800217 	ldw	r2,8(r6)
  464bfc:	defff504 	addi	sp,sp,-44
  464c00:	dd400615 	stw	r21,24(sp)
  464c04:	dd000515 	stw	r20,20(sp)
  464c08:	dc000115 	stw	r16,4(sp)
  464c0c:	dfc00a15 	stw	ra,40(sp)
  464c10:	df000915 	stw	fp,36(sp)
  464c14:	ddc00815 	stw	r23,32(sp)
  464c18:	dd800715 	stw	r22,28(sp)
  464c1c:	dcc00415 	stw	r19,16(sp)
  464c20:	dc800315 	stw	r18,12(sp)
  464c24:	dc400215 	stw	r17,8(sp)
  464c28:	3029883a 	mov	r20,r6
  464c2c:	202b883a 	mov	r21,r4
  464c30:	2821883a 	mov	r16,r5
  464c34:	10002126 	beq	r2,zero,464cbc <__sfvwrite_r+0xc4>
  464c38:	2880030b 	ldhu	r2,12(r5)
  464c3c:	10c0020c 	andi	r3,r2,8
  464c40:	18ffffcc 	andi	r3,r3,65535
  464c44:	18e0001c 	xori	r3,r3,32768
  464c48:	18e00004 	addi	r3,r3,-32768
  464c4c:	18002826 	beq	r3,zero,464cf0 <__sfvwrite_r+0xf8>
  464c50:	28c00417 	ldw	r3,16(r5)
  464c54:	18002626 	beq	r3,zero,464cf0 <__sfvwrite_r+0xf8>
  464c58:	10c0008c 	andi	r3,r2,2
  464c5c:	18ffffcc 	andi	r3,r3,65535
  464c60:	18e0001c 	xori	r3,r3,32768
  464c64:	18e00004 	addi	r3,r3,-32768
  464c68:	a4400017 	ldw	r17,0(r20)
  464c6c:	18002b26 	beq	r3,zero,464d1c <__sfvwrite_r+0x124>
  464c70:	0027883a 	mov	r19,zero
  464c74:	0025883a 	mov	r18,zero
  464c78:	05810004 	movi	r22,1024
  464c7c:	980d883a 	mov	r6,r19
  464c80:	a809883a 	mov	r4,r21
  464c84:	90004f26 	beq	r18,zero,464dc4 <__sfvwrite_r+0x1cc>
  464c88:	900f883a 	mov	r7,r18
  464c8c:	81400717 	ldw	r5,28(r16)
  464c90:	b480012e 	bgeu	r22,r18,464c98 <__sfvwrite_r+0xa0>
  464c94:	01c10004 	movi	r7,1024
  464c98:	80800917 	ldw	r2,36(r16)
  464c9c:	103ee83a 	callr	r2
  464ca0:	0080540e 	bge	zero,r2,464df4 <__sfvwrite_r+0x1fc>
  464ca4:	a0c00217 	ldw	r3,8(r20)
  464ca8:	98a7883a 	add	r19,r19,r2
  464cac:	90a5c83a 	sub	r18,r18,r2
  464cb0:	1885c83a 	sub	r2,r3,r2
  464cb4:	a0800215 	stw	r2,8(r20)
  464cb8:	103ff01e 	bne	r2,zero,464c7c <__sfvwrite_r+0x84>
  464cbc:	0005883a 	mov	r2,zero
  464cc0:	dfc00a17 	ldw	ra,40(sp)
  464cc4:	df000917 	ldw	fp,36(sp)
  464cc8:	ddc00817 	ldw	r23,32(sp)
  464ccc:	dd800717 	ldw	r22,28(sp)
  464cd0:	dd400617 	ldw	r21,24(sp)
  464cd4:	dd000517 	ldw	r20,20(sp)
  464cd8:	dcc00417 	ldw	r19,16(sp)
  464cdc:	dc800317 	ldw	r18,12(sp)
  464ce0:	dc400217 	ldw	r17,8(sp)
  464ce4:	dc000117 	ldw	r16,4(sp)
  464ce8:	dec00b04 	addi	sp,sp,44
  464cec:	f800283a 	ret
  464cf0:	a809883a 	mov	r4,r21
  464cf4:	800b883a 	mov	r5,r16
  464cf8:	04662840 	call	466284 <__swsetup_r>
  464cfc:	1000f01e 	bne	r2,zero,4650c0 <__sfvwrite_r+0x4c8>
  464d00:	8080030b 	ldhu	r2,12(r16)
  464d04:	a4400017 	ldw	r17,0(r20)
  464d08:	10c0008c 	andi	r3,r2,2
  464d0c:	18ffffcc 	andi	r3,r3,65535
  464d10:	18e0001c 	xori	r3,r3,32768
  464d14:	18e00004 	addi	r3,r3,-32768
  464d18:	183fd51e 	bne	r3,zero,464c70 <__sfvwrite_r+0x78>
  464d1c:	10c0004c 	andi	r3,r2,1
  464d20:	002d883a 	mov	r22,zero
  464d24:	1800381e 	bne	r3,zero,464e08 <__sfvwrite_r+0x210>
  464d28:	0025883a 	mov	r18,zero
  464d2c:	90002126 	beq	r18,zero,464db4 <__sfvwrite_r+0x1bc>
  464d30:	10c0800c 	andi	r3,r2,512
  464d34:	18ffffcc 	andi	r3,r3,65535
  464d38:	18e0001c 	xori	r3,r3,32768
  464d3c:	18e00004 	addi	r3,r3,-32768
  464d40:	84c00217 	ldw	r19,8(r16)
  464d44:	18006b26 	beq	r3,zero,464ef4 <__sfvwrite_r+0x2fc>
  464d48:	980f883a 	mov	r7,r19
  464d4c:	94c08636 	bltu	r18,r19,464f68 <__sfvwrite_r+0x370>
  464d50:	10c1200c 	andi	r3,r2,1152
  464d54:	18009f1e 	bne	r3,zero,464fd4 <__sfvwrite_r+0x3dc>
  464d58:	81000017 	ldw	r4,0(r16)
  464d5c:	982f883a 	mov	r23,r19
  464d60:	9039883a 	mov	fp,r18
  464d64:	9027883a 	mov	r19,r18
  464d68:	380d883a 	mov	r6,r7
  464d6c:	b00b883a 	mov	r5,r22
  464d70:	d9c00015 	stw	r7,0(sp)
  464d74:	0465a980 	call	465a98 <memmove>
  464d78:	d9c00017 	ldw	r7,0(sp)
  464d7c:	81000217 	ldw	r4,8(r16)
  464d80:	80800017 	ldw	r2,0(r16)
  464d84:	25efc83a 	sub	r23,r4,r23
  464d88:	11cf883a 	add	r7,r2,r7
  464d8c:	85c00215 	stw	r23,8(r16)
  464d90:	81c00015 	stw	r7,0(r16)
  464d94:	a0800217 	ldw	r2,8(r20)
  464d98:	b72d883a 	add	r22,r22,fp
  464d9c:	9725c83a 	sub	r18,r18,fp
  464da0:	14e7c83a 	sub	r19,r2,r19
  464da4:	a4c00215 	stw	r19,8(r20)
  464da8:	983fc426 	beq	r19,zero,464cbc <__sfvwrite_r+0xc4>
  464dac:	8080030b 	ldhu	r2,12(r16)
  464db0:	903fdf1e 	bne	r18,zero,464d30 <__sfvwrite_r+0x138>
  464db4:	8d800017 	ldw	r22,0(r17)
  464db8:	8c800117 	ldw	r18,4(r17)
  464dbc:	8c400204 	addi	r17,r17,8
  464dc0:	003fda06 	br	464d2c <__sfvwrite_r+0x134>
  464dc4:	8cc00017 	ldw	r19,0(r17)
  464dc8:	8c800117 	ldw	r18,4(r17)
  464dcc:	8c400204 	addi	r17,r17,8
  464dd0:	003faa06 	br	464c7c <__sfvwrite_r+0x84>
  464dd4:	0465c240 	call	465c24 <_realloc_r>
  464dd8:	102f883a 	mov	r23,r2
  464ddc:	10009f1e 	bne	r2,zero,46505c <__sfvwrite_r+0x464>
  464de0:	81400417 	ldw	r5,16(r16)
  464de4:	a809883a 	mov	r4,r21
  464de8:	0466a380 	call	466a38 <_free_r>
  464dec:	00800304 	movi	r2,12
  464df0:	a8800015 	stw	r2,0(r21)
  464df4:	80c0030b 	ldhu	r3,12(r16)
  464df8:	00bfffc4 	movi	r2,-1
  464dfc:	18c01014 	ori	r3,r3,64
  464e00:	80c0030d 	sth	r3,12(r16)
  464e04:	003fae06 	br	464cc0 <__sfvwrite_r+0xc8>
  464e08:	0007883a 	mov	r3,zero
  464e0c:	0039883a 	mov	fp,zero
  464e10:	0025883a 	mov	r18,zero
  464e14:	90001e26 	beq	r18,zero,464e90 <__sfvwrite_r+0x298>
  464e18:	18006526 	beq	r3,zero,464fb0 <__sfvwrite_r+0x3b8>
  464e1c:	b02f883a 	mov	r23,r22
  464e20:	9580012e 	bgeu	r18,r22,464e28 <__sfvwrite_r+0x230>
  464e24:	902f883a 	mov	r23,r18
  464e28:	81000017 	ldw	r4,0(r16)
  464e2c:	80800417 	ldw	r2,16(r16)
  464e30:	84c00217 	ldw	r19,8(r16)
  464e34:	81c00517 	ldw	r7,20(r16)
  464e38:	1100022e 	bgeu	r2,r4,464e44 <__sfvwrite_r+0x24c>
  464e3c:	99e7883a 	add	r19,r19,r7
  464e40:	9dc01816 	blt	r19,r23,464ea4 <__sfvwrite_r+0x2ac>
  464e44:	b9c03b16 	blt	r23,r7,464f34 <__sfvwrite_r+0x33c>
  464e48:	80800917 	ldw	r2,36(r16)
  464e4c:	81400717 	ldw	r5,28(r16)
  464e50:	a809883a 	mov	r4,r21
  464e54:	d8c00015 	stw	r3,0(sp)
  464e58:	e00d883a 	mov	r6,fp
  464e5c:	103ee83a 	callr	r2
  464e60:	1027883a 	mov	r19,r2
  464e64:	d8c00017 	ldw	r3,0(sp)
  464e68:	00bfe20e 	bge	zero,r2,464df4 <__sfvwrite_r+0x1fc>
  464e6c:	b4edc83a 	sub	r22,r22,r19
  464e70:	b0001a26 	beq	r22,zero,464edc <__sfvwrite_r+0x2e4>
  464e74:	a0800217 	ldw	r2,8(r20)
  464e78:	e4f9883a 	add	fp,fp,r19
  464e7c:	94e5c83a 	sub	r18,r18,r19
  464e80:	14e7c83a 	sub	r19,r2,r19
  464e84:	a4c00215 	stw	r19,8(r20)
  464e88:	983f8c26 	beq	r19,zero,464cbc <__sfvwrite_r+0xc4>
  464e8c:	903fe21e 	bne	r18,zero,464e18 <__sfvwrite_r+0x220>
  464e90:	8f000017 	ldw	fp,0(r17)
  464e94:	8c800117 	ldw	r18,4(r17)
  464e98:	0007883a 	mov	r3,zero
  464e9c:	8c400204 	addi	r17,r17,8
  464ea0:	003fdc06 	br	464e14 <__sfvwrite_r+0x21c>
  464ea4:	e00b883a 	mov	r5,fp
  464ea8:	980d883a 	mov	r6,r19
  464eac:	d8c00015 	stw	r3,0(sp)
  464eb0:	0465a980 	call	465a98 <memmove>
  464eb4:	80800017 	ldw	r2,0(r16)
  464eb8:	a809883a 	mov	r4,r21
  464ebc:	800b883a 	mov	r5,r16
  464ec0:	14c5883a 	add	r2,r2,r19
  464ec4:	80800015 	stw	r2,0(r16)
  464ec8:	04663f80 	call	4663f8 <_fflush_r>
  464ecc:	d8c00017 	ldw	r3,0(sp)
  464ed0:	103fc81e 	bne	r2,zero,464df4 <__sfvwrite_r+0x1fc>
  464ed4:	b4edc83a 	sub	r22,r22,r19
  464ed8:	b03fe61e 	bne	r22,zero,464e74 <__sfvwrite_r+0x27c>
  464edc:	a809883a 	mov	r4,r21
  464ee0:	800b883a 	mov	r5,r16
  464ee4:	04663f80 	call	4663f8 <_fflush_r>
  464ee8:	103fc21e 	bne	r2,zero,464df4 <__sfvwrite_r+0x1fc>
  464eec:	0007883a 	mov	r3,zero
  464ef0:	003fe006 	br	464e74 <__sfvwrite_r+0x27c>
  464ef4:	81000017 	ldw	r4,0(r16)
  464ef8:	80800417 	ldw	r2,16(r16)
  464efc:	1100022e 	bgeu	r2,r4,464f08 <__sfvwrite_r+0x310>
  464f00:	9839883a 	mov	fp,r19
  464f04:	9c806036 	bltu	r19,r18,465088 <__sfvwrite_r+0x490>
  464f08:	81c00517 	ldw	r7,20(r16)
  464f0c:	91c01c36 	bltu	r18,r7,464f80 <__sfvwrite_r+0x388>
  464f10:	80800917 	ldw	r2,36(r16)
  464f14:	81400717 	ldw	r5,28(r16)
  464f18:	a809883a 	mov	r4,r21
  464f1c:	b00d883a 	mov	r6,r22
  464f20:	103ee83a 	callr	r2
  464f24:	1027883a 	mov	r19,r2
  464f28:	00bfb20e 	bge	zero,r2,464df4 <__sfvwrite_r+0x1fc>
  464f2c:	1039883a 	mov	fp,r2
  464f30:	003f9806 	br	464d94 <__sfvwrite_r+0x19c>
  464f34:	b80d883a 	mov	r6,r23
  464f38:	e00b883a 	mov	r5,fp
  464f3c:	d8c00015 	stw	r3,0(sp)
  464f40:	0465a980 	call	465a98 <memmove>
  464f44:	80800217 	ldw	r2,8(r16)
  464f48:	81000017 	ldw	r4,0(r16)
  464f4c:	b827883a 	mov	r19,r23
  464f50:	15c5c83a 	sub	r2,r2,r23
  464f54:	25ef883a 	add	r23,r4,r23
  464f58:	80800215 	stw	r2,8(r16)
  464f5c:	85c00015 	stw	r23,0(r16)
  464f60:	d8c00017 	ldw	r3,0(sp)
  464f64:	003fc106 	br	464e6c <__sfvwrite_r+0x274>
  464f68:	81000017 	ldw	r4,0(r16)
  464f6c:	902f883a 	mov	r23,r18
  464f70:	9039883a 	mov	fp,r18
  464f74:	9027883a 	mov	r19,r18
  464f78:	900f883a 	mov	r7,r18
  464f7c:	003f7a06 	br	464d68 <__sfvwrite_r+0x170>
  464f80:	b00b883a 	mov	r5,r22
  464f84:	900d883a 	mov	r6,r18
  464f88:	0465a980 	call	465a98 <memmove>
  464f8c:	80c00217 	ldw	r3,8(r16)
  464f90:	80800017 	ldw	r2,0(r16)
  464f94:	9027883a 	mov	r19,r18
  464f98:	1c87c83a 	sub	r3,r3,r18
  464f9c:	1485883a 	add	r2,r2,r18
  464fa0:	80c00215 	stw	r3,8(r16)
  464fa4:	80800015 	stw	r2,0(r16)
  464fa8:	9039883a 	mov	fp,r18
  464fac:	003f7906 	br	464d94 <__sfvwrite_r+0x19c>
  464fb0:	e009883a 	mov	r4,fp
  464fb4:	01400284 	movi	r5,10
  464fb8:	900d883a 	mov	r6,r18
  464fbc:	04658600 	call	465860 <memchr>
  464fc0:	10003c26 	beq	r2,zero,4650b4 <__sfvwrite_r+0x4bc>
  464fc4:	15800044 	addi	r22,r2,1
  464fc8:	b72dc83a 	sub	r22,r22,fp
  464fcc:	00c00044 	movi	r3,1
  464fd0:	003f9206 	br	464e1c <__sfvwrite_r+0x224>
  464fd4:	81000517 	ldw	r4,20(r16)
  464fd8:	81400417 	ldw	r5,16(r16)
  464fdc:	80c00017 	ldw	r3,0(r16)
  464fe0:	210d883a 	add	r6,r4,r4
  464fe4:	3109883a 	add	r4,r6,r4
  464fe8:	2026d7fa 	srli	r19,r4,31
  464fec:	1979c83a 	sub	fp,r3,r5
  464ff0:	e1800044 	addi	r6,fp,1
  464ff4:	9909883a 	add	r4,r19,r4
  464ff8:	2027d07a 	srai	r19,r4,1
  464ffc:	3489883a 	add	r4,r6,r18
  465000:	980d883a 	mov	r6,r19
  465004:	9900022e 	bgeu	r19,r4,465010 <__sfvwrite_r+0x418>
  465008:	2027883a 	mov	r19,r4
  46500c:	200d883a 	mov	r6,r4
  465010:	1081000c 	andi	r2,r2,1024
  465014:	10bfffcc 	andi	r2,r2,65535
  465018:	10a0001c 	xori	r2,r2,32768
  46501c:	10a00004 	addi	r2,r2,-32768
  465020:	a809883a 	mov	r4,r21
  465024:	103f6b26 	beq	r2,zero,464dd4 <__sfvwrite_r+0x1dc>
  465028:	300b883a 	mov	r5,r6
  46502c:	04650dc0 	call	4650dc <_malloc_r>
  465030:	102f883a 	mov	r23,r2
  465034:	103f6d26 	beq	r2,zero,464dec <__sfvwrite_r+0x1f4>
  465038:	81400417 	ldw	r5,16(r16)
  46503c:	1009883a 	mov	r4,r2
  465040:	e00d883a 	mov	r6,fp
  465044:	04659580 	call	465958 <memcpy>
  465048:	8080030b 	ldhu	r2,12(r16)
  46504c:	00fedfc4 	movi	r3,-1153
  465050:	10c4703a 	and	r2,r2,r3
  465054:	10802014 	ori	r2,r2,128
  465058:	8080030d 	sth	r2,12(r16)
  46505c:	bf09883a 	add	r4,r23,fp
  465060:	9f07c83a 	sub	r3,r19,fp
  465064:	85c00415 	stw	r23,16(r16)
  465068:	84c00515 	stw	r19,20(r16)
  46506c:	81000015 	stw	r4,0(r16)
  465070:	902f883a 	mov	r23,r18
  465074:	80c00215 	stw	r3,8(r16)
  465078:	9039883a 	mov	fp,r18
  46507c:	9027883a 	mov	r19,r18
  465080:	900f883a 	mov	r7,r18
  465084:	003f3806 	br	464d68 <__sfvwrite_r+0x170>
  465088:	b00b883a 	mov	r5,r22
  46508c:	980d883a 	mov	r6,r19
  465090:	0465a980 	call	465a98 <memmove>
  465094:	80800017 	ldw	r2,0(r16)
  465098:	a809883a 	mov	r4,r21
  46509c:	800b883a 	mov	r5,r16
  4650a0:	14c5883a 	add	r2,r2,r19
  4650a4:	80800015 	stw	r2,0(r16)
  4650a8:	04663f80 	call	4663f8 <_fflush_r>
  4650ac:	103f3926 	beq	r2,zero,464d94 <__sfvwrite_r+0x19c>
  4650b0:	003f5006 	br	464df4 <__sfvwrite_r+0x1fc>
  4650b4:	95800044 	addi	r22,r18,1
  4650b8:	00c00044 	movi	r3,1
  4650bc:	003f5706 	br	464e1c <__sfvwrite_r+0x224>
  4650c0:	80c0030b 	ldhu	r3,12(r16)
  4650c4:	00bfffc4 	movi	r2,-1
  4650c8:	18c01014 	ori	r3,r3,64
  4650cc:	80c0030d 	sth	r3,12(r16)
  4650d0:	00c00244 	movi	r3,9
  4650d4:	a8c00015 	stw	r3,0(r21)
  4650d8:	003ef906 	br	464cc0 <__sfvwrite_r+0xc8>

004650dc <_malloc_r>:
  4650dc:	defff604 	addi	sp,sp,-40
  4650e0:	dc800215 	stw	r18,8(sp)
  4650e4:	dfc00915 	stw	ra,36(sp)
  4650e8:	df000815 	stw	fp,32(sp)
  4650ec:	ddc00715 	stw	r23,28(sp)
  4650f0:	dd800615 	stw	r22,24(sp)
  4650f4:	dd400515 	stw	r21,20(sp)
  4650f8:	dd000415 	stw	r20,16(sp)
  4650fc:	dcc00315 	stw	r19,12(sp)
  465100:	dc400115 	stw	r17,4(sp)
  465104:	dc000015 	stw	r16,0(sp)
  465108:	288002c4 	addi	r2,r5,11
  46510c:	00c00584 	movi	r3,22
  465110:	2025883a 	mov	r18,r4
  465114:	18802b2e 	bgeu	r3,r2,4651c4 <_malloc_r+0xe8>
  465118:	047ffe04 	movi	r17,-8
  46511c:	1462703a 	and	r17,r2,r17
  465120:	88002a16 	blt	r17,zero,4651cc <_malloc_r+0xf0>
  465124:	89402936 	bltu	r17,r5,4651cc <_malloc_r+0xf0>
  465128:	9009883a 	mov	r4,r18
  46512c:	04684a00 	call	4684a0 <__malloc_lock>
  465130:	00807dc4 	movi	r2,503
  465134:	14402936 	bltu	r2,r17,4651dc <_malloc_r+0x100>
  465138:	8808d0fa 	srli	r4,r17,3
  46513c:	04c011f4 	movhi	r19,71
  465140:	9cd9a704 	addi	r19,r19,26268
  465144:	2105883a 	add	r2,r4,r4
  465148:	1085883a 	add	r2,r2,r2
  46514c:	1085883a 	add	r2,r2,r2
  465150:	9885883a 	add	r2,r19,r2
  465154:	14000317 	ldw	r16,12(r2)
  465158:	80815526 	beq	r16,r2,4656b0 <_malloc_r+0x5d4>
  46515c:	81000117 	ldw	r4,4(r16)
  465160:	00bfff04 	movi	r2,-4
  465164:	80c00317 	ldw	r3,12(r16)
  465168:	2084703a 	and	r2,r4,r2
  46516c:	8085883a 	add	r2,r16,r2
  465170:	11800117 	ldw	r6,4(r2)
  465174:	81400217 	ldw	r5,8(r16)
  465178:	9009883a 	mov	r4,r18
  46517c:	31800054 	ori	r6,r6,1
  465180:	11800115 	stw	r6,4(r2)
  465184:	28c00315 	stw	r3,12(r5)
  465188:	19400215 	stw	r5,8(r3)
  46518c:	046860c0 	call	46860c <__malloc_unlock>
  465190:	80800204 	addi	r2,r16,8
  465194:	dfc00917 	ldw	ra,36(sp)
  465198:	df000817 	ldw	fp,32(sp)
  46519c:	ddc00717 	ldw	r23,28(sp)
  4651a0:	dd800617 	ldw	r22,24(sp)
  4651a4:	dd400517 	ldw	r21,20(sp)
  4651a8:	dd000417 	ldw	r20,16(sp)
  4651ac:	dcc00317 	ldw	r19,12(sp)
  4651b0:	dc800217 	ldw	r18,8(sp)
  4651b4:	dc400117 	ldw	r17,4(sp)
  4651b8:	dc000017 	ldw	r16,0(sp)
  4651bc:	dec00a04 	addi	sp,sp,40
  4651c0:	f800283a 	ret
  4651c4:	04400404 	movi	r17,16
  4651c8:	897fd72e 	bgeu	r17,r5,465128 <_malloc_r+0x4c>
  4651cc:	00800304 	movi	r2,12
  4651d0:	90800015 	stw	r2,0(r18)
  4651d4:	0005883a 	mov	r2,zero
  4651d8:	003fee06 	br	465194 <_malloc_r+0xb8>
  4651dc:	8808d27a 	srli	r4,r17,9
  4651e0:	20007126 	beq	r4,zero,4653a8 <_malloc_r+0x2cc>
  4651e4:	00800104 	movi	r2,4
  4651e8:	1100eb36 	bltu	r2,r4,465598 <_malloc_r+0x4bc>
  4651ec:	8808d1ba 	srli	r4,r17,6
  4651f0:	21000e04 	addi	r4,r4,56
  4651f4:	210b883a 	add	r5,r4,r4
  4651f8:	294b883a 	add	r5,r5,r5
  4651fc:	294b883a 	add	r5,r5,r5
  465200:	04c011f4 	movhi	r19,71
  465204:	9cd9a704 	addi	r19,r19,26268
  465208:	994b883a 	add	r5,r19,r5
  46520c:	2c000317 	ldw	r16,12(r5)
  465210:	2c000e26 	beq	r5,r16,46524c <_malloc_r+0x170>
  465214:	80c00117 	ldw	r3,4(r16)
  465218:	01ffff04 	movi	r7,-4
  46521c:	018003c4 	movi	r6,15
  465220:	19c6703a 	and	r3,r3,r7
  465224:	1c45c83a 	sub	r2,r3,r17
  465228:	30800716 	blt	r6,r2,465248 <_malloc_r+0x16c>
  46522c:	1000610e 	bge	r2,zero,4653b4 <_malloc_r+0x2d8>
  465230:	84000317 	ldw	r16,12(r16)
  465234:	2c000526 	beq	r5,r16,46524c <_malloc_r+0x170>
  465238:	80c00117 	ldw	r3,4(r16)
  46523c:	19c6703a 	and	r3,r3,r7
  465240:	1c45c83a 	sub	r2,r3,r17
  465244:	30bff90e 	bge	r6,r2,46522c <_malloc_r+0x150>
  465248:	213fffc4 	addi	r4,r4,-1
  46524c:	21000044 	addi	r4,r4,1
  465250:	9c000417 	ldw	r16,16(r19)
  465254:	00c011f4 	movhi	r3,71
  465258:	18d9a704 	addi	r3,r3,26268
  46525c:	1a400204 	addi	r9,r3,8
  465260:	8240ff26 	beq	r16,r9,465660 <_malloc_r+0x584>
  465264:	81400117 	ldw	r5,4(r16)
  465268:	00bfff04 	movi	r2,-4
  46526c:	018003c4 	movi	r6,15
  465270:	2884703a 	and	r2,r5,r2
  465274:	144bc83a 	sub	r5,r2,r17
  465278:	3140ea16 	blt	r6,r5,465624 <_malloc_r+0x548>
  46527c:	1a400515 	stw	r9,20(r3)
  465280:	1a400415 	stw	r9,16(r3)
  465284:	2800570e 	bge	r5,zero,4653e4 <_malloc_r+0x308>
  465288:	01407fc4 	movi	r5,511
  46528c:	2880ca36 	bltu	r5,r2,4655b8 <_malloc_r+0x4dc>
  465290:	1004d0fa 	srli	r2,r2,3
  465294:	02000044 	movi	r8,1
  465298:	19c00117 	ldw	r7,4(r3)
  46529c:	108b883a 	add	r5,r2,r2
  4652a0:	294b883a 	add	r5,r5,r5
  4652a4:	1005d0ba 	srai	r2,r2,2
  4652a8:	294b883a 	add	r5,r5,r5
  4652ac:	28cb883a 	add	r5,r5,r3
  4652b0:	29800217 	ldw	r6,8(r5)
  4652b4:	4084983a 	sll	r2,r8,r2
  4652b8:	81400315 	stw	r5,12(r16)
  4652bc:	81800215 	stw	r6,8(r16)
  4652c0:	11c4b03a 	or	r2,r2,r7
  4652c4:	18800115 	stw	r2,4(r3)
  4652c8:	2c000215 	stw	r16,8(r5)
  4652cc:	34000315 	stw	r16,12(r6)
  4652d0:	200bd0ba 	srai	r5,r4,2
  4652d4:	00c00044 	movi	r3,1
  4652d8:	194a983a 	sll	r5,r3,r5
  4652dc:	11404936 	bltu	r2,r5,465404 <_malloc_r+0x328>
  4652e0:	1146703a 	and	r3,r2,r5
  4652e4:	18000a1e 	bne	r3,zero,465310 <_malloc_r+0x234>
  4652e8:	00ffff04 	movi	r3,-4
  4652ec:	294b883a 	add	r5,r5,r5
  4652f0:	20c8703a 	and	r4,r4,r3
  4652f4:	1146703a 	and	r3,r2,r5
  4652f8:	21000104 	addi	r4,r4,4
  4652fc:	1800041e 	bne	r3,zero,465310 <_malloc_r+0x234>
  465300:	294b883a 	add	r5,r5,r5
  465304:	1146703a 	and	r3,r2,r5
  465308:	21000104 	addi	r4,r4,4
  46530c:	183ffc26 	beq	r3,zero,465300 <_malloc_r+0x224>
  465310:	023fff04 	movi	r8,-4
  465314:	01c003c4 	movi	r7,15
  465318:	2105883a 	add	r2,r4,r4
  46531c:	1085883a 	add	r2,r2,r2
  465320:	1085883a 	add	r2,r2,r2
  465324:	9899883a 	add	r12,r19,r2
  465328:	62800304 	addi	r10,r12,12
  46532c:	2017883a 	mov	r11,r4
  465330:	54000017 	ldw	r16,0(r10)
  465334:	51bffd04 	addi	r6,r10,-12
  465338:	8180041e 	bne	r16,r6,46534c <_malloc_r+0x270>
  46533c:	0000ca06 	br	465668 <_malloc_r+0x58c>
  465340:	10001c0e 	bge	r2,zero,4653b4 <_malloc_r+0x2d8>
  465344:	84000317 	ldw	r16,12(r16)
  465348:	8180c726 	beq	r16,r6,465668 <_malloc_r+0x58c>
  46534c:	80c00117 	ldw	r3,4(r16)
  465350:	1a06703a 	and	r3,r3,r8
  465354:	1c45c83a 	sub	r2,r3,r17
  465358:	38bff90e 	bge	r7,r2,465340 <_malloc_r+0x264>
  46535c:	81000317 	ldw	r4,12(r16)
  465360:	81400217 	ldw	r5,8(r16)
  465364:	8447883a 	add	r3,r16,r17
  465368:	8c400054 	ori	r17,r17,1
  46536c:	29000315 	stw	r4,12(r5)
  465370:	21400215 	stw	r5,8(r4)
  465374:	84400115 	stw	r17,4(r16)
  465378:	1889883a 	add	r4,r3,r2
  46537c:	11400054 	ori	r5,r2,1
  465380:	98c00515 	stw	r3,20(r19)
  465384:	98c00415 	stw	r3,16(r19)
  465388:	20800015 	stw	r2,0(r4)
  46538c:	1a400315 	stw	r9,12(r3)
  465390:	1a400215 	stw	r9,8(r3)
  465394:	19400115 	stw	r5,4(r3)
  465398:	9009883a 	mov	r4,r18
  46539c:	046860c0 	call	46860c <__malloc_unlock>
  4653a0:	80800204 	addi	r2,r16,8
  4653a4:	003f7b06 	br	465194 <_malloc_r+0xb8>
  4653a8:	8808d0fa 	srli	r4,r17,3
  4653ac:	210b883a 	add	r5,r4,r4
  4653b0:	003f9106 	br	4651f8 <_malloc_r+0x11c>
  4653b4:	80c7883a 	add	r3,r16,r3
  4653b8:	19400117 	ldw	r5,4(r3)
  4653bc:	80800317 	ldw	r2,12(r16)
  4653c0:	81000217 	ldw	r4,8(r16)
  4653c4:	29400054 	ori	r5,r5,1
  4653c8:	19400115 	stw	r5,4(r3)
  4653cc:	20800315 	stw	r2,12(r4)
  4653d0:	11000215 	stw	r4,8(r2)
  4653d4:	9009883a 	mov	r4,r18
  4653d8:	046860c0 	call	46860c <__malloc_unlock>
  4653dc:	80800204 	addi	r2,r16,8
  4653e0:	003f6c06 	br	465194 <_malloc_r+0xb8>
  4653e4:	8085883a 	add	r2,r16,r2
  4653e8:	10c00117 	ldw	r3,4(r2)
  4653ec:	9009883a 	mov	r4,r18
  4653f0:	18c00054 	ori	r3,r3,1
  4653f4:	10c00115 	stw	r3,4(r2)
  4653f8:	046860c0 	call	46860c <__malloc_unlock>
  4653fc:	80800204 	addi	r2,r16,8
  465400:	003f6406 	br	465194 <_malloc_r+0xb8>
  465404:	9c000217 	ldw	r16,8(r19)
  465408:	00bfff04 	movi	r2,-4
  46540c:	85400117 	ldw	r21,4(r16)
  465410:	a8aa703a 	and	r21,r21,r2
  465414:	ac400336 	bltu	r21,r17,465424 <_malloc_r+0x348>
  465418:	ac45c83a 	sub	r2,r21,r17
  46541c:	00c003c4 	movi	r3,15
  465420:	18805316 	blt	r3,r2,465570 <_malloc_r+0x494>
  465424:	d5e70017 	ldw	r23,-25600(gp)
  465428:	d0e00817 	ldw	r3,-32736(gp)
  46542c:	00bfffc4 	movi	r2,-1
  465430:	8579883a 	add	fp,r16,r21
  465434:	8def883a 	add	r23,r17,r23
  465438:	1880d226 	beq	r3,r2,465784 <_malloc_r+0x6a8>
  46543c:	bdc403c4 	addi	r23,r23,4111
  465440:	00bc0004 	movi	r2,-4096
  465444:	b8ae703a 	and	r23,r23,r2
  465448:	9009883a 	mov	r4,r18
  46544c:	b80b883a 	mov	r5,r23
  465450:	04662200 	call	466220 <_sbrk_r>
  465454:	1029883a 	mov	r20,r2
  465458:	00bfffc4 	movi	r2,-1
  46545c:	a080d126 	beq	r20,r2,4657a4 <_malloc_r+0x6c8>
  465460:	a7009f36 	bltu	r20,fp,4656e0 <_malloc_r+0x604>
  465464:	05801234 	movhi	r22,72
  465468:	b5a65604 	addi	r22,r22,-26280
  46546c:	b0800017 	ldw	r2,0(r22)
  465470:	b885883a 	add	r2,r23,r2
  465474:	b0800015 	stw	r2,0(r22)
  465478:	e500cf26 	beq	fp,r20,4657b8 <_malloc_r+0x6dc>
  46547c:	d1200817 	ldw	r4,-32736(gp)
  465480:	00ffffc4 	movi	r3,-1
  465484:	20c0e026 	beq	r4,r3,465808 <_malloc_r+0x72c>
  465488:	a739c83a 	sub	fp,r20,fp
  46548c:	1705883a 	add	r2,r2,fp
  465490:	b0800015 	stw	r2,0(r22)
  465494:	a08001cc 	andi	r2,r20,7
  465498:	1000a526 	beq	r2,zero,465730 <_malloc_r+0x654>
  46549c:	a0a9c83a 	sub	r20,r20,r2
  4654a0:	00c40204 	movi	r3,4104
  4654a4:	a5000204 	addi	r20,r20,8
  4654a8:	1885c83a 	sub	r2,r3,r2
  4654ac:	a5c7883a 	add	r3,r20,r23
  4654b0:	18c3ffcc 	andi	r3,r3,4095
  4654b4:	10efc83a 	sub	r23,r2,r3
  4654b8:	9009883a 	mov	r4,r18
  4654bc:	b80b883a 	mov	r5,r23
  4654c0:	04662200 	call	466220 <_sbrk_r>
  4654c4:	00ffffc4 	movi	r3,-1
  4654c8:	10c0cc26 	beq	r2,r3,4657fc <_malloc_r+0x720>
  4654cc:	1505c83a 	sub	r2,r2,r20
  4654d0:	b887883a 	add	r3,r23,r2
  4654d4:	18c00054 	ori	r3,r3,1
  4654d8:	b0800017 	ldw	r2,0(r22)
  4654dc:	9d000215 	stw	r20,8(r19)
  4654e0:	a0c00115 	stw	r3,4(r20)
  4654e4:	b885883a 	add	r2,r23,r2
  4654e8:	b0800015 	stw	r2,0(r22)
  4654ec:	84c00e26 	beq	r16,r19,465528 <_malloc_r+0x44c>
  4654f0:	00c003c4 	movi	r3,15
  4654f4:	1d40902e 	bgeu	r3,r21,465738 <_malloc_r+0x65c>
  4654f8:	ad7ffd04 	addi	r21,r21,-12
  4654fc:	013ffe04 	movi	r4,-8
  465500:	a908703a 	and	r4,r21,r4
  465504:	810b883a 	add	r5,r16,r4
  465508:	01800144 	movi	r6,5
  46550c:	29800115 	stw	r6,4(r5)
  465510:	29800215 	stw	r6,8(r5)
  465514:	81400117 	ldw	r5,4(r16)
  465518:	2940004c 	andi	r5,r5,1
  46551c:	214ab03a 	or	r5,r4,r5
  465520:	81400115 	stw	r5,4(r16)
  465524:	1900ae36 	bltu	r3,r4,4657e0 <_malloc_r+0x704>
  465528:	d0e6ff17 	ldw	r3,-25604(gp)
  46552c:	1880012e 	bgeu	r3,r2,465534 <_malloc_r+0x458>
  465530:	d0a6ff15 	stw	r2,-25604(gp)
  465534:	d0e6fe17 	ldw	r3,-25608(gp)
  465538:	9c000217 	ldw	r16,8(r19)
  46553c:	1880012e 	bgeu	r3,r2,465544 <_malloc_r+0x468>
  465540:	d0a6fe15 	stw	r2,-25608(gp)
  465544:	80c00117 	ldw	r3,4(r16)
  465548:	00bfff04 	movi	r2,-4
  46554c:	1886703a 	and	r3,r3,r2
  465550:	1c45c83a 	sub	r2,r3,r17
  465554:	1c400236 	bltu	r3,r17,465560 <_malloc_r+0x484>
  465558:	00c003c4 	movi	r3,15
  46555c:	18800416 	blt	r3,r2,465570 <_malloc_r+0x494>
  465560:	9009883a 	mov	r4,r18
  465564:	046860c0 	call	46860c <__malloc_unlock>
  465568:	0005883a 	mov	r2,zero
  46556c:	003f0906 	br	465194 <_malloc_r+0xb8>
  465570:	88c00054 	ori	r3,r17,1
  465574:	10800054 	ori	r2,r2,1
  465578:	80c00115 	stw	r3,4(r16)
  46557c:	8463883a 	add	r17,r16,r17
  465580:	88800115 	stw	r2,4(r17)
  465584:	9009883a 	mov	r4,r18
  465588:	9c400215 	stw	r17,8(r19)
  46558c:	046860c0 	call	46860c <__malloc_unlock>
  465590:	80800204 	addi	r2,r16,8
  465594:	003eff06 	br	465194 <_malloc_r+0xb8>
  465598:	00800504 	movi	r2,20
  46559c:	1100492e 	bgeu	r2,r4,4656c4 <_malloc_r+0x5e8>
  4655a0:	00801504 	movi	r2,84
  4655a4:	11005c36 	bltu	r2,r4,465718 <_malloc_r+0x63c>
  4655a8:	8808d33a 	srli	r4,r17,12
  4655ac:	21001b84 	addi	r4,r4,110
  4655b0:	210b883a 	add	r5,r4,r4
  4655b4:	003f1006 	br	4651f8 <_malloc_r+0x11c>
  4655b8:	1006d27a 	srli	r3,r2,9
  4655bc:	01400104 	movi	r5,4
  4655c0:	28c0432e 	bgeu	r5,r3,4656d0 <_malloc_r+0x5f4>
  4655c4:	01400504 	movi	r5,20
  4655c8:	28c07036 	bltu	r5,r3,46578c <_malloc_r+0x6b0>
  4655cc:	194016c4 	addi	r5,r3,91
  4655d0:	294d883a 	add	r6,r5,r5
  4655d4:	318d883a 	add	r6,r6,r6
  4655d8:	318d883a 	add	r6,r6,r6
  4655dc:	998d883a 	add	r6,r19,r6
  4655e0:	30c00217 	ldw	r3,8(r6)
  4655e4:	01c011f4 	movhi	r7,71
  4655e8:	39d9a704 	addi	r7,r7,26268
  4655ec:	19805726 	beq	r3,r6,46574c <_malloc_r+0x670>
  4655f0:	01ffff04 	movi	r7,-4
  4655f4:	19400117 	ldw	r5,4(r3)
  4655f8:	29ca703a 	and	r5,r5,r7
  4655fc:	1140022e 	bgeu	r2,r5,465608 <_malloc_r+0x52c>
  465600:	18c00217 	ldw	r3,8(r3)
  465604:	30fffb1e 	bne	r6,r3,4655f4 <_malloc_r+0x518>
  465608:	19400317 	ldw	r5,12(r3)
  46560c:	98800117 	ldw	r2,4(r19)
  465610:	81400315 	stw	r5,12(r16)
  465614:	80c00215 	stw	r3,8(r16)
  465618:	2c000215 	stw	r16,8(r5)
  46561c:	1c000315 	stw	r16,12(r3)
  465620:	003f2b06 	br	4652d0 <_malloc_r+0x1f4>
  465624:	8445883a 	add	r2,r16,r17
  465628:	8c400054 	ori	r17,r17,1
  46562c:	18800515 	stw	r2,20(r3)
  465630:	18800415 	stw	r2,16(r3)
  465634:	29000054 	ori	r4,r5,1
  465638:	1147883a 	add	r3,r2,r5
  46563c:	84400115 	stw	r17,4(r16)
  465640:	11000115 	stw	r4,4(r2)
  465644:	12400315 	stw	r9,12(r2)
  465648:	12400215 	stw	r9,8(r2)
  46564c:	19400015 	stw	r5,0(r3)
  465650:	9009883a 	mov	r4,r18
  465654:	046860c0 	call	46860c <__malloc_unlock>
  465658:	80800204 	addi	r2,r16,8
  46565c:	003ecd06 	br	465194 <_malloc_r+0xb8>
  465660:	18800117 	ldw	r2,4(r3)
  465664:	003f1a06 	br	4652d0 <_malloc_r+0x1f4>
  465668:	5ac00044 	addi	r11,r11,1
  46566c:	588000cc 	andi	r2,r11,3
  465670:	52800204 	addi	r10,r10,8
  465674:	103f2e1e 	bne	r2,zero,465330 <_malloc_r+0x254>
  465678:	20c000cc 	andi	r3,r4,3
  46567c:	60bffe04 	addi	r2,r12,-8
  465680:	18006f26 	beq	r3,zero,465840 <_malloc_r+0x764>
  465684:	63000017 	ldw	r12,0(r12)
  465688:	213fffc4 	addi	r4,r4,-1
  46568c:	60bffa26 	beq	r12,r2,465678 <_malloc_r+0x59c>
  465690:	98800117 	ldw	r2,4(r19)
  465694:	294b883a 	add	r5,r5,r5
  465698:	117f5a36 	bltu	r2,r5,465404 <_malloc_r+0x328>
  46569c:	283f5926 	beq	r5,zero,465404 <_malloc_r+0x328>
  4656a0:	1146703a 	and	r3,r2,r5
  4656a4:	18001626 	beq	r3,zero,465700 <_malloc_r+0x624>
  4656a8:	5809883a 	mov	r4,r11
  4656ac:	003f1a06 	br	465318 <_malloc_r+0x23c>
  4656b0:	80800204 	addi	r2,r16,8
  4656b4:	84000517 	ldw	r16,20(r16)
  4656b8:	143ea81e 	bne	r2,r16,46515c <_malloc_r+0x80>
  4656bc:	21000084 	addi	r4,r4,2
  4656c0:	003ee306 	br	465250 <_malloc_r+0x174>
  4656c4:	210016c4 	addi	r4,r4,91
  4656c8:	210b883a 	add	r5,r4,r4
  4656cc:	003eca06 	br	4651f8 <_malloc_r+0x11c>
  4656d0:	100ad1ba 	srli	r5,r2,6
  4656d4:	29400e04 	addi	r5,r5,56
  4656d8:	294d883a 	add	r6,r5,r5
  4656dc:	003fbd06 	br	4655d4 <_malloc_r+0x4f8>
  4656e0:	84ff6026 	beq	r16,r19,465464 <_malloc_r+0x388>
  4656e4:	008011f4 	movhi	r2,71
  4656e8:	1099a704 	addi	r2,r2,26268
  4656ec:	14000217 	ldw	r16,8(r2)
  4656f0:	00bfff04 	movi	r2,-4
  4656f4:	80c00117 	ldw	r3,4(r16)
  4656f8:	1886703a 	and	r3,r3,r2
  4656fc:	003f9406 	br	465550 <_malloc_r+0x474>
  465700:	294b883a 	add	r5,r5,r5
  465704:	1146703a 	and	r3,r2,r5
  465708:	5ac00104 	addi	r11,r11,4
  46570c:	183ffc26 	beq	r3,zero,465700 <_malloc_r+0x624>
  465710:	5809883a 	mov	r4,r11
  465714:	003f0006 	br	465318 <_malloc_r+0x23c>
  465718:	00805504 	movi	r2,340
  46571c:	11001336 	bltu	r2,r4,46576c <_malloc_r+0x690>
  465720:	8808d3fa 	srli	r4,r17,15
  465724:	21001dc4 	addi	r4,r4,119
  465728:	210b883a 	add	r5,r4,r4
  46572c:	003eb206 	br	4651f8 <_malloc_r+0x11c>
  465730:	00840004 	movi	r2,4096
  465734:	003f5d06 	br	4654ac <_malloc_r+0x3d0>
  465738:	00800044 	movi	r2,1
  46573c:	a0800115 	stw	r2,4(r20)
  465740:	a021883a 	mov	r16,r20
  465744:	0007883a 	mov	r3,zero
  465748:	003f8106 	br	465550 <_malloc_r+0x474>
  46574c:	280bd0ba 	srai	r5,r5,2
  465750:	01800044 	movi	r6,1
  465754:	38800117 	ldw	r2,4(r7)
  465758:	314c983a 	sll	r6,r6,r5
  46575c:	180b883a 	mov	r5,r3
  465760:	3084b03a 	or	r2,r6,r2
  465764:	38800115 	stw	r2,4(r7)
  465768:	003fa906 	br	465610 <_malloc_r+0x534>
  46576c:	00815504 	movi	r2,1364
  465770:	11001836 	bltu	r2,r4,4657d4 <_malloc_r+0x6f8>
  465774:	8808d4ba 	srli	r4,r17,18
  465778:	21001f04 	addi	r4,r4,124
  46577c:	210b883a 	add	r5,r4,r4
  465780:	003e9d06 	br	4651f8 <_malloc_r+0x11c>
  465784:	bdc00404 	addi	r23,r23,16
  465788:	003f2f06 	br	465448 <_malloc_r+0x36c>
  46578c:	01401504 	movi	r5,84
  465790:	28c01f36 	bltu	r5,r3,465810 <_malloc_r+0x734>
  465794:	100ad33a 	srli	r5,r2,12
  465798:	29401b84 	addi	r5,r5,110
  46579c:	294d883a 	add	r6,r5,r5
  4657a0:	003f8c06 	br	4655d4 <_malloc_r+0x4f8>
  4657a4:	9c000217 	ldw	r16,8(r19)
  4657a8:	00bfff04 	movi	r2,-4
  4657ac:	80c00117 	ldw	r3,4(r16)
  4657b0:	1886703a 	and	r3,r3,r2
  4657b4:	003f6606 	br	465550 <_malloc_r+0x474>
  4657b8:	e0c3ffcc 	andi	r3,fp,4095
  4657bc:	183f2f1e 	bne	r3,zero,46547c <_malloc_r+0x3a0>
  4657c0:	98c00217 	ldw	r3,8(r19)
  4657c4:	bd49883a 	add	r4,r23,r21
  4657c8:	21000054 	ori	r4,r4,1
  4657cc:	19000115 	stw	r4,4(r3)
  4657d0:	003f5506 	br	465528 <_malloc_r+0x44c>
  4657d4:	01403f04 	movi	r5,252
  4657d8:	01001f84 	movi	r4,126
  4657dc:	003e8606 	br	4651f8 <_malloc_r+0x11c>
  4657e0:	9009883a 	mov	r4,r18
  4657e4:	81400204 	addi	r5,r16,8
  4657e8:	0466a380 	call	466a38 <_free_r>
  4657ec:	00801234 	movhi	r2,72
  4657f0:	10a65604 	addi	r2,r2,-26280
  4657f4:	10800017 	ldw	r2,0(r2)
  4657f8:	003f4b06 	br	465528 <_malloc_r+0x44c>
  4657fc:	00c00044 	movi	r3,1
  465800:	002f883a 	mov	r23,zero
  465804:	003f3406 	br	4654d8 <_malloc_r+0x3fc>
  465808:	d5200815 	stw	r20,-32736(gp)
  46580c:	003f2106 	br	465494 <_malloc_r+0x3b8>
  465810:	01405504 	movi	r5,340
  465814:	28c00436 	bltu	r5,r3,465828 <_malloc_r+0x74c>
  465818:	100ad3fa 	srli	r5,r2,15
  46581c:	29401dc4 	addi	r5,r5,119
  465820:	294d883a 	add	r6,r5,r5
  465824:	003f6b06 	br	4655d4 <_malloc_r+0x4f8>
  465828:	01415504 	movi	r5,1364
  46582c:	28c00936 	bltu	r5,r3,465854 <_malloc_r+0x778>
  465830:	100ad4ba 	srli	r5,r2,18
  465834:	29401f04 	addi	r5,r5,124
  465838:	294d883a 	add	r6,r5,r5
  46583c:	003f6506 	br	4655d4 <_malloc_r+0x4f8>
  465840:	98800117 	ldw	r2,4(r19)
  465844:	0146303a 	nor	r3,zero,r5
  465848:	1884703a 	and	r2,r3,r2
  46584c:	98800115 	stw	r2,4(r19)
  465850:	003f9006 	br	465694 <_malloc_r+0x5b8>
  465854:	01803f04 	movi	r6,252
  465858:	01401f84 	movi	r5,126
  46585c:	003f5d06 	br	4655d4 <_malloc_r+0x4f8>

00465860 <memchr>:
  465860:	008000c4 	movi	r2,3
  465864:	29403fcc 	andi	r5,r5,255
  465868:	1180282e 	bgeu	r2,r6,46590c <memchr+0xac>
  46586c:	2086703a 	and	r3,r4,r2
  465870:	1800351e 	bne	r3,zero,465948 <memchr+0xe8>
  465874:	2816923a 	slli	r11,r5,8
  465878:	2093883a 	add	r9,r4,r2
  46587c:	22000084 	addi	r8,r4,2
  465880:	5957883a 	add	r11,r11,r5
  465884:	5816923a 	slli	r11,r11,8
  465888:	20c00044 	addi	r3,r4,1
  46588c:	037fbff4 	movhi	r13,65279
  465890:	6b7fbfc4 	addi	r13,r13,-257
  465894:	5957883a 	add	r11,r11,r5
  465898:	5816923a 	slli	r11,r11,8
  46589c:	03202074 	movhi	r12,32897
  4658a0:	63202004 	addi	r12,r12,-32640
  4658a4:	101d883a 	mov	r14,r2
  4658a8:	5957883a 	add	r11,r11,r5
  4658ac:	21c00017 	ldw	r7,0(r4)
  4658b0:	31bfff04 	addi	r6,r6,-4
  4658b4:	1805883a 	mov	r2,r3
  4658b8:	3acef03a 	xor	r7,r7,r11
  4658bc:	3b55883a 	add	r10,r7,r13
  4658c0:	01ce303a 	nor	r7,zero,r7
  4658c4:	51ce703a 	and	r7,r10,r7
  4658c8:	3b0e703a 	and	r7,r7,r12
  4658cc:	38000a26 	beq	r7,zero,4658f8 <memchr+0x98>
  4658d0:	21c00003 	ldbu	r7,0(r4)
  4658d4:	39401e26 	beq	r7,r5,465950 <memchr+0xf0>
  4658d8:	19c00003 	ldbu	r7,0(r3)
  4658dc:	39401926 	beq	r7,r5,465944 <memchr+0xe4>
  4658e0:	41c00003 	ldbu	r7,0(r8)
  4658e4:	4005883a 	mov	r2,r8
  4658e8:	39401626 	beq	r7,r5,465944 <memchr+0xe4>
  4658ec:	49c00003 	ldbu	r7,0(r9)
  4658f0:	4805883a 	mov	r2,r9
  4658f4:	39401326 	beq	r7,r5,465944 <memchr+0xe4>
  4658f8:	21000104 	addi	r4,r4,4
  4658fc:	4a400104 	addi	r9,r9,4
  465900:	42000104 	addi	r8,r8,4
  465904:	18c00104 	addi	r3,r3,4
  465908:	71bfe836 	bltu	r14,r6,4658ac <memchr+0x4c>
  46590c:	2005883a 	mov	r2,r4
  465910:	30000a26 	beq	r6,zero,46593c <memchr+0xdc>
  465914:	10c00003 	ldbu	r3,0(r2)
  465918:	19400a26 	beq	r3,r5,465944 <memchr+0xe4>
  46591c:	10c00044 	addi	r3,r2,1
  465920:	118d883a 	add	r6,r2,r6
  465924:	00000306 	br	465934 <memchr+0xd4>
  465928:	11000003 	ldbu	r4,0(r2)
  46592c:	18c00044 	addi	r3,r3,1
  465930:	21400426 	beq	r4,r5,465944 <memchr+0xe4>
  465934:	1805883a 	mov	r2,r3
  465938:	19bffb1e 	bne	r3,r6,465928 <memchr+0xc8>
  46593c:	0005883a 	mov	r2,zero
  465940:	f800283a 	ret
  465944:	f800283a 	ret
  465948:	2005883a 	mov	r2,r4
  46594c:	003ff106 	br	465914 <memchr+0xb4>
  465950:	2005883a 	mov	r2,r4
  465954:	f800283a 	ret

00465958 <memcpy>:
  465958:	defffb04 	addi	sp,sp,-20
  46595c:	dc000015 	stw	r16,0(sp)
  465960:	dfc00415 	stw	ra,16(sp)
  465964:	dcc00315 	stw	r19,12(sp)
  465968:	dc800215 	stw	r18,8(sp)
  46596c:	dc400115 	stw	r17,4(sp)
  465970:	00c003c4 	movi	r3,15
  465974:	2021883a 	mov	r16,r4
  465978:	3005883a 	mov	r2,r6
  46597c:	1980032e 	bgeu	r3,r6,46598c <memcpy+0x34>
  465980:	2906b03a 	or	r3,r5,r4
  465984:	18c000cc 	andi	r3,r3,3
  465988:	18001026 	beq	r3,zero,4659cc <memcpy+0x74>
  46598c:	8007883a 	mov	r3,r16
  465990:	288f883a 	add	r7,r5,r2
  465994:	10000526 	beq	r2,zero,4659ac <memcpy+0x54>
  465998:	29800003 	ldbu	r6,0(r5)
  46599c:	18c00044 	addi	r3,r3,1
  4659a0:	29400044 	addi	r5,r5,1
  4659a4:	19bfffc5 	stb	r6,-1(r3)
  4659a8:	29fffb1e 	bne	r5,r7,465998 <memcpy+0x40>
  4659ac:	8005883a 	mov	r2,r16
  4659b0:	dfc00417 	ldw	ra,16(sp)
  4659b4:	dcc00317 	ldw	r19,12(sp)
  4659b8:	dc800217 	ldw	r18,8(sp)
  4659bc:	dc400117 	ldw	r17,4(sp)
  4659c0:	dc000017 	ldw	r16,0(sp)
  4659c4:	dec00504 	addi	sp,sp,20
  4659c8:	f800283a 	ret
  4659cc:	32bffc04 	addi	r10,r6,-16
  4659d0:	5014d13a 	srli	r10,r10,4
  4659d4:	20800404 	addi	r2,r4,16
  4659d8:	2007883a 	mov	r3,r4
  4659dc:	5008913a 	slli	r4,r10,4
  4659e0:	280f883a 	mov	r7,r5
  4659e4:	1105883a 	add	r2,r2,r4
  4659e8:	3a000017 	ldw	r8,0(r7)
  4659ec:	18c00404 	addi	r3,r3,16
  4659f0:	39c00404 	addi	r7,r7,16
  4659f4:	1a3ffc15 	stw	r8,-16(r3)
  4659f8:	3a3ffd17 	ldw	r8,-12(r7)
  4659fc:	1a3ffd15 	stw	r8,-12(r3)
  465a00:	3a3ffe17 	ldw	r8,-8(r7)
  465a04:	1a3ffe15 	stw	r8,-8(r3)
  465a08:	3a3fff17 	ldw	r8,-4(r7)
  465a0c:	1a3fff15 	stw	r8,-4(r3)
  465a10:	18bff51e 	bne	r3,r2,4659e8 <memcpy+0x90>
  465a14:	52800044 	addi	r10,r10,1
  465a18:	5014913a 	slli	r10,r10,4
  465a1c:	308003cc 	andi	r2,r6,15
  465a20:	010000c4 	movi	r4,3
  465a24:	8287883a 	add	r3,r16,r10
  465a28:	2a95883a 	add	r10,r5,r10
  465a2c:	2080182e 	bgeu	r4,r2,465a90 <memcpy+0x138>
  465a30:	147fff04 	addi	r17,r2,-4
  465a34:	8808d0ba 	srli	r4,r17,2
  465a38:	1a400104 	addi	r9,r3,4
  465a3c:	180d883a 	mov	r6,r3
  465a40:	2105883a 	add	r2,r4,r4
  465a44:	1085883a 	add	r2,r2,r2
  465a48:	4893883a 	add	r9,r9,r2
  465a4c:	500f883a 	mov	r7,r10
  465a50:	3a000017 	ldw	r8,0(r7)
  465a54:	31800104 	addi	r6,r6,4
  465a58:	39c00104 	addi	r7,r7,4
  465a5c:	323fff15 	stw	r8,-4(r6)
  465a60:	327ffb1e 	bne	r6,r9,465a50 <memcpy+0xf8>
  465a64:	20800044 	addi	r2,r4,1
  465a68:	1085883a 	add	r2,r2,r2
  465a6c:	1085883a 	add	r2,r2,r2
  465a70:	017fff04 	movi	r5,-4
  465a74:	18a5883a 	add	r18,r3,r2
  465a78:	50a7883a 	add	r19,r10,r2
  465a7c:	04675f00 	call	4675f0 <__mulsi3>
  465a80:	1445883a 	add	r2,r2,r17
  465a84:	980b883a 	mov	r5,r19
  465a88:	9007883a 	mov	r3,r18
  465a8c:	003fc006 	br	465990 <memcpy+0x38>
  465a90:	500b883a 	mov	r5,r10
  465a94:	003fbe06 	br	465990 <memcpy+0x38>

00465a98 <memmove>:
  465a98:	defffb04 	addi	sp,sp,-20
  465a9c:	dc000015 	stw	r16,0(sp)
  465aa0:	dfc00415 	stw	ra,16(sp)
  465aa4:	dcc00315 	stw	r19,12(sp)
  465aa8:	dc800215 	stw	r18,8(sp)
  465aac:	dc400115 	stw	r17,4(sp)
  465ab0:	2021883a 	mov	r16,r4
  465ab4:	300f883a 	mov	r7,r6
  465ab8:	2900122e 	bgeu	r5,r4,465b04 <memmove+0x6c>
  465abc:	2987883a 	add	r3,r5,r6
  465ac0:	20c0102e 	bgeu	r4,r3,465b04 <memmove+0x6c>
  465ac4:	218b883a 	add	r5,r4,r6
  465ac8:	1989c83a 	sub	r4,r3,r6
  465acc:	30000526 	beq	r6,zero,465ae4 <memmove+0x4c>
  465ad0:	18ffffc4 	addi	r3,r3,-1
  465ad4:	18800003 	ldbu	r2,0(r3)
  465ad8:	297fffc4 	addi	r5,r5,-1
  465adc:	28800005 	stb	r2,0(r5)
  465ae0:	193ffb1e 	bne	r3,r4,465ad0 <memmove+0x38>
  465ae4:	8005883a 	mov	r2,r16
  465ae8:	dfc00417 	ldw	ra,16(sp)
  465aec:	dcc00317 	ldw	r19,12(sp)
  465af0:	dc800217 	ldw	r18,8(sp)
  465af4:	dc400117 	ldw	r17,4(sp)
  465af8:	dc000017 	ldw	r16,0(sp)
  465afc:	dec00504 	addi	sp,sp,20
  465b00:	f800283a 	ret
  465b04:	008003c4 	movi	r2,15
  465b08:	1180422e 	bgeu	r2,r6,465c14 <memmove+0x17c>
  465b0c:	2c04b03a 	or	r2,r5,r16
  465b10:	108000cc 	andi	r2,r2,3
  465b14:	10003f1e 	bne	r2,zero,465c14 <memmove+0x17c>
  465b18:	32bffc04 	addi	r10,r6,-16
  465b1c:	5014d13a 	srli	r10,r10,4
  465b20:	81000404 	addi	r4,r16,16
  465b24:	8007883a 	mov	r3,r16
  465b28:	5004913a 	slli	r2,r10,4
  465b2c:	280f883a 	mov	r7,r5
  465b30:	2089883a 	add	r4,r4,r2
  465b34:	38800017 	ldw	r2,0(r7)
  465b38:	18c00404 	addi	r3,r3,16
  465b3c:	39c00404 	addi	r7,r7,16
  465b40:	18bffc15 	stw	r2,-16(r3)
  465b44:	38bffd17 	ldw	r2,-12(r7)
  465b48:	18bffd15 	stw	r2,-12(r3)
  465b4c:	38bffe17 	ldw	r2,-8(r7)
  465b50:	18bffe15 	stw	r2,-8(r3)
  465b54:	38bfff17 	ldw	r2,-4(r7)
  465b58:	18bfff15 	stw	r2,-4(r3)
  465b5c:	193ff51e 	bne	r3,r4,465b34 <memmove+0x9c>
  465b60:	52800044 	addi	r10,r10,1
  465b64:	5014913a 	slli	r10,r10,4
  465b68:	31c003cc 	andi	r7,r6,15
  465b6c:	008000c4 	movi	r2,3
  465b70:	8287883a 	add	r3,r16,r10
  465b74:	2a95883a 	add	r10,r5,r10
  465b78:	11c0282e 	bgeu	r2,r7,465c1c <memmove+0x184>
  465b7c:	3c7fff04 	addi	r17,r7,-4
  465b80:	8808d0ba 	srli	r4,r17,2
  465b84:	1a400104 	addi	r9,r3,4
  465b88:	180d883a 	mov	r6,r3
  465b8c:	2105883a 	add	r2,r4,r4
  465b90:	1085883a 	add	r2,r2,r2
  465b94:	4893883a 	add	r9,r9,r2
  465b98:	5005883a 	mov	r2,r10
  465b9c:	12000017 	ldw	r8,0(r2)
  465ba0:	31800104 	addi	r6,r6,4
  465ba4:	10800104 	addi	r2,r2,4
  465ba8:	323fff15 	stw	r8,-4(r6)
  465bac:	327ffb1e 	bne	r6,r9,465b9c <memmove+0x104>
  465bb0:	20800044 	addi	r2,r4,1
  465bb4:	1085883a 	add	r2,r2,r2
  465bb8:	1085883a 	add	r2,r2,r2
  465bbc:	017fff04 	movi	r5,-4
  465bc0:	18a5883a 	add	r18,r3,r2
  465bc4:	50a7883a 	add	r19,r10,r2
  465bc8:	04675f00 	call	4675f0 <__mulsi3>
  465bcc:	144f883a 	add	r7,r2,r17
  465bd0:	980b883a 	mov	r5,r19
  465bd4:	9007883a 	mov	r3,r18
  465bd8:	383fc226 	beq	r7,zero,465ae4 <memmove+0x4c>
  465bdc:	19cf883a 	add	r7,r3,r7
  465be0:	29800003 	ldbu	r6,0(r5)
  465be4:	18c00044 	addi	r3,r3,1
  465be8:	29400044 	addi	r5,r5,1
  465bec:	19bfffc5 	stb	r6,-1(r3)
  465bf0:	19fffb1e 	bne	r3,r7,465be0 <memmove+0x148>
  465bf4:	8005883a 	mov	r2,r16
  465bf8:	dfc00417 	ldw	ra,16(sp)
  465bfc:	dcc00317 	ldw	r19,12(sp)
  465c00:	dc800217 	ldw	r18,8(sp)
  465c04:	dc400117 	ldw	r17,4(sp)
  465c08:	dc000017 	ldw	r16,0(sp)
  465c0c:	dec00504 	addi	sp,sp,20
  465c10:	f800283a 	ret
  465c14:	8007883a 	mov	r3,r16
  465c18:	003fef06 	br	465bd8 <memmove+0x140>
  465c1c:	500b883a 	mov	r5,r10
  465c20:	003fed06 	br	465bd8 <memmove+0x140>

00465c24 <_realloc_r>:
  465c24:	defff504 	addi	sp,sp,-44
  465c28:	dd400615 	stw	r21,24(sp)
  465c2c:	dc800315 	stw	r18,12(sp)
  465c30:	dc000115 	stw	r16,4(sp)
  465c34:	dfc00a15 	stw	ra,40(sp)
  465c38:	df000915 	stw	fp,36(sp)
  465c3c:	ddc00815 	stw	r23,32(sp)
  465c40:	dd800715 	stw	r22,28(sp)
  465c44:	dd000515 	stw	r20,20(sp)
  465c48:	dcc00415 	stw	r19,16(sp)
  465c4c:	dc400215 	stw	r17,8(sp)
  465c50:	2821883a 	mov	r16,r5
  465c54:	202b883a 	mov	r21,r4
  465c58:	3025883a 	mov	r18,r6
  465c5c:	28009626 	beq	r5,zero,465eb8 <_realloc_r+0x294>
  465c60:	04684a00 	call	4684a0 <__malloc_lock>
  465c64:	80bfff17 	ldw	r2,-4(r16)
  465c68:	04ffff04 	movi	r19,-4
  465c6c:	90c002c4 	addi	r3,r18,11
  465c70:	01000584 	movi	r4,22
  465c74:	85bffe04 	addi	r22,r16,-8
  465c78:	14e6703a 	and	r19,r2,r19
  465c7c:	20c0372e 	bgeu	r4,r3,465d5c <_realloc_r+0x138>
  465c80:	047ffe04 	movi	r17,-8
  465c84:	1c62703a 	and	r17,r3,r17
  465c88:	8807883a 	mov	r3,r17
  465c8c:	88005a16 	blt	r17,zero,465df8 <_realloc_r+0x1d4>
  465c90:	8c805936 	bltu	r17,r18,465df8 <_realloc_r+0x1d4>
  465c94:	98c0340e 	bge	r19,r3,465d68 <_realloc_r+0x144>
  465c98:	070011f4 	movhi	fp,71
  465c9c:	e719a704 	addi	fp,fp,26268
  465ca0:	e1400217 	ldw	r5,8(fp)
  465ca4:	b4c9883a 	add	r4,r22,r19
  465ca8:	29009026 	beq	r5,r4,465eec <_realloc_r+0x2c8>
  465cac:	21800117 	ldw	r6,4(r4)
  465cb0:	01ffff84 	movi	r7,-2
  465cb4:	31ce703a 	and	r7,r6,r7
  465cb8:	21cf883a 	add	r7,r4,r7
  465cbc:	39c00117 	ldw	r7,4(r7)
  465cc0:	39c0004c 	andi	r7,r7,1
  465cc4:	38004326 	beq	r7,zero,465dd4 <_realloc_r+0x1b0>
  465cc8:	000d883a 	mov	r6,zero
  465ccc:	0009883a 	mov	r4,zero
  465cd0:	1080004c 	andi	r2,r2,1
  465cd4:	10005a1e 	bne	r2,zero,465e40 <_realloc_r+0x21c>
  465cd8:	85fffe17 	ldw	r23,-8(r16)
  465cdc:	00bfff04 	movi	r2,-4
  465ce0:	b5efc83a 	sub	r23,r22,r23
  465ce4:	b9c00117 	ldw	r7,4(r23)
  465ce8:	388e703a 	and	r7,r7,r2
  465cec:	3ccf883a 	add	r7,r7,r19
  465cf0:	20005226 	beq	r4,zero,465e3c <_realloc_r+0x218>
  465cf4:	31e9883a 	add	r20,r6,r7
  465cf8:	2140c726 	beq	r4,r5,466018 <_realloc_r+0x3f4>
  465cfc:	a0c04f16 	blt	r20,r3,465e3c <_realloc_r+0x218>
  465d00:	20800317 	ldw	r2,12(r4)
  465d04:	20c00217 	ldw	r3,8(r4)
  465d08:	99bfff04 	addi	r6,r19,-4
  465d0c:	01000904 	movi	r4,36
  465d10:	18800315 	stw	r2,12(r3)
  465d14:	10c00215 	stw	r3,8(r2)
  465d18:	b8c00217 	ldw	r3,8(r23)
  465d1c:	b8800317 	ldw	r2,12(r23)
  465d20:	bc800204 	addi	r18,r23,8
  465d24:	18800315 	stw	r2,12(r3)
  465d28:	10c00215 	stw	r3,8(r2)
  465d2c:	2180ed36 	bltu	r4,r6,4660e4 <_realloc_r+0x4c0>
  465d30:	008004c4 	movi	r2,19
  465d34:	11809b2e 	bgeu	r2,r6,465fa4 <_realloc_r+0x380>
  465d38:	80800017 	ldw	r2,0(r16)
  465d3c:	b8800215 	stw	r2,8(r23)
  465d40:	80800117 	ldw	r2,4(r16)
  465d44:	b8800315 	stw	r2,12(r23)
  465d48:	008006c4 	movi	r2,27
  465d4c:	1180f936 	bltu	r2,r6,466134 <_realloc_r+0x510>
  465d50:	b8800404 	addi	r2,r23,16
  465d54:	80c00204 	addi	r3,r16,8
  465d58:	00009406 	br	465fac <_realloc_r+0x388>
  465d5c:	00c00404 	movi	r3,16
  465d60:	1823883a 	mov	r17,r3
  465d64:	003fca06 	br	465c90 <_realloc_r+0x6c>
  465d68:	9829883a 	mov	r20,r19
  465d6c:	a447c83a 	sub	r3,r20,r17
  465d70:	010003c4 	movi	r4,15
  465d74:	1080004c 	andi	r2,r2,1
  465d78:	20c02336 	bltu	r4,r3,465e08 <_realloc_r+0x1e4>
  465d7c:	1504b03a 	or	r2,r2,r20
  465d80:	b0800115 	stw	r2,4(r22)
  465d84:	b52d883a 	add	r22,r22,r20
  465d88:	b0800117 	ldw	r2,4(r22)
  465d8c:	10800054 	ori	r2,r2,1
  465d90:	b0800115 	stw	r2,4(r22)
  465d94:	a809883a 	mov	r4,r21
  465d98:	046860c0 	call	46860c <__malloc_unlock>
  465d9c:	8025883a 	mov	r18,r16
  465da0:	9005883a 	mov	r2,r18
  465da4:	dfc00a17 	ldw	ra,40(sp)
  465da8:	df000917 	ldw	fp,36(sp)
  465dac:	ddc00817 	ldw	r23,32(sp)
  465db0:	dd800717 	ldw	r22,28(sp)
  465db4:	dd400617 	ldw	r21,24(sp)
  465db8:	dd000517 	ldw	r20,20(sp)
  465dbc:	dcc00417 	ldw	r19,16(sp)
  465dc0:	dc800317 	ldw	r18,12(sp)
  465dc4:	dc400217 	ldw	r17,8(sp)
  465dc8:	dc000117 	ldw	r16,4(sp)
  465dcc:	dec00b04 	addi	sp,sp,44
  465dd0:	f800283a 	ret
  465dd4:	01ffff04 	movi	r7,-4
  465dd8:	31cc703a 	and	r6,r6,r7
  465ddc:	34e9883a 	add	r20,r6,r19
  465de0:	a0ffbb16 	blt	r20,r3,465cd0 <_realloc_r+0xac>
  465de4:	20c00317 	ldw	r3,12(r4)
  465de8:	21000217 	ldw	r4,8(r4)
  465dec:	20c00315 	stw	r3,12(r4)
  465df0:	19000215 	stw	r4,8(r3)
  465df4:	003fdd06 	br	465d6c <_realloc_r+0x148>
  465df8:	00800304 	movi	r2,12
  465dfc:	a8800015 	stw	r2,0(r21)
  465e00:	0025883a 	mov	r18,zero
  465e04:	003fe606 	br	465da0 <_realloc_r+0x17c>
  465e08:	1444b03a 	or	r2,r2,r17
  465e0c:	b0800115 	stw	r2,4(r22)
  465e10:	b44b883a 	add	r5,r22,r17
  465e14:	18800054 	ori	r2,r3,1
  465e18:	28800115 	stw	r2,4(r5)
  465e1c:	28c7883a 	add	r3,r5,r3
  465e20:	18800117 	ldw	r2,4(r3)
  465e24:	a809883a 	mov	r4,r21
  465e28:	29400204 	addi	r5,r5,8
  465e2c:	10800054 	ori	r2,r2,1
  465e30:	18800115 	stw	r2,4(r3)
  465e34:	0466a380 	call	466a38 <_free_r>
  465e38:	003fd606 	br	465d94 <_realloc_r+0x170>
  465e3c:	38c0330e 	bge	r7,r3,465f0c <_realloc_r+0x2e8>
  465e40:	900b883a 	mov	r5,r18
  465e44:	a809883a 	mov	r4,r21
  465e48:	04650dc0 	call	4650dc <_malloc_r>
  465e4c:	1025883a 	mov	r18,r2
  465e50:	10001626 	beq	r2,zero,465eac <_realloc_r+0x288>
  465e54:	80bfff17 	ldw	r2,-4(r16)
  465e58:	00ffff84 	movi	r3,-2
  465e5c:	913ffe04 	addi	r4,r18,-8
  465e60:	10c6703a 	and	r3,r2,r3
  465e64:	b0c7883a 	add	r3,r22,r3
  465e68:	20c09926 	beq	r4,r3,4660d0 <_realloc_r+0x4ac>
  465e6c:	99bfff04 	addi	r6,r19,-4
  465e70:	00800904 	movi	r2,36
  465e74:	11806436 	bltu	r2,r6,466008 <_realloc_r+0x3e4>
  465e78:	00c004c4 	movi	r3,19
  465e7c:	19804036 	bltu	r3,r6,465f80 <_realloc_r+0x35c>
  465e80:	9005883a 	mov	r2,r18
  465e84:	8007883a 	mov	r3,r16
  465e88:	19000017 	ldw	r4,0(r3)
  465e8c:	11000015 	stw	r4,0(r2)
  465e90:	19000117 	ldw	r4,4(r3)
  465e94:	11000115 	stw	r4,4(r2)
  465e98:	18c00217 	ldw	r3,8(r3)
  465e9c:	10c00215 	stw	r3,8(r2)
  465ea0:	a809883a 	mov	r4,r21
  465ea4:	800b883a 	mov	r5,r16
  465ea8:	0466a380 	call	466a38 <_free_r>
  465eac:	a809883a 	mov	r4,r21
  465eb0:	046860c0 	call	46860c <__malloc_unlock>
  465eb4:	003fba06 	br	465da0 <_realloc_r+0x17c>
  465eb8:	300b883a 	mov	r5,r6
  465ebc:	dfc00a17 	ldw	ra,40(sp)
  465ec0:	df000917 	ldw	fp,36(sp)
  465ec4:	ddc00817 	ldw	r23,32(sp)
  465ec8:	dd800717 	ldw	r22,28(sp)
  465ecc:	dd400617 	ldw	r21,24(sp)
  465ed0:	dd000517 	ldw	r20,20(sp)
  465ed4:	dcc00417 	ldw	r19,16(sp)
  465ed8:	dc800317 	ldw	r18,12(sp)
  465edc:	dc400217 	ldw	r17,8(sp)
  465ee0:	dc000117 	ldw	r16,4(sp)
  465ee4:	dec00b04 	addi	sp,sp,44
  465ee8:	04650dc1 	jmpi	4650dc <_malloc_r>
  465eec:	29800117 	ldw	r6,4(r5)
  465ef0:	013fff04 	movi	r4,-4
  465ef4:	89c00404 	addi	r7,r17,16
  465ef8:	310c703a 	and	r6,r6,r4
  465efc:	34c9883a 	add	r4,r6,r19
  465f00:	21c0340e 	bge	r4,r7,465fd4 <_realloc_r+0x3b0>
  465f04:	2809883a 	mov	r4,r5
  465f08:	003f7106 	br	465cd0 <_realloc_r+0xac>
  465f0c:	b8800317 	ldw	r2,12(r23)
  465f10:	b8c00217 	ldw	r3,8(r23)
  465f14:	99bfff04 	addi	r6,r19,-4
  465f18:	01000904 	movi	r4,36
  465f1c:	18800315 	stw	r2,12(r3)
  465f20:	10c00215 	stw	r3,8(r2)
  465f24:	bc800204 	addi	r18,r23,8
  465f28:	21807836 	bltu	r4,r6,46610c <_realloc_r+0x4e8>
  465f2c:	008004c4 	movi	r2,19
  465f30:	1180732e 	bgeu	r2,r6,466100 <_realloc_r+0x4dc>
  465f34:	80800017 	ldw	r2,0(r16)
  465f38:	b8800215 	stw	r2,8(r23)
  465f3c:	80800117 	ldw	r2,4(r16)
  465f40:	b8800315 	stw	r2,12(r23)
  465f44:	008006c4 	movi	r2,27
  465f48:	11808936 	bltu	r2,r6,466170 <_realloc_r+0x54c>
  465f4c:	b8800404 	addi	r2,r23,16
  465f50:	80c00204 	addi	r3,r16,8
  465f54:	19000017 	ldw	r4,0(r3)
  465f58:	9021883a 	mov	r16,r18
  465f5c:	3829883a 	mov	r20,r7
  465f60:	11000015 	stw	r4,0(r2)
  465f64:	19000117 	ldw	r4,4(r3)
  465f68:	b82d883a 	mov	r22,r23
  465f6c:	11000115 	stw	r4,4(r2)
  465f70:	18c00217 	ldw	r3,8(r3)
  465f74:	10c00215 	stw	r3,8(r2)
  465f78:	b8800117 	ldw	r2,4(r23)
  465f7c:	003f7b06 	br	465d6c <_realloc_r+0x148>
  465f80:	80c00017 	ldw	r3,0(r16)
  465f84:	90c00015 	stw	r3,0(r18)
  465f88:	80c00117 	ldw	r3,4(r16)
  465f8c:	90c00115 	stw	r3,4(r18)
  465f90:	00c006c4 	movi	r3,27
  465f94:	19804636 	bltu	r3,r6,4660b0 <_realloc_r+0x48c>
  465f98:	90800204 	addi	r2,r18,8
  465f9c:	80c00204 	addi	r3,r16,8
  465fa0:	003fb906 	br	465e88 <_realloc_r+0x264>
  465fa4:	9005883a 	mov	r2,r18
  465fa8:	8007883a 	mov	r3,r16
  465fac:	19000017 	ldw	r4,0(r3)
  465fb0:	9021883a 	mov	r16,r18
  465fb4:	b82d883a 	mov	r22,r23
  465fb8:	11000015 	stw	r4,0(r2)
  465fbc:	19000117 	ldw	r4,4(r3)
  465fc0:	11000115 	stw	r4,4(r2)
  465fc4:	18c00217 	ldw	r3,8(r3)
  465fc8:	10c00215 	stw	r3,8(r2)
  465fcc:	b8800117 	ldw	r2,4(r23)
  465fd0:	003f6606 	br	465d6c <_realloc_r+0x148>
  465fd4:	2445c83a 	sub	r2,r4,r17
  465fd8:	b46d883a 	add	r22,r22,r17
  465fdc:	10800054 	ori	r2,r2,1
  465fe0:	b0800115 	stw	r2,4(r22)
  465fe4:	80bfff17 	ldw	r2,-4(r16)
  465fe8:	a809883a 	mov	r4,r21
  465fec:	e5800215 	stw	r22,8(fp)
  465ff0:	1080004c 	andi	r2,r2,1
  465ff4:	88a2b03a 	or	r17,r17,r2
  465ff8:	847fff15 	stw	r17,-4(r16)
  465ffc:	046860c0 	call	46860c <__malloc_unlock>
  466000:	8025883a 	mov	r18,r16
  466004:	003f6606 	br	465da0 <_realloc_r+0x17c>
  466008:	9009883a 	mov	r4,r18
  46600c:	800b883a 	mov	r5,r16
  466010:	0465a980 	call	465a98 <memmove>
  466014:	003fa206 	br	465ea0 <_realloc_r+0x27c>
  466018:	88800404 	addi	r2,r17,16
  46601c:	a0bf8716 	blt	r20,r2,465e3c <_realloc_r+0x218>
  466020:	b8800317 	ldw	r2,12(r23)
  466024:	b8c00217 	ldw	r3,8(r23)
  466028:	99bfff04 	addi	r6,r19,-4
  46602c:	01000904 	movi	r4,36
  466030:	18800315 	stw	r2,12(r3)
  466034:	10c00215 	stw	r3,8(r2)
  466038:	bc800204 	addi	r18,r23,8
  46603c:	21806536 	bltu	r4,r6,4661d4 <_realloc_r+0x5b0>
  466040:	008004c4 	movi	r2,19
  466044:	1180592e 	bgeu	r2,r6,4661ac <_realloc_r+0x588>
  466048:	80800017 	ldw	r2,0(r16)
  46604c:	b8800215 	stw	r2,8(r23)
  466050:	80800117 	ldw	r2,4(r16)
  466054:	b8800315 	stw	r2,12(r23)
  466058:	008006c4 	movi	r2,27
  46605c:	11806136 	bltu	r2,r6,4661e4 <_realloc_r+0x5c0>
  466060:	b8800404 	addi	r2,r23,16
  466064:	80c00204 	addi	r3,r16,8
  466068:	19000017 	ldw	r4,0(r3)
  46606c:	11000015 	stw	r4,0(r2)
  466070:	19000117 	ldw	r4,4(r3)
  466074:	11000115 	stw	r4,4(r2)
  466078:	18c00217 	ldw	r3,8(r3)
  46607c:	10c00215 	stw	r3,8(r2)
  466080:	a447c83a 	sub	r3,r20,r17
  466084:	bc45883a 	add	r2,r23,r17
  466088:	18c00054 	ori	r3,r3,1
  46608c:	10c00115 	stw	r3,4(r2)
  466090:	b8c00117 	ldw	r3,4(r23)
  466094:	e0800215 	stw	r2,8(fp)
  466098:	a809883a 	mov	r4,r21
  46609c:	1880004c 	andi	r2,r3,1
  4660a0:	88a2b03a 	or	r17,r17,r2
  4660a4:	bc400115 	stw	r17,4(r23)
  4660a8:	046860c0 	call	46860c <__malloc_unlock>
  4660ac:	003f3c06 	br	465da0 <_realloc_r+0x17c>
  4660b0:	80c00217 	ldw	r3,8(r16)
  4660b4:	90c00215 	stw	r3,8(r18)
  4660b8:	80c00317 	ldw	r3,12(r16)
  4660bc:	90c00315 	stw	r3,12(r18)
  4660c0:	30802426 	beq	r6,r2,466154 <_realloc_r+0x530>
  4660c4:	90800404 	addi	r2,r18,16
  4660c8:	80c00404 	addi	r3,r16,16
  4660cc:	003f6e06 	br	465e88 <_realloc_r+0x264>
  4660d0:	953fff17 	ldw	r20,-4(r18)
  4660d4:	00ffff04 	movi	r3,-4
  4660d8:	a0e8703a 	and	r20,r20,r3
  4660dc:	a4e9883a 	add	r20,r20,r19
  4660e0:	003f2206 	br	465d6c <_realloc_r+0x148>
  4660e4:	800b883a 	mov	r5,r16
  4660e8:	9009883a 	mov	r4,r18
  4660ec:	0465a980 	call	465a98 <memmove>
  4660f0:	9021883a 	mov	r16,r18
  4660f4:	b8800117 	ldw	r2,4(r23)
  4660f8:	b82d883a 	mov	r22,r23
  4660fc:	003f1b06 	br	465d6c <_realloc_r+0x148>
  466100:	9005883a 	mov	r2,r18
  466104:	8007883a 	mov	r3,r16
  466108:	003f9206 	br	465f54 <_realloc_r+0x330>
  46610c:	800b883a 	mov	r5,r16
  466110:	9009883a 	mov	r4,r18
  466114:	d9c00015 	stw	r7,0(sp)
  466118:	0465a980 	call	465a98 <memmove>
  46611c:	d9c00017 	ldw	r7,0(sp)
  466120:	9021883a 	mov	r16,r18
  466124:	b8800117 	ldw	r2,4(r23)
  466128:	3829883a 	mov	r20,r7
  46612c:	b82d883a 	mov	r22,r23
  466130:	003f0e06 	br	465d6c <_realloc_r+0x148>
  466134:	80800217 	ldw	r2,8(r16)
  466138:	b8800415 	stw	r2,16(r23)
  46613c:	80800317 	ldw	r2,12(r16)
  466140:	b8800515 	stw	r2,20(r23)
  466144:	31001226 	beq	r6,r4,466190 <_realloc_r+0x56c>
  466148:	b8800604 	addi	r2,r23,24
  46614c:	80c00404 	addi	r3,r16,16
  466150:	003f9606 	br	465fac <_realloc_r+0x388>
  466154:	81000417 	ldw	r4,16(r16)
  466158:	90800604 	addi	r2,r18,24
  46615c:	80c00604 	addi	r3,r16,24
  466160:	91000415 	stw	r4,16(r18)
  466164:	81000517 	ldw	r4,20(r16)
  466168:	91000515 	stw	r4,20(r18)
  46616c:	003f4606 	br	465e88 <_realloc_r+0x264>
  466170:	80800217 	ldw	r2,8(r16)
  466174:	b8800415 	stw	r2,16(r23)
  466178:	80800317 	ldw	r2,12(r16)
  46617c:	b8800515 	stw	r2,20(r23)
  466180:	31000d26 	beq	r6,r4,4661b8 <_realloc_r+0x594>
  466184:	b8800604 	addi	r2,r23,24
  466188:	80c00404 	addi	r3,r16,16
  46618c:	003f7106 	br	465f54 <_realloc_r+0x330>
  466190:	81000417 	ldw	r4,16(r16)
  466194:	b8800804 	addi	r2,r23,32
  466198:	80c00604 	addi	r3,r16,24
  46619c:	b9000615 	stw	r4,24(r23)
  4661a0:	81000517 	ldw	r4,20(r16)
  4661a4:	b9000715 	stw	r4,28(r23)
  4661a8:	003f8006 	br	465fac <_realloc_r+0x388>
  4661ac:	9005883a 	mov	r2,r18
  4661b0:	8007883a 	mov	r3,r16
  4661b4:	003fac06 	br	466068 <_realloc_r+0x444>
  4661b8:	81000417 	ldw	r4,16(r16)
  4661bc:	b8800804 	addi	r2,r23,32
  4661c0:	80c00604 	addi	r3,r16,24
  4661c4:	b9000615 	stw	r4,24(r23)
  4661c8:	81000517 	ldw	r4,20(r16)
  4661cc:	b9000715 	stw	r4,28(r23)
  4661d0:	003f6006 	br	465f54 <_realloc_r+0x330>
  4661d4:	9009883a 	mov	r4,r18
  4661d8:	800b883a 	mov	r5,r16
  4661dc:	0465a980 	call	465a98 <memmove>
  4661e0:	003fa706 	br	466080 <_realloc_r+0x45c>
  4661e4:	80800217 	ldw	r2,8(r16)
  4661e8:	b8800415 	stw	r2,16(r23)
  4661ec:	80800317 	ldw	r2,12(r16)
  4661f0:	b8800515 	stw	r2,20(r23)
  4661f4:	31000326 	beq	r6,r4,466204 <_realloc_r+0x5e0>
  4661f8:	b8800604 	addi	r2,r23,24
  4661fc:	80c00404 	addi	r3,r16,16
  466200:	003f9906 	br	466068 <_realloc_r+0x444>
  466204:	81000417 	ldw	r4,16(r16)
  466208:	b8800804 	addi	r2,r23,32
  46620c:	80c00604 	addi	r3,r16,24
  466210:	b9000615 	stw	r4,24(r23)
  466214:	81000517 	ldw	r4,20(r16)
  466218:	b9000715 	stw	r4,28(r23)
  46621c:	003f9206 	br	466068 <_realloc_r+0x444>

00466220 <_sbrk_r>:
  466220:	defffd04 	addi	sp,sp,-12
  466224:	dc400115 	stw	r17,4(sp)
  466228:	dc000015 	stw	r16,0(sp)
  46622c:	2023883a 	mov	r17,r4
  466230:	04001234 	movhi	r16,72
  466234:	84263404 	addi	r16,r16,-26416
  466238:	2809883a 	mov	r4,r5
  46623c:	dfc00215 	stw	ra,8(sp)
  466240:	80000015 	stw	zero,0(r16)
  466244:	04681400 	call	468140 <sbrk>
  466248:	00ffffc4 	movi	r3,-1
  46624c:	10c00526 	beq	r2,r3,466264 <_sbrk_r+0x44>
  466250:	dfc00217 	ldw	ra,8(sp)
  466254:	dc400117 	ldw	r17,4(sp)
  466258:	dc000017 	ldw	r16,0(sp)
  46625c:	dec00304 	addi	sp,sp,12
  466260:	f800283a 	ret
  466264:	80c00017 	ldw	r3,0(r16)
  466268:	183ff926 	beq	r3,zero,466250 <_sbrk_r+0x30>
  46626c:	88c00015 	stw	r3,0(r17)
  466270:	dfc00217 	ldw	ra,8(sp)
  466274:	dc400117 	ldw	r17,4(sp)
  466278:	dc000017 	ldw	r16,0(sp)
  46627c:	dec00304 	addi	sp,sp,12
  466280:	f800283a 	ret

00466284 <__swsetup_r>:
  466284:	008011f4 	movhi	r2,71
  466288:	109f3a04 	addi	r2,r2,31976
  46628c:	10800017 	ldw	r2,0(r2)
  466290:	defffd04 	addi	sp,sp,-12
  466294:	dc400115 	stw	r17,4(sp)
  466298:	dc000015 	stw	r16,0(sp)
  46629c:	dfc00215 	stw	ra,8(sp)
  4662a0:	2023883a 	mov	r17,r4
  4662a4:	2821883a 	mov	r16,r5
  4662a8:	10000226 	beq	r2,zero,4662b4 <__swsetup_r+0x30>
  4662ac:	10c00e17 	ldw	r3,56(r2)
  4662b0:	18003d26 	beq	r3,zero,4663a8 <__swsetup_r+0x124>
  4662b4:	8080030b 	ldhu	r2,12(r16)
  4662b8:	10c0020c 	andi	r3,r2,8
  4662bc:	18ffffcc 	andi	r3,r3,65535
  4662c0:	18e0001c 	xori	r3,r3,32768
  4662c4:	18e00004 	addi	r3,r3,-32768
  4662c8:	18001226 	beq	r3,zero,466314 <__swsetup_r+0x90>
  4662cc:	80c00417 	ldw	r3,16(r16)
  4662d0:	18001f26 	beq	r3,zero,466350 <__swsetup_r+0xcc>
  4662d4:	1100004c 	andi	r4,r2,1
  4662d8:	2000261e 	bne	r4,zero,466374 <__swsetup_r+0xf0>
  4662dc:	1080008c 	andi	r2,r2,2
  4662e0:	10bfffcc 	andi	r2,r2,65535
  4662e4:	10a0001c 	xori	r2,r2,32768
  4662e8:	10a00004 	addi	r2,r2,-32768
  4662ec:	1000311e 	bne	r2,zero,4663b4 <__swsetup_r+0x130>
  4662f0:	80800517 	ldw	r2,20(r16)
  4662f4:	80800215 	stw	r2,8(r16)
  4662f8:	18002326 	beq	r3,zero,466388 <__swsetup_r+0x104>
  4662fc:	0005883a 	mov	r2,zero
  466300:	dfc00217 	ldw	ra,8(sp)
  466304:	dc400117 	ldw	r17,4(sp)
  466308:	dc000017 	ldw	r16,0(sp)
  46630c:	dec00304 	addi	sp,sp,12
  466310:	f800283a 	ret
  466314:	10c0040c 	andi	r3,r2,16
  466318:	18ffffcc 	andi	r3,r3,65535
  46631c:	18e0001c 	xori	r3,r3,32768
  466320:	18e00004 	addi	r3,r3,-32768
  466324:	18001e26 	beq	r3,zero,4663a0 <__swsetup_r+0x11c>
  466328:	10c0010c 	andi	r3,r2,4
  46632c:	18ffffcc 	andi	r3,r3,65535
  466330:	18e0001c 	xori	r3,r3,32768
  466334:	18e00004 	addi	r3,r3,-32768
  466338:	1800211e 	bne	r3,zero,4663c0 <__swsetup_r+0x13c>
  46633c:	80c00417 	ldw	r3,16(r16)
  466340:	11400214 	ori	r5,r2,8
  466344:	8140030d 	sth	r5,12(r16)
  466348:	2805883a 	mov	r2,r5
  46634c:	183fe11e 	bne	r3,zero,4662d4 <__swsetup_r+0x50>
  466350:	1140a00c 	andi	r5,r2,640
  466354:	01008004 	movi	r4,512
  466358:	293fde26 	beq	r5,r4,4662d4 <__swsetup_r+0x50>
  46635c:	8809883a 	mov	r4,r17
  466360:	800b883a 	mov	r5,r16
  466364:	0466e680 	call	466e68 <__smakebuf_r>
  466368:	8080030b 	ldhu	r2,12(r16)
  46636c:	80c00417 	ldw	r3,16(r16)
  466370:	003fd806 	br	4662d4 <__swsetup_r+0x50>
  466374:	80800517 	ldw	r2,20(r16)
  466378:	80000215 	stw	zero,8(r16)
  46637c:	0085c83a 	sub	r2,zero,r2
  466380:	80800615 	stw	r2,24(r16)
  466384:	183fdd1e 	bne	r3,zero,4662fc <__swsetup_r+0x78>
  466388:	8080030b 	ldhu	r2,12(r16)
  46638c:	1080200c 	andi	r2,r2,128
  466390:	10bfffcc 	andi	r2,r2,65535
  466394:	10a0001c 	xori	r2,r2,32768
  466398:	10a00004 	addi	r2,r2,-32768
  46639c:	103fd826 	beq	r2,zero,466300 <__swsetup_r+0x7c>
  4663a0:	00bfffc4 	movi	r2,-1
  4663a4:	003fd606 	br	466300 <__swsetup_r+0x7c>
  4663a8:	1009883a 	mov	r4,r2
  4663ac:	04666b40 	call	4666b4 <__sinit>
  4663b0:	003fc006 	br	4662b4 <__swsetup_r+0x30>
  4663b4:	0005883a 	mov	r2,zero
  4663b8:	80800215 	stw	r2,8(r16)
  4663bc:	003fce06 	br	4662f8 <__swsetup_r+0x74>
  4663c0:	81400c17 	ldw	r5,48(r16)
  4663c4:	28000626 	beq	r5,zero,4663e0 <__swsetup_r+0x15c>
  4663c8:	80c01004 	addi	r3,r16,64
  4663cc:	28c00326 	beq	r5,r3,4663dc <__swsetup_r+0x158>
  4663d0:	8809883a 	mov	r4,r17
  4663d4:	0466a380 	call	466a38 <_free_r>
  4663d8:	8080030b 	ldhu	r2,12(r16)
  4663dc:	80000c15 	stw	zero,48(r16)
  4663e0:	80c00417 	ldw	r3,16(r16)
  4663e4:	013ff6c4 	movi	r4,-37
  4663e8:	2084703a 	and	r2,r4,r2
  4663ec:	80000115 	stw	zero,4(r16)
  4663f0:	80c00015 	stw	r3,0(r16)
  4663f4:	003fd206 	br	466340 <__swsetup_r+0xbc>

004663f8 <_fflush_r>:
  4663f8:	defffb04 	addi	sp,sp,-20
  4663fc:	dcc00315 	stw	r19,12(sp)
  466400:	dc400115 	stw	r17,4(sp)
  466404:	dfc00415 	stw	ra,16(sp)
  466408:	dc800215 	stw	r18,8(sp)
  46640c:	dc000015 	stw	r16,0(sp)
  466410:	2027883a 	mov	r19,r4
  466414:	2823883a 	mov	r17,r5
  466418:	20000226 	beq	r4,zero,466424 <_fflush_r+0x2c>
  46641c:	20800e17 	ldw	r2,56(r4)
  466420:	10005726 	beq	r2,zero,466580 <_fflush_r+0x188>
  466424:	8880030b 	ldhu	r2,12(r17)
  466428:	10c0020c 	andi	r3,r2,8
  46642c:	18ffffcc 	andi	r3,r3,65535
  466430:	18e0001c 	xori	r3,r3,32768
  466434:	18e00004 	addi	r3,r3,-32768
  466438:	1800311e 	bne	r3,zero,466500 <_fflush_r+0x108>
  46643c:	89000117 	ldw	r4,4(r17)
  466440:	10c20014 	ori	r3,r2,2048
  466444:	88c0030d 	sth	r3,12(r17)
  466448:	180b883a 	mov	r5,r3
  46644c:	0100520e 	bge	zero,r4,466598 <_fflush_r+0x1a0>
  466450:	88c00a17 	ldw	r3,40(r17)
  466454:	18002226 	beq	r3,zero,4664e0 <_fflush_r+0xe8>
  466458:	1084000c 	andi	r2,r2,4096
  46645c:	10bfffcc 	andi	r2,r2,65535
  466460:	10a0001c 	xori	r2,r2,32768
  466464:	10a00004 	addi	r2,r2,-32768
  466468:	10004e26 	beq	r2,zero,4665a4 <_fflush_r+0x1ac>
  46646c:	8c001417 	ldw	r16,80(r17)
  466470:	2940010c 	andi	r5,r5,4
  466474:	297fffcc 	andi	r5,r5,65535
  466478:	2960001c 	xori	r5,r5,32768
  46647c:	29600004 	addi	r5,r5,-32768
  466480:	28000626 	beq	r5,zero,46649c <_fflush_r+0xa4>
  466484:	89000117 	ldw	r4,4(r17)
  466488:	88800c17 	ldw	r2,48(r17)
  46648c:	8121c83a 	sub	r16,r16,r4
  466490:	10000226 	beq	r2,zero,46649c <_fflush_r+0xa4>
  466494:	88800f17 	ldw	r2,60(r17)
  466498:	80a1c83a 	sub	r16,r16,r2
  46649c:	89400717 	ldw	r5,28(r17)
  4664a0:	9809883a 	mov	r4,r19
  4664a4:	800d883a 	mov	r6,r16
  4664a8:	000f883a 	mov	r7,zero
  4664ac:	183ee83a 	callr	r3
  4664b0:	8080281e 	bne	r16,r2,466554 <_fflush_r+0x15c>
  4664b4:	8880030b 	ldhu	r2,12(r17)
  4664b8:	88c00417 	ldw	r3,16(r17)
  4664bc:	88000115 	stw	zero,4(r17)
  4664c0:	113dffcc 	andi	r4,r2,63487
  4664c4:	1084000c 	andi	r2,r2,4096
  4664c8:	10bfffcc 	andi	r2,r2,65535
  4664cc:	10a0001c 	xori	r2,r2,32768
  4664d0:	8900030d 	sth	r4,12(r17)
  4664d4:	88c00015 	stw	r3,0(r17)
  4664d8:	10a00004 	addi	r2,r2,-32768
  4664dc:	10002c1e 	bne	r2,zero,466590 <_fflush_r+0x198>
  4664e0:	0005883a 	mov	r2,zero
  4664e4:	dfc00417 	ldw	ra,16(sp)
  4664e8:	dcc00317 	ldw	r19,12(sp)
  4664ec:	dc800217 	ldw	r18,8(sp)
  4664f0:	dc400117 	ldw	r17,4(sp)
  4664f4:	dc000017 	ldw	r16,0(sp)
  4664f8:	dec00504 	addi	sp,sp,20
  4664fc:	f800283a 	ret
  466500:	8c800417 	ldw	r18,16(r17)
  466504:	903ff626 	beq	r18,zero,4664e0 <_fflush_r+0xe8>
  466508:	8c000017 	ldw	r16,0(r17)
  46650c:	108000cc 	andi	r2,r2,3
  466510:	8c800015 	stw	r18,0(r17)
  466514:	84a1c83a 	sub	r16,r16,r18
  466518:	10001b1e 	bne	r2,zero,466588 <_fflush_r+0x190>
  46651c:	88800517 	ldw	r2,20(r17)
  466520:	88800215 	stw	r2,8(r17)
  466524:	04000316 	blt	zero,r16,466534 <_fflush_r+0x13c>
  466528:	003fed06 	br	4664e0 <_fflush_r+0xe8>
  46652c:	90a5883a 	add	r18,r18,r2
  466530:	043feb0e 	bge	zero,r16,4664e0 <_fflush_r+0xe8>
  466534:	88800917 	ldw	r2,36(r17)
  466538:	89400717 	ldw	r5,28(r17)
  46653c:	800f883a 	mov	r7,r16
  466540:	900d883a 	mov	r6,r18
  466544:	9809883a 	mov	r4,r19
  466548:	103ee83a 	callr	r2
  46654c:	80a1c83a 	sub	r16,r16,r2
  466550:	00bff616 	blt	zero,r2,46652c <_fflush_r+0x134>
  466554:	88c0030b 	ldhu	r3,12(r17)
  466558:	00bfffc4 	movi	r2,-1
  46655c:	18c01014 	ori	r3,r3,64
  466560:	88c0030d 	sth	r3,12(r17)
  466564:	dfc00417 	ldw	ra,16(sp)
  466568:	dcc00317 	ldw	r19,12(sp)
  46656c:	dc800217 	ldw	r18,8(sp)
  466570:	dc400117 	ldw	r17,4(sp)
  466574:	dc000017 	ldw	r16,0(sp)
  466578:	dec00504 	addi	sp,sp,20
  46657c:	f800283a 	ret
  466580:	04666b40 	call	4666b4 <__sinit>
  466584:	003fa706 	br	466424 <_fflush_r+0x2c>
  466588:	0005883a 	mov	r2,zero
  46658c:	003fe406 	br	466520 <_fflush_r+0x128>
  466590:	8c001415 	stw	r16,80(r17)
  466594:	003fd206 	br	4664e0 <_fflush_r+0xe8>
  466598:	88c00f17 	ldw	r3,60(r17)
  46659c:	00ffac16 	blt	zero,r3,466450 <_fflush_r+0x58>
  4665a0:	003fcf06 	br	4664e0 <_fflush_r+0xe8>
  4665a4:	89400717 	ldw	r5,28(r17)
  4665a8:	9809883a 	mov	r4,r19
  4665ac:	000d883a 	mov	r6,zero
  4665b0:	01c00044 	movi	r7,1
  4665b4:	183ee83a 	callr	r3
  4665b8:	1021883a 	mov	r16,r2
  4665bc:	00bfffc4 	movi	r2,-1
  4665c0:	80800326 	beq	r16,r2,4665d0 <_fflush_r+0x1d8>
  4665c4:	8940030b 	ldhu	r5,12(r17)
  4665c8:	88c00a17 	ldw	r3,40(r17)
  4665cc:	003fa806 	br	466470 <_fflush_r+0x78>
  4665d0:	98c00017 	ldw	r3,0(r19)
  4665d4:	00800744 	movi	r2,29
  4665d8:	18bfde1e 	bne	r3,r2,466554 <_fflush_r+0x15c>
  4665dc:	003fc006 	br	4664e0 <_fflush_r+0xe8>

004665e0 <fflush>:
  4665e0:	200b883a 	mov	r5,r4
  4665e4:	20000426 	beq	r4,zero,4665f8 <fflush+0x18>
  4665e8:	008011f4 	movhi	r2,71
  4665ec:	109f3a04 	addi	r2,r2,31976
  4665f0:	11000017 	ldw	r4,0(r2)
  4665f4:	04663f81 	jmpi	4663f8 <_fflush_r>
  4665f8:	008011f4 	movhi	r2,71
  4665fc:	109f3904 	addi	r2,r2,31972
  466600:	11000017 	ldw	r4,0(r2)
  466604:	014011b4 	movhi	r5,70
  466608:	2958fe04 	addi	r5,r5,25592
  46660c:	0466db01 	jmpi	466db0 <_fwalk_reent>

00466610 <__fp_lock>:
  466610:	0005883a 	mov	r2,zero
  466614:	f800283a 	ret

00466618 <__fp_unlock>:
  466618:	0005883a 	mov	r2,zero
  46661c:	f800283a 	ret

00466620 <_cleanup_r>:
  466620:	014011b4 	movhi	r5,70
  466624:	295d0e04 	addi	r5,r5,29752
  466628:	0466d081 	jmpi	466d08 <_fwalk>

0046662c <__sfmoreglue>:
  46662c:	defffc04 	addi	sp,sp,-16
  466630:	dc800215 	stw	r18,8(sp)
  466634:	2825883a 	mov	r18,r5
  466638:	dc000015 	stw	r16,0(sp)
  46663c:	01401704 	movi	r5,92
  466640:	2021883a 	mov	r16,r4
  466644:	9009883a 	mov	r4,r18
  466648:	dfc00315 	stw	ra,12(sp)
  46664c:	dc400115 	stw	r17,4(sp)
  466650:	04675f00 	call	4675f0 <__mulsi3>
  466654:	8009883a 	mov	r4,r16
  466658:	11400304 	addi	r5,r2,12
  46665c:	1023883a 	mov	r17,r2
  466660:	04650dc0 	call	4650dc <_malloc_r>
  466664:	1021883a 	mov	r16,r2
  466668:	10000726 	beq	r2,zero,466688 <__sfmoreglue+0x5c>
  46666c:	11000304 	addi	r4,r2,12
  466670:	10000015 	stw	zero,0(r2)
  466674:	14800115 	stw	r18,4(r2)
  466678:	11000215 	stw	r4,8(r2)
  46667c:	000b883a 	mov	r5,zero
  466680:	880d883a 	mov	r6,r17
  466684:	04670100 	call	467010 <memset>
  466688:	8005883a 	mov	r2,r16
  46668c:	dfc00317 	ldw	ra,12(sp)
  466690:	dc800217 	ldw	r18,8(sp)
  466694:	dc400117 	ldw	r17,4(sp)
  466698:	dc000017 	ldw	r16,0(sp)
  46669c:	dec00404 	addi	sp,sp,16
  4666a0:	f800283a 	ret

004666a4 <_cleanup>:
  4666a4:	008011f4 	movhi	r2,71
  4666a8:	109f3904 	addi	r2,r2,31972
  4666ac:	11000017 	ldw	r4,0(r2)
  4666b0:	04666201 	jmpi	466620 <_cleanup_r>

004666b4 <__sinit>:
  4666b4:	20800e17 	ldw	r2,56(r4)
  4666b8:	1000401e 	bne	r2,zero,4667bc <__sinit+0x108>
  4666bc:	21400117 	ldw	r5,4(r4)
  4666c0:	018011b4 	movhi	r6,70
  4666c4:	31998804 	addi	r6,r6,26144
  4666c8:	20c00217 	ldw	r3,8(r4)
  4666cc:	21800f15 	stw	r6,60(r4)
  4666d0:	2080bb04 	addi	r2,r4,748
  4666d4:	02400044 	movi	r9,1
  4666d8:	018000c4 	movi	r6,3
  4666dc:	2180b915 	stw	r6,740(r4)
  4666e0:	2080ba15 	stw	r2,744(r4)
  4666e4:	22400e15 	stw	r9,56(r4)
  4666e8:	20800317 	ldw	r2,12(r4)
  4666ec:	2000b815 	stw	zero,736(r4)
  4666f0:	020011b4 	movhi	r8,70
  4666f4:	421c3b04 	addi	r8,r8,28908
  4666f8:	01c011b4 	movhi	r7,70
  4666fc:	39dc5004 	addi	r7,r7,28992
  466700:	018011b4 	movhi	r6,70
  466704:	319c7204 	addi	r6,r6,29128
  466708:	010011b4 	movhi	r4,70
  46670c:	211c8904 	addi	r4,r4,29220
  466710:	02800104 	movi	r10,4
  466714:	28000015 	stw	zero,0(r5)
  466718:	28000115 	stw	zero,4(r5)
  46671c:	28000215 	stw	zero,8(r5)
  466720:	2a80030d 	sth	r10,12(r5)
  466724:	2800038d 	sth	zero,14(r5)
  466728:	28000415 	stw	zero,16(r5)
  46672c:	28000515 	stw	zero,20(r5)
  466730:	28000615 	stw	zero,24(r5)
  466734:	29400715 	stw	r5,28(r5)
  466738:	2a000815 	stw	r8,32(r5)
  46673c:	29c00915 	stw	r7,36(r5)
  466740:	29800a15 	stw	r6,40(r5)
  466744:	29000b15 	stw	r4,44(r5)
  466748:	01400284 	movi	r5,10
  46674c:	18000015 	stw	zero,0(r3)
  466750:	18000115 	stw	zero,4(r3)
  466754:	18000215 	stw	zero,8(r3)
  466758:	1940030d 	sth	r5,12(r3)
  46675c:	1a40038d 	sth	r9,14(r3)
  466760:	18000415 	stw	zero,16(r3)
  466764:	18000515 	stw	zero,20(r3)
  466768:	18000615 	stw	zero,24(r3)
  46676c:	18c00715 	stw	r3,28(r3)
  466770:	1a000815 	stw	r8,32(r3)
  466774:	19c00915 	stw	r7,36(r3)
  466778:	19800a15 	stw	r6,40(r3)
  46677c:	19000b15 	stw	r4,44(r3)
  466780:	00c00484 	movi	r3,18
  466784:	10c0030d 	sth	r3,12(r2)
  466788:	00c00084 	movi	r3,2
  46678c:	10000015 	stw	zero,0(r2)
  466790:	10000115 	stw	zero,4(r2)
  466794:	10000215 	stw	zero,8(r2)
  466798:	10c0038d 	sth	r3,14(r2)
  46679c:	10000415 	stw	zero,16(r2)
  4667a0:	10000515 	stw	zero,20(r2)
  4667a4:	10000615 	stw	zero,24(r2)
  4667a8:	10800715 	stw	r2,28(r2)
  4667ac:	12000815 	stw	r8,32(r2)
  4667b0:	11c00915 	stw	r7,36(r2)
  4667b4:	11800a15 	stw	r6,40(r2)
  4667b8:	11000b15 	stw	r4,44(r2)
  4667bc:	f800283a 	ret

004667c0 <__sfp>:
  4667c0:	defffc04 	addi	sp,sp,-16
  4667c4:	008011f4 	movhi	r2,71
  4667c8:	109f3904 	addi	r2,r2,31972
  4667cc:	dc400115 	stw	r17,4(sp)
  4667d0:	14400017 	ldw	r17,0(r2)
  4667d4:	dc800215 	stw	r18,8(sp)
  4667d8:	dfc00315 	stw	ra,12(sp)
  4667dc:	88800e17 	ldw	r2,56(r17)
  4667e0:	dc000015 	stw	r16,0(sp)
  4667e4:	2025883a 	mov	r18,r4
  4667e8:	10002826 	beq	r2,zero,46688c <__sfp+0xcc>
  4667ec:	8c40b804 	addi	r17,r17,736
  4667f0:	043fffc4 	movi	r16,-1
  4667f4:	89400117 	ldw	r5,4(r17)
  4667f8:	88800217 	ldw	r2,8(r17)
  4667fc:	297fffc4 	addi	r5,r5,-1
  466800:	28000a16 	blt	r5,zero,46682c <__sfp+0x6c>
  466804:	10c0030f 	ldh	r3,12(r2)
  466808:	18000c26 	beq	r3,zero,46683c <__sfp+0x7c>
  46680c:	10c01a04 	addi	r3,r2,104
  466810:	00000206 	br	46681c <__sfp+0x5c>
  466814:	19bfe90f 	ldh	r6,-92(r3)
  466818:	30000826 	beq	r6,zero,46683c <__sfp+0x7c>
  46681c:	297fffc4 	addi	r5,r5,-1
  466820:	18bffd04 	addi	r2,r3,-12
  466824:	18c01704 	addi	r3,r3,92
  466828:	2c3ffa1e 	bne	r5,r16,466814 <__sfp+0x54>
  46682c:	88800017 	ldw	r2,0(r17)
  466830:	10001926 	beq	r2,zero,466898 <__sfp+0xd8>
  466834:	1023883a 	mov	r17,r2
  466838:	003fee06 	br	4667f4 <__sfp+0x34>
  46683c:	00ffffc4 	movi	r3,-1
  466840:	10c0038d 	sth	r3,14(r2)
  466844:	00c00044 	movi	r3,1
  466848:	10c0030d 	sth	r3,12(r2)
  46684c:	10000015 	stw	zero,0(r2)
  466850:	10000215 	stw	zero,8(r2)
  466854:	10000115 	stw	zero,4(r2)
  466858:	10000415 	stw	zero,16(r2)
  46685c:	10000515 	stw	zero,20(r2)
  466860:	10000615 	stw	zero,24(r2)
  466864:	10000c15 	stw	zero,48(r2)
  466868:	10000d15 	stw	zero,52(r2)
  46686c:	10001115 	stw	zero,68(r2)
  466870:	10001215 	stw	zero,72(r2)
  466874:	dfc00317 	ldw	ra,12(sp)
  466878:	dc800217 	ldw	r18,8(sp)
  46687c:	dc400117 	ldw	r17,4(sp)
  466880:	dc000017 	ldw	r16,0(sp)
  466884:	dec00404 	addi	sp,sp,16
  466888:	f800283a 	ret
  46688c:	8809883a 	mov	r4,r17
  466890:	04666b40 	call	4666b4 <__sinit>
  466894:	003fd506 	br	4667ec <__sfp+0x2c>
  466898:	9009883a 	mov	r4,r18
  46689c:	01400104 	movi	r5,4
  4668a0:	046662c0 	call	46662c <__sfmoreglue>
  4668a4:	88800015 	stw	r2,0(r17)
  4668a8:	103fe21e 	bne	r2,zero,466834 <__sfp+0x74>
  4668ac:	00800304 	movi	r2,12
  4668b0:	90800015 	stw	r2,0(r18)
  4668b4:	0005883a 	mov	r2,zero
  4668b8:	003fee06 	br	466874 <__sfp+0xb4>

004668bc <__sfp_lock_acquire>:
  4668bc:	f800283a 	ret

004668c0 <__sfp_lock_release>:
  4668c0:	f800283a 	ret

004668c4 <__sinit_lock_acquire>:
  4668c4:	f800283a 	ret

004668c8 <__sinit_lock_release>:
  4668c8:	f800283a 	ret

004668cc <__fp_lock_all>:
  4668cc:	008011f4 	movhi	r2,71
  4668d0:	109f3a04 	addi	r2,r2,31976
  4668d4:	11000017 	ldw	r4,0(r2)
  4668d8:	014011b4 	movhi	r5,70
  4668dc:	29598404 	addi	r5,r5,26128
  4668e0:	0466d081 	jmpi	466d08 <_fwalk>

004668e4 <__fp_unlock_all>:
  4668e4:	008011f4 	movhi	r2,71
  4668e8:	109f3a04 	addi	r2,r2,31976
  4668ec:	11000017 	ldw	r4,0(r2)
  4668f0:	014011b4 	movhi	r5,70
  4668f4:	29598604 	addi	r5,r5,26136
  4668f8:	0466d081 	jmpi	466d08 <_fwalk>

004668fc <_malloc_trim_r>:
  4668fc:	defffb04 	addi	sp,sp,-20
  466900:	dcc00315 	stw	r19,12(sp)
  466904:	dc800215 	stw	r18,8(sp)
  466908:	dc400115 	stw	r17,4(sp)
  46690c:	dc000015 	stw	r16,0(sp)
  466910:	2827883a 	mov	r19,r5
  466914:	dfc00415 	stw	ra,16(sp)
  466918:	044011f4 	movhi	r17,71
  46691c:	8c59a704 	addi	r17,r17,26268
  466920:	2021883a 	mov	r16,r4
  466924:	04684a00 	call	4684a0 <__malloc_lock>
  466928:	88800217 	ldw	r2,8(r17)
  46692c:	14800117 	ldw	r18,4(r2)
  466930:	00bfff04 	movi	r2,-4
  466934:	90a4703a 	and	r18,r18,r2
  466938:	9083fbc4 	addi	r2,r18,4079
  46693c:	14e7c83a 	sub	r19,r2,r19
  466940:	9826d33a 	srli	r19,r19,12
  466944:	0083ffc4 	movi	r2,4095
  466948:	9cffffc4 	addi	r19,r19,-1
  46694c:	9826933a 	slli	r19,r19,12
  466950:	14c0060e 	bge	r2,r19,46696c <_malloc_trim_r+0x70>
  466954:	8009883a 	mov	r4,r16
  466958:	000b883a 	mov	r5,zero
  46695c:	04662200 	call	466220 <_sbrk_r>
  466960:	88c00217 	ldw	r3,8(r17)
  466964:	1c87883a 	add	r3,r3,r18
  466968:	10c00a26 	beq	r2,r3,466994 <_malloc_trim_r+0x98>
  46696c:	8009883a 	mov	r4,r16
  466970:	046860c0 	call	46860c <__malloc_unlock>
  466974:	0005883a 	mov	r2,zero
  466978:	dfc00417 	ldw	ra,16(sp)
  46697c:	dcc00317 	ldw	r19,12(sp)
  466980:	dc800217 	ldw	r18,8(sp)
  466984:	dc400117 	ldw	r17,4(sp)
  466988:	dc000017 	ldw	r16,0(sp)
  46698c:	dec00504 	addi	sp,sp,20
  466990:	f800283a 	ret
  466994:	8009883a 	mov	r4,r16
  466998:	04cbc83a 	sub	r5,zero,r19
  46699c:	04662200 	call	466220 <_sbrk_r>
  4669a0:	00ffffc4 	movi	r3,-1
  4669a4:	10c01326 	beq	r2,r3,4669f4 <_malloc_trim_r+0xf8>
  4669a8:	00801234 	movhi	r2,72
  4669ac:	10a65604 	addi	r2,r2,-26280
  4669b0:	11000017 	ldw	r4,0(r2)
  4669b4:	88c00217 	ldw	r3,8(r17)
  4669b8:	94e5c83a 	sub	r18,r18,r19
  4669bc:	94800054 	ori	r18,r18,1
  4669c0:	24e7c83a 	sub	r19,r4,r19
  4669c4:	1c800115 	stw	r18,4(r3)
  4669c8:	8009883a 	mov	r4,r16
  4669cc:	14c00015 	stw	r19,0(r2)
  4669d0:	046860c0 	call	46860c <__malloc_unlock>
  4669d4:	00800044 	movi	r2,1
  4669d8:	dfc00417 	ldw	ra,16(sp)
  4669dc:	dcc00317 	ldw	r19,12(sp)
  4669e0:	dc800217 	ldw	r18,8(sp)
  4669e4:	dc400117 	ldw	r17,4(sp)
  4669e8:	dc000017 	ldw	r16,0(sp)
  4669ec:	dec00504 	addi	sp,sp,20
  4669f0:	f800283a 	ret
  4669f4:	8009883a 	mov	r4,r16
  4669f8:	000b883a 	mov	r5,zero
  4669fc:	04662200 	call	466220 <_sbrk_r>
  466a00:	88c00217 	ldw	r3,8(r17)
  466a04:	014003c4 	movi	r5,15
  466a08:	10c9c83a 	sub	r4,r2,r3
  466a0c:	293fd70e 	bge	r5,r4,46696c <_malloc_trim_r+0x70>
  466a10:	014011f4 	movhi	r5,71
  466a14:	295f3b04 	addi	r5,r5,31980
  466a18:	29400017 	ldw	r5,0(r5)
  466a1c:	21000054 	ori	r4,r4,1
  466a20:	19000115 	stw	r4,4(r3)
  466a24:	1145c83a 	sub	r2,r2,r5
  466a28:	01401234 	movhi	r5,72
  466a2c:	29665604 	addi	r5,r5,-26280
  466a30:	28800015 	stw	r2,0(r5)
  466a34:	003fcd06 	br	46696c <_malloc_trim_r+0x70>

00466a38 <_free_r>:
  466a38:	defffd04 	addi	sp,sp,-12
  466a3c:	dc400115 	stw	r17,4(sp)
  466a40:	dc000015 	stw	r16,0(sp)
  466a44:	dfc00215 	stw	ra,8(sp)
  466a48:	2821883a 	mov	r16,r5
  466a4c:	2023883a 	mov	r17,r4
  466a50:	28004b26 	beq	r5,zero,466b80 <_free_r+0x148>
  466a54:	04684a00 	call	4684a0 <__malloc_lock>
  466a58:	823fff17 	ldw	r8,-4(r16)
  466a5c:	00bfff84 	movi	r2,-2
  466a60:	81bffe04 	addi	r6,r16,-8
  466a64:	4084703a 	and	r2,r8,r2
  466a68:	3087883a 	add	r3,r6,r2
  466a6c:	014011f4 	movhi	r5,71
  466a70:	2959a704 	addi	r5,r5,26268
  466a74:	1a400117 	ldw	r9,4(r3)
  466a78:	29000217 	ldw	r4,8(r5)
  466a7c:	01ffff04 	movi	r7,-4
  466a80:	49ce703a 	and	r7,r9,r7
  466a84:	20c06526 	beq	r4,r3,466c1c <_free_r+0x1e4>
  466a88:	19c00115 	stw	r7,4(r3)
  466a8c:	4200004c 	andi	r8,r8,1
  466a90:	40003026 	beq	r8,zero,466b54 <_free_r+0x11c>
  466a94:	0009883a 	mov	r4,zero
  466a98:	19d1883a 	add	r8,r3,r7
  466a9c:	42000117 	ldw	r8,4(r8)
  466aa0:	4200004c 	andi	r8,r8,1
  466aa4:	4000061e 	bne	r8,zero,466ac0 <_free_r+0x88>
  466aa8:	11c5883a 	add	r2,r2,r7
  466aac:	19c00217 	ldw	r7,8(r3)
  466ab0:	20004e26 	beq	r4,zero,466bec <_free_r+0x1b4>
  466ab4:	18c00317 	ldw	r3,12(r3)
  466ab8:	38c00315 	stw	r3,12(r7)
  466abc:	19c00215 	stw	r7,8(r3)
  466ac0:	11c00054 	ori	r7,r2,1
  466ac4:	3087883a 	add	r3,r6,r2
  466ac8:	31c00115 	stw	r7,4(r6)
  466acc:	18800015 	stw	r2,0(r3)
  466ad0:	20001a1e 	bne	r4,zero,466b3c <_free_r+0x104>
  466ad4:	00c07fc4 	movi	r3,511
  466ad8:	18802e2e 	bgeu	r3,r2,466b94 <_free_r+0x15c>
  466adc:	1006d27a 	srli	r3,r2,9
  466ae0:	01000104 	movi	r4,4
  466ae4:	20c06636 	bltu	r4,r3,466c80 <_free_r+0x248>
  466ae8:	1008d1ba 	srli	r4,r2,6
  466aec:	21000e04 	addi	r4,r4,56
  466af0:	210f883a 	add	r7,r4,r4
  466af4:	39cf883a 	add	r7,r7,r7
  466af8:	39cf883a 	add	r7,r7,r7
  466afc:	29cf883a 	add	r7,r5,r7
  466b00:	38c00217 	ldw	r3,8(r7)
  466b04:	014011f4 	movhi	r5,71
  466b08:	2959a704 	addi	r5,r5,26268
  466b0c:	19c06126 	beq	r3,r7,466c94 <_free_r+0x25c>
  466b10:	013fff04 	movi	r4,-4
  466b14:	19400117 	ldw	r5,4(r3)
  466b18:	290a703a 	and	r5,r5,r4
  466b1c:	1140022e 	bgeu	r2,r5,466b28 <_free_r+0xf0>
  466b20:	18c00217 	ldw	r3,8(r3)
  466b24:	38fffb1e 	bne	r7,r3,466b14 <_free_r+0xdc>
  466b28:	18800317 	ldw	r2,12(r3)
  466b2c:	30800315 	stw	r2,12(r6)
  466b30:	30c00215 	stw	r3,8(r6)
  466b34:	11800215 	stw	r6,8(r2)
  466b38:	19800315 	stw	r6,12(r3)
  466b3c:	8809883a 	mov	r4,r17
  466b40:	dfc00217 	ldw	ra,8(sp)
  466b44:	dc400117 	ldw	r17,4(sp)
  466b48:	dc000017 	ldw	r16,0(sp)
  466b4c:	dec00304 	addi	sp,sp,12
  466b50:	046860c1 	jmpi	46860c <__malloc_unlock>
  466b54:	813ffe17 	ldw	r4,-8(r16)
  466b58:	2a400204 	addi	r9,r5,8
  466b5c:	310dc83a 	sub	r6,r6,r4
  466b60:	32000217 	ldw	r8,8(r6)
  466b64:	1105883a 	add	r2,r2,r4
  466b68:	42404326 	beq	r8,r9,466c78 <_free_r+0x240>
  466b6c:	32400317 	ldw	r9,12(r6)
  466b70:	0009883a 	mov	r4,zero
  466b74:	42400315 	stw	r9,12(r8)
  466b78:	4a000215 	stw	r8,8(r9)
  466b7c:	003fc606 	br	466a98 <_free_r+0x60>
  466b80:	dfc00217 	ldw	ra,8(sp)
  466b84:	dc400117 	ldw	r17,4(sp)
  466b88:	dc000017 	ldw	r16,0(sp)
  466b8c:	dec00304 	addi	sp,sp,12
  466b90:	f800283a 	ret
  466b94:	1004d0fa 	srli	r2,r2,3
  466b98:	02000044 	movi	r8,1
  466b9c:	29c00117 	ldw	r7,4(r5)
  466ba0:	1087883a 	add	r3,r2,r2
  466ba4:	18c7883a 	add	r3,r3,r3
  466ba8:	1005d0ba 	srai	r2,r2,2
  466bac:	18c7883a 	add	r3,r3,r3
  466bb0:	28c7883a 	add	r3,r5,r3
  466bb4:	19000217 	ldw	r4,8(r3)
  466bb8:	4084983a 	sll	r2,r8,r2
  466bbc:	30c00315 	stw	r3,12(r6)
  466bc0:	31000215 	stw	r4,8(r6)
  466bc4:	11c4b03a 	or	r2,r2,r7
  466bc8:	21800315 	stw	r6,12(r4)
  466bcc:	8809883a 	mov	r4,r17
  466bd0:	28800115 	stw	r2,4(r5)
  466bd4:	19800215 	stw	r6,8(r3)
  466bd8:	dfc00217 	ldw	ra,8(sp)
  466bdc:	dc400117 	ldw	r17,4(sp)
  466be0:	dc000017 	ldw	r16,0(sp)
  466be4:	dec00304 	addi	sp,sp,12
  466be8:	046860c1 	jmpi	46860c <__malloc_unlock>
  466bec:	020011f4 	movhi	r8,71
  466bf0:	4219a904 	addi	r8,r8,26276
  466bf4:	3a3faf1e 	bne	r7,r8,466ab4 <_free_r+0x7c>
  466bf8:	29800515 	stw	r6,20(r5)
  466bfc:	29800415 	stw	r6,16(r5)
  466c00:	11000054 	ori	r4,r2,1
  466c04:	3087883a 	add	r3,r6,r2
  466c08:	31c00315 	stw	r7,12(r6)
  466c0c:	31c00215 	stw	r7,8(r6)
  466c10:	31000115 	stw	r4,4(r6)
  466c14:	18800015 	stw	r2,0(r3)
  466c18:	003fc806 	br	466b3c <_free_r+0x104>
  466c1c:	4200004c 	andi	r8,r8,1
  466c20:	3885883a 	add	r2,r7,r2
  466c24:	4000071e 	bne	r8,zero,466c44 <_free_r+0x20c>
  466c28:	81fffe17 	ldw	r7,-8(r16)
  466c2c:	31cdc83a 	sub	r6,r6,r7
  466c30:	30c00317 	ldw	r3,12(r6)
  466c34:	31000217 	ldw	r4,8(r6)
  466c38:	11c5883a 	add	r2,r2,r7
  466c3c:	20c00315 	stw	r3,12(r4)
  466c40:	19000215 	stw	r4,8(r3)
  466c44:	00c011f4 	movhi	r3,71
  466c48:	18df3c04 	addi	r3,r3,31984
  466c4c:	18c00017 	ldw	r3,0(r3)
  466c50:	11000054 	ori	r4,r2,1
  466c54:	31000115 	stw	r4,4(r6)
  466c58:	29800215 	stw	r6,8(r5)
  466c5c:	10ffb736 	bltu	r2,r3,466b3c <_free_r+0x104>
  466c60:	00801234 	movhi	r2,72
  466c64:	10a63304 	addi	r2,r2,-26420
  466c68:	11400017 	ldw	r5,0(r2)
  466c6c:	8809883a 	mov	r4,r17
  466c70:	04668fc0 	call	4668fc <_malloc_trim_r>
  466c74:	003fb106 	br	466b3c <_free_r+0x104>
  466c78:	01000044 	movi	r4,1
  466c7c:	003f8606 	br	466a98 <_free_r+0x60>
  466c80:	01000504 	movi	r4,20
  466c84:	20c00b36 	bltu	r4,r3,466cb4 <_free_r+0x27c>
  466c88:	190016c4 	addi	r4,r3,91
  466c8c:	210f883a 	add	r7,r4,r4
  466c90:	003f9806 	br	466af4 <_free_r+0xbc>
  466c94:	2009d0ba 	srai	r4,r4,2
  466c98:	00800044 	movi	r2,1
  466c9c:	29c00117 	ldw	r7,4(r5)
  466ca0:	1108983a 	sll	r4,r2,r4
  466ca4:	1805883a 	mov	r2,r3
  466ca8:	21c8b03a 	or	r4,r4,r7
  466cac:	29000115 	stw	r4,4(r5)
  466cb0:	003f9e06 	br	466b2c <_free_r+0xf4>
  466cb4:	01001504 	movi	r4,84
  466cb8:	20c00436 	bltu	r4,r3,466ccc <_free_r+0x294>
  466cbc:	1008d33a 	srli	r4,r2,12
  466cc0:	21001b84 	addi	r4,r4,110
  466cc4:	210f883a 	add	r7,r4,r4
  466cc8:	003f8a06 	br	466af4 <_free_r+0xbc>
  466ccc:	01005504 	movi	r4,340
  466cd0:	20c00436 	bltu	r4,r3,466ce4 <_free_r+0x2ac>
  466cd4:	1008d3fa 	srli	r4,r2,15
  466cd8:	21001dc4 	addi	r4,r4,119
  466cdc:	210f883a 	add	r7,r4,r4
  466ce0:	003f8406 	br	466af4 <_free_r+0xbc>
  466ce4:	01015504 	movi	r4,1364
  466ce8:	20c00436 	bltu	r4,r3,466cfc <_free_r+0x2c4>
  466cec:	1008d4ba 	srli	r4,r2,18
  466cf0:	21001f04 	addi	r4,r4,124
  466cf4:	210f883a 	add	r7,r4,r4
  466cf8:	003f7e06 	br	466af4 <_free_r+0xbc>
  466cfc:	01c03f04 	movi	r7,252
  466d00:	01001f84 	movi	r4,126
  466d04:	003f7b06 	br	466af4 <_free_r+0xbc>

00466d08 <_fwalk>:
  466d08:	defff904 	addi	sp,sp,-28
  466d0c:	dcc00315 	stw	r19,12(sp)
  466d10:	24c0b804 	addi	r19,r4,736
  466d14:	dd400515 	stw	r21,20(sp)
  466d18:	dd000415 	stw	r20,16(sp)
  466d1c:	dfc00615 	stw	ra,24(sp)
  466d20:	dc800215 	stw	r18,8(sp)
  466d24:	dc400115 	stw	r17,4(sp)
  466d28:	dc000015 	stw	r16,0(sp)
  466d2c:	282b883a 	mov	r21,r5
  466d30:	0029883a 	mov	r20,zero
  466d34:	04668bc0 	call	4668bc <__sfp_lock_acquire>
  466d38:	98001226 	beq	r19,zero,466d84 <_fwalk+0x7c>
  466d3c:	04bfffc4 	movi	r18,-1
  466d40:	9c400117 	ldw	r17,4(r19)
  466d44:	9c000217 	ldw	r16,8(r19)
  466d48:	8c7fffc4 	addi	r17,r17,-1
  466d4c:	88000b16 	blt	r17,zero,466d7c <_fwalk+0x74>
  466d50:	84000304 	addi	r16,r16,12
  466d54:	80c0000f 	ldh	r3,0(r16)
  466d58:	8c7fffc4 	addi	r17,r17,-1
  466d5c:	813ffd04 	addi	r4,r16,-12
  466d60:	18000426 	beq	r3,zero,466d74 <_fwalk+0x6c>
  466d64:	80c0008f 	ldh	r3,2(r16)
  466d68:	1c800226 	beq	r3,r18,466d74 <_fwalk+0x6c>
  466d6c:	a83ee83a 	callr	r21
  466d70:	a0a8b03a 	or	r20,r20,r2
  466d74:	84001704 	addi	r16,r16,92
  466d78:	8cbff61e 	bne	r17,r18,466d54 <_fwalk+0x4c>
  466d7c:	9cc00017 	ldw	r19,0(r19)
  466d80:	983fef1e 	bne	r19,zero,466d40 <_fwalk+0x38>
  466d84:	04668c00 	call	4668c0 <__sfp_lock_release>
  466d88:	a005883a 	mov	r2,r20
  466d8c:	dfc00617 	ldw	ra,24(sp)
  466d90:	dd400517 	ldw	r21,20(sp)
  466d94:	dd000417 	ldw	r20,16(sp)
  466d98:	dcc00317 	ldw	r19,12(sp)
  466d9c:	dc800217 	ldw	r18,8(sp)
  466da0:	dc400117 	ldw	r17,4(sp)
  466da4:	dc000017 	ldw	r16,0(sp)
  466da8:	dec00704 	addi	sp,sp,28
  466dac:	f800283a 	ret

00466db0 <_fwalk_reent>:
  466db0:	defff804 	addi	sp,sp,-32
  466db4:	dcc00315 	stw	r19,12(sp)
  466db8:	24c0b804 	addi	r19,r4,736
  466dbc:	dd800615 	stw	r22,24(sp)
  466dc0:	dd400515 	stw	r21,20(sp)
  466dc4:	dd000415 	stw	r20,16(sp)
  466dc8:	dfc00715 	stw	ra,28(sp)
  466dcc:	dc800215 	stw	r18,8(sp)
  466dd0:	dc400115 	stw	r17,4(sp)
  466dd4:	dc000015 	stw	r16,0(sp)
  466dd8:	2029883a 	mov	r20,r4
  466ddc:	282b883a 	mov	r21,r5
  466de0:	002d883a 	mov	r22,zero
  466de4:	04668bc0 	call	4668bc <__sfp_lock_acquire>
  466de8:	98001326 	beq	r19,zero,466e38 <_fwalk_reent+0x88>
  466dec:	04bfffc4 	movi	r18,-1
  466df0:	9c400117 	ldw	r17,4(r19)
  466df4:	9c000217 	ldw	r16,8(r19)
  466df8:	8c7fffc4 	addi	r17,r17,-1
  466dfc:	88000c16 	blt	r17,zero,466e30 <_fwalk_reent+0x80>
  466e00:	84000304 	addi	r16,r16,12
  466e04:	80c0000f 	ldh	r3,0(r16)
  466e08:	8c7fffc4 	addi	r17,r17,-1
  466e0c:	817ffd04 	addi	r5,r16,-12
  466e10:	18000526 	beq	r3,zero,466e28 <_fwalk_reent+0x78>
  466e14:	80c0008f 	ldh	r3,2(r16)
  466e18:	a009883a 	mov	r4,r20
  466e1c:	1c800226 	beq	r3,r18,466e28 <_fwalk_reent+0x78>
  466e20:	a83ee83a 	callr	r21
  466e24:	b0acb03a 	or	r22,r22,r2
  466e28:	84001704 	addi	r16,r16,92
  466e2c:	8cbff51e 	bne	r17,r18,466e04 <_fwalk_reent+0x54>
  466e30:	9cc00017 	ldw	r19,0(r19)
  466e34:	983fee1e 	bne	r19,zero,466df0 <_fwalk_reent+0x40>
  466e38:	04668c00 	call	4668c0 <__sfp_lock_release>
  466e3c:	b005883a 	mov	r2,r22
  466e40:	dfc00717 	ldw	ra,28(sp)
  466e44:	dd800617 	ldw	r22,24(sp)
  466e48:	dd400517 	ldw	r21,20(sp)
  466e4c:	dd000417 	ldw	r20,16(sp)
  466e50:	dcc00317 	ldw	r19,12(sp)
  466e54:	dc800217 	ldw	r18,8(sp)
  466e58:	dc400117 	ldw	r17,4(sp)
  466e5c:	dc000017 	ldw	r16,0(sp)
  466e60:	dec00804 	addi	sp,sp,32
  466e64:	f800283a 	ret

00466e68 <__smakebuf_r>:
  466e68:	2880030b 	ldhu	r2,12(r5)
  466e6c:	deffed04 	addi	sp,sp,-76
  466e70:	dc401015 	stw	r17,64(sp)
  466e74:	10c0008c 	andi	r3,r2,2
  466e78:	18ffffcc 	andi	r3,r3,65535
  466e7c:	18e0001c 	xori	r3,r3,32768
  466e80:	dc000f15 	stw	r16,60(sp)
  466e84:	dfc01215 	stw	ra,72(sp)
  466e88:	dc801115 	stw	r18,68(sp)
  466e8c:	18e00004 	addi	r3,r3,-32768
  466e90:	2821883a 	mov	r16,r5
  466e94:	2023883a 	mov	r17,r4
  466e98:	1800381e 	bne	r3,zero,466f7c <__smakebuf_r+0x114>
  466e9c:	2940038f 	ldh	r5,14(r5)
  466ea0:	28002d16 	blt	r5,zero,466f58 <__smakebuf_r+0xf0>
  466ea4:	d80d883a 	mov	r6,sp
  466ea8:	046744c0 	call	46744c <_fstat_r>
  466eac:	10002916 	blt	r2,zero,466f54 <__smakebuf_r+0xec>
  466eb0:	d8800117 	ldw	r2,4(sp)
  466eb4:	00e00014 	movui	r3,32768
  466eb8:	10bc000c 	andi	r2,r2,61440
  466ebc:	10c03c26 	beq	r2,r3,466fb0 <__smakebuf_r+0x148>
  466ec0:	80c0030b 	ldhu	r3,12(r16)
  466ec4:	18c20014 	ori	r3,r3,2048
  466ec8:	80c0030d 	sth	r3,12(r16)
  466ecc:	00c80004 	movi	r3,8192
  466ed0:	10c00c1e 	bne	r2,r3,466f04 <__smakebuf_r+0x9c>
  466ed4:	8140038f 	ldh	r5,14(r16)
  466ed8:	8809883a 	mov	r4,r17
  466edc:	04674b40 	call	4674b4 <_isatty_r>
  466ee0:	10000826 	beq	r2,zero,466f04 <__smakebuf_r+0x9c>
  466ee4:	80c0030b 	ldhu	r3,12(r16)
  466ee8:	808010c4 	addi	r2,r16,67
  466eec:	80800015 	stw	r2,0(r16)
  466ef0:	18c00054 	ori	r3,r3,1
  466ef4:	80800415 	stw	r2,16(r16)
  466ef8:	00800044 	movi	r2,1
  466efc:	80c0030d 	sth	r3,12(r16)
  466f00:	80800515 	stw	r2,20(r16)
  466f04:	04810004 	movi	r18,1024
  466f08:	8809883a 	mov	r4,r17
  466f0c:	900b883a 	mov	r5,r18
  466f10:	04650dc0 	call	4650dc <_malloc_r>
  466f14:	10003026 	beq	r2,zero,466fd8 <__smakebuf_r+0x170>
  466f18:	80c0030b 	ldhu	r3,12(r16)
  466f1c:	010011b4 	movhi	r4,70
  466f20:	21198804 	addi	r4,r4,26144
  466f24:	89000f15 	stw	r4,60(r17)
  466f28:	18c02014 	ori	r3,r3,128
  466f2c:	80c0030d 	sth	r3,12(r16)
  466f30:	80800015 	stw	r2,0(r16)
  466f34:	80800415 	stw	r2,16(r16)
  466f38:	84800515 	stw	r18,20(r16)
  466f3c:	dfc01217 	ldw	ra,72(sp)
  466f40:	dc801117 	ldw	r18,68(sp)
  466f44:	dc401017 	ldw	r17,64(sp)
  466f48:	dc000f17 	ldw	r16,60(sp)
  466f4c:	dec01304 	addi	sp,sp,76
  466f50:	f800283a 	ret
  466f54:	8080030b 	ldhu	r2,12(r16)
  466f58:	10c0200c 	andi	r3,r2,128
  466f5c:	18ffffcc 	andi	r3,r3,65535
  466f60:	18e0001c 	xori	r3,r3,32768
  466f64:	18e00004 	addi	r3,r3,-32768
  466f68:	18000f1e 	bne	r3,zero,466fa8 <__smakebuf_r+0x140>
  466f6c:	04810004 	movi	r18,1024
  466f70:	10820014 	ori	r2,r2,2048
  466f74:	8080030d 	sth	r2,12(r16)
  466f78:	003fe306 	br	466f08 <__smakebuf_r+0xa0>
  466f7c:	288010c4 	addi	r2,r5,67
  466f80:	28800015 	stw	r2,0(r5)
  466f84:	28800415 	stw	r2,16(r5)
  466f88:	00800044 	movi	r2,1
  466f8c:	28800515 	stw	r2,20(r5)
  466f90:	dfc01217 	ldw	ra,72(sp)
  466f94:	dc801117 	ldw	r18,68(sp)
  466f98:	dc401017 	ldw	r17,64(sp)
  466f9c:	dc000f17 	ldw	r16,60(sp)
  466fa0:	dec01304 	addi	sp,sp,76
  466fa4:	f800283a 	ret
  466fa8:	04801004 	movi	r18,64
  466fac:	003ff006 	br	466f70 <__smakebuf_r+0x108>
  466fb0:	81000a17 	ldw	r4,40(r16)
  466fb4:	00c011b4 	movhi	r3,70
  466fb8:	18dc7204 	addi	r3,r3,29128
  466fbc:	20ffc01e 	bne	r4,r3,466ec0 <__smakebuf_r+0x58>
  466fc0:	8080030b 	ldhu	r2,12(r16)
  466fc4:	00c10004 	movi	r3,1024
  466fc8:	80c01315 	stw	r3,76(r16)
  466fcc:	10c4b03a 	or	r2,r2,r3
  466fd0:	8080030d 	sth	r2,12(r16)
  466fd4:	003fcb06 	br	466f04 <__smakebuf_r+0x9c>
  466fd8:	8080030b 	ldhu	r2,12(r16)
  466fdc:	10c0800c 	andi	r3,r2,512
  466fe0:	18ffffcc 	andi	r3,r3,65535
  466fe4:	18e0001c 	xori	r3,r3,32768
  466fe8:	18e00004 	addi	r3,r3,-32768
  466fec:	183fd31e 	bne	r3,zero,466f3c <__smakebuf_r+0xd4>
  466ff0:	10800094 	ori	r2,r2,2
  466ff4:	80c010c4 	addi	r3,r16,67
  466ff8:	8080030d 	sth	r2,12(r16)
  466ffc:	00800044 	movi	r2,1
  467000:	80c00015 	stw	r3,0(r16)
  467004:	80c00415 	stw	r3,16(r16)
  467008:	80800515 	stw	r2,20(r16)
  46700c:	003fcb06 	br	466f3c <__smakebuf_r+0xd4>

00467010 <memset>:
  467010:	00c000c4 	movi	r3,3
  467014:	2005883a 	mov	r2,r4
  467018:	29403fcc 	andi	r5,r5,255
  46701c:	19802d2e 	bgeu	r3,r6,4670d4 <memset+0xc4>
  467020:	20c6703a 	and	r3,r4,r3
  467024:	18002e1e 	bne	r3,zero,4670e0 <memset+0xd0>
  467028:	2806923a 	slli	r3,r5,8
  46702c:	010003c4 	movi	r4,15
  467030:	3011883a 	mov	r8,r6
  467034:	1946b03a 	or	r3,r3,r5
  467038:	180e943a 	slli	r7,r3,16
  46703c:	38ceb03a 	or	r7,r7,r3
  467040:	1007883a 	mov	r3,r2
  467044:	21800f2e 	bgeu	r4,r6,467084 <memset+0x74>
  467048:	19c00015 	stw	r7,0(r3)
  46704c:	19c00115 	stw	r7,4(r3)
  467050:	19c00215 	stw	r7,8(r3)
  467054:	19c00315 	stw	r7,12(r3)
  467058:	423ffc04 	addi	r8,r8,-16
  46705c:	18c00404 	addi	r3,r3,16
  467060:	223ff936 	bltu	r4,r8,467048 <memset+0x38>
  467064:	30fffc04 	addi	r3,r6,-16
  467068:	1806d13a 	srli	r3,r3,4
  46706c:	318003cc 	andi	r6,r6,15
  467070:	010000c4 	movi	r4,3
  467074:	18c00044 	addi	r3,r3,1
  467078:	1806913a 	slli	r3,r3,4
  46707c:	10c7883a 	add	r3,r2,r3
  467080:	21800e2e 	bgeu	r4,r6,4670bc <memset+0xac>
  467084:	1813883a 	mov	r9,r3
  467088:	3011883a 	mov	r8,r6
  46708c:	010000c4 	movi	r4,3
  467090:	49c00015 	stw	r7,0(r9)
  467094:	423fff04 	addi	r8,r8,-4
  467098:	4a400104 	addi	r9,r9,4
  46709c:	223ffc36 	bltu	r4,r8,467090 <memset+0x80>
  4670a0:	313fff04 	addi	r4,r6,-4
  4670a4:	2008d0ba 	srli	r4,r4,2
  4670a8:	318000cc 	andi	r6,r6,3
  4670ac:	21000044 	addi	r4,r4,1
  4670b0:	2109883a 	add	r4,r4,r4
  4670b4:	2109883a 	add	r4,r4,r4
  4670b8:	1907883a 	add	r3,r3,r4
  4670bc:	30000a26 	beq	r6,zero,4670e8 <memset+0xd8>
  4670c0:	198d883a 	add	r6,r3,r6
  4670c4:	19400005 	stb	r5,0(r3)
  4670c8:	18c00044 	addi	r3,r3,1
  4670cc:	19bffd1e 	bne	r3,r6,4670c4 <memset+0xb4>
  4670d0:	f800283a 	ret
  4670d4:	2007883a 	mov	r3,r4
  4670d8:	303ff91e 	bne	r6,zero,4670c0 <memset+0xb0>
  4670dc:	00000206 	br	4670e8 <memset+0xd8>
  4670e0:	2007883a 	mov	r3,r4
  4670e4:	003ff606 	br	4670c0 <memset+0xb0>
  4670e8:	f800283a 	ret

004670ec <__sread>:
  4670ec:	defffe04 	addi	sp,sp,-8
  4670f0:	dc000015 	stw	r16,0(sp)
  4670f4:	2821883a 	mov	r16,r5
  4670f8:	2940038f 	ldh	r5,14(r5)
  4670fc:	dfc00115 	stw	ra,4(sp)
  467100:	04675840 	call	467584 <_read_r>
  467104:	10000716 	blt	r2,zero,467124 <__sread+0x38>
  467108:	80c01417 	ldw	r3,80(r16)
  46710c:	1887883a 	add	r3,r3,r2
  467110:	80c01415 	stw	r3,80(r16)
  467114:	dfc00117 	ldw	ra,4(sp)
  467118:	dc000017 	ldw	r16,0(sp)
  46711c:	dec00204 	addi	sp,sp,8
  467120:	f800283a 	ret
  467124:	80c0030b 	ldhu	r3,12(r16)
  467128:	18fbffcc 	andi	r3,r3,61439
  46712c:	80c0030d 	sth	r3,12(r16)
  467130:	dfc00117 	ldw	ra,4(sp)
  467134:	dc000017 	ldw	r16,0(sp)
  467138:	dec00204 	addi	sp,sp,8
  46713c:	f800283a 	ret

00467140 <__swrite>:
  467140:	2880030b 	ldhu	r2,12(r5)
  467144:	defffb04 	addi	sp,sp,-20
  467148:	dcc00315 	stw	r19,12(sp)
  46714c:	10c0400c 	andi	r3,r2,256
  467150:	18ffffcc 	andi	r3,r3,65535
  467154:	18e0001c 	xori	r3,r3,32768
  467158:	dc800215 	stw	r18,8(sp)
  46715c:	dc400115 	stw	r17,4(sp)
  467160:	dc000015 	stw	r16,0(sp)
  467164:	dfc00415 	stw	ra,16(sp)
  467168:	18e00004 	addi	r3,r3,-32768
  46716c:	2821883a 	mov	r16,r5
  467170:	2027883a 	mov	r19,r4
  467174:	3025883a 	mov	r18,r6
  467178:	3823883a 	mov	r17,r7
  46717c:	18000526 	beq	r3,zero,467194 <__swrite+0x54>
  467180:	2940038f 	ldh	r5,14(r5)
  467184:	000d883a 	mov	r6,zero
  467188:	01c00084 	movi	r7,2
  46718c:	04675180 	call	467518 <_lseek_r>
  467190:	8080030b 	ldhu	r2,12(r16)
  467194:	8140038f 	ldh	r5,14(r16)
  467198:	10bbffcc 	andi	r2,r2,61439
  46719c:	9809883a 	mov	r4,r19
  4671a0:	900d883a 	mov	r6,r18
  4671a4:	880f883a 	mov	r7,r17
  4671a8:	8080030d 	sth	r2,12(r16)
  4671ac:	dfc00417 	ldw	ra,16(sp)
  4671b0:	dcc00317 	ldw	r19,12(sp)
  4671b4:	dc800217 	ldw	r18,8(sp)
  4671b8:	dc400117 	ldw	r17,4(sp)
  4671bc:	dc000017 	ldw	r16,0(sp)
  4671c0:	dec00504 	addi	sp,sp,20
  4671c4:	046722c1 	jmpi	46722c <_write_r>

004671c8 <__sseek>:
  4671c8:	defffe04 	addi	sp,sp,-8
  4671cc:	dc000015 	stw	r16,0(sp)
  4671d0:	2821883a 	mov	r16,r5
  4671d4:	2940038f 	ldh	r5,14(r5)
  4671d8:	dfc00115 	stw	ra,4(sp)
  4671dc:	04675180 	call	467518 <_lseek_r>
  4671e0:	00ffffc4 	movi	r3,-1
  4671e4:	10c00826 	beq	r2,r3,467208 <__sseek+0x40>
  4671e8:	80c0030b 	ldhu	r3,12(r16)
  4671ec:	80801415 	stw	r2,80(r16)
  4671f0:	18c40014 	ori	r3,r3,4096
  4671f4:	80c0030d 	sth	r3,12(r16)
  4671f8:	dfc00117 	ldw	ra,4(sp)
  4671fc:	dc000017 	ldw	r16,0(sp)
  467200:	dec00204 	addi	sp,sp,8
  467204:	f800283a 	ret
  467208:	80c0030b 	ldhu	r3,12(r16)
  46720c:	18fbffcc 	andi	r3,r3,61439
  467210:	80c0030d 	sth	r3,12(r16)
  467214:	dfc00117 	ldw	ra,4(sp)
  467218:	dc000017 	ldw	r16,0(sp)
  46721c:	dec00204 	addi	sp,sp,8
  467220:	f800283a 	ret

00467224 <__sclose>:
  467224:	2940038f 	ldh	r5,14(r5)
  467228:	04672981 	jmpi	467298 <_close_r>

0046722c <_write_r>:
  46722c:	defffd04 	addi	sp,sp,-12
  467230:	dc400115 	stw	r17,4(sp)
  467234:	dc000015 	stw	r16,0(sp)
  467238:	2023883a 	mov	r17,r4
  46723c:	04001234 	movhi	r16,72
  467240:	84263404 	addi	r16,r16,-26416
  467244:	2809883a 	mov	r4,r5
  467248:	300b883a 	mov	r5,r6
  46724c:	380d883a 	mov	r6,r7
  467250:	dfc00215 	stw	ra,8(sp)
  467254:	80000015 	stw	zero,0(r16)
  467258:	04682980 	call	468298 <write>
  46725c:	00ffffc4 	movi	r3,-1
  467260:	10c00526 	beq	r2,r3,467278 <_write_r+0x4c>
  467264:	dfc00217 	ldw	ra,8(sp)
  467268:	dc400117 	ldw	r17,4(sp)
  46726c:	dc000017 	ldw	r16,0(sp)
  467270:	dec00304 	addi	sp,sp,12
  467274:	f800283a 	ret
  467278:	80c00017 	ldw	r3,0(r16)
  46727c:	183ff926 	beq	r3,zero,467264 <_write_r+0x38>
  467280:	88c00015 	stw	r3,0(r17)
  467284:	dfc00217 	ldw	ra,8(sp)
  467288:	dc400117 	ldw	r17,4(sp)
  46728c:	dc000017 	ldw	r16,0(sp)
  467290:	dec00304 	addi	sp,sp,12
  467294:	f800283a 	ret

00467298 <_close_r>:
  467298:	defffd04 	addi	sp,sp,-12
  46729c:	dc400115 	stw	r17,4(sp)
  4672a0:	dc000015 	stw	r16,0(sp)
  4672a4:	2023883a 	mov	r17,r4
  4672a8:	04001234 	movhi	r16,72
  4672ac:	84263404 	addi	r16,r16,-26416
  4672b0:	2809883a 	mov	r4,r5
  4672b4:	dfc00215 	stw	ra,8(sp)
  4672b8:	80000015 	stw	zero,0(r16)
  4672bc:	04676680 	call	467668 <close>
  4672c0:	00ffffc4 	movi	r3,-1
  4672c4:	10c00526 	beq	r2,r3,4672dc <_close_r+0x44>
  4672c8:	dfc00217 	ldw	ra,8(sp)
  4672cc:	dc400117 	ldw	r17,4(sp)
  4672d0:	dc000017 	ldw	r16,0(sp)
  4672d4:	dec00304 	addi	sp,sp,12
  4672d8:	f800283a 	ret
  4672dc:	80c00017 	ldw	r3,0(r16)
  4672e0:	183ff926 	beq	r3,zero,4672c8 <_close_r+0x30>
  4672e4:	88c00015 	stw	r3,0(r17)
  4672e8:	dfc00217 	ldw	ra,8(sp)
  4672ec:	dc400117 	ldw	r17,4(sp)
  4672f0:	dc000017 	ldw	r16,0(sp)
  4672f4:	dec00304 	addi	sp,sp,12
  4672f8:	f800283a 	ret

004672fc <_fclose_r>:
  4672fc:	defffc04 	addi	sp,sp,-16
  467300:	dc400115 	stw	r17,4(sp)
  467304:	dc000015 	stw	r16,0(sp)
  467308:	dfc00315 	stw	ra,12(sp)
  46730c:	dc800215 	stw	r18,8(sp)
  467310:	2821883a 	mov	r16,r5
  467314:	2023883a 	mov	r17,r4
  467318:	28003426 	beq	r5,zero,4673ec <_fclose_r+0xf0>
  46731c:	04668bc0 	call	4668bc <__sfp_lock_acquire>
  467320:	88000226 	beq	r17,zero,46732c <_fclose_r+0x30>
  467324:	88800e17 	ldw	r2,56(r17)
  467328:	10003826 	beq	r2,zero,46740c <_fclose_r+0x110>
  46732c:	8080030f 	ldh	r2,12(r16)
  467330:	10002526 	beq	r2,zero,4673c8 <_fclose_r+0xcc>
  467334:	8809883a 	mov	r4,r17
  467338:	800b883a 	mov	r5,r16
  46733c:	04663f80 	call	4663f8 <_fflush_r>
  467340:	1025883a 	mov	r18,r2
  467344:	80800b17 	ldw	r2,44(r16)
  467348:	10000426 	beq	r2,zero,46735c <_fclose_r+0x60>
  46734c:	81400717 	ldw	r5,28(r16)
  467350:	8809883a 	mov	r4,r17
  467354:	103ee83a 	callr	r2
  467358:	10003516 	blt	r2,zero,467430 <_fclose_r+0x134>
  46735c:	8080030b 	ldhu	r2,12(r16)
  467360:	1080200c 	andi	r2,r2,128
  467364:	10bfffcc 	andi	r2,r2,65535
  467368:	10a0001c 	xori	r2,r2,32768
  46736c:	10a00004 	addi	r2,r2,-32768
  467370:	10002b1e 	bne	r2,zero,467420 <_fclose_r+0x124>
  467374:	81400c17 	ldw	r5,48(r16)
  467378:	28000526 	beq	r5,zero,467390 <_fclose_r+0x94>
  46737c:	80801004 	addi	r2,r16,64
  467380:	28800226 	beq	r5,r2,46738c <_fclose_r+0x90>
  467384:	8809883a 	mov	r4,r17
  467388:	0466a380 	call	466a38 <_free_r>
  46738c:	80000c15 	stw	zero,48(r16)
  467390:	81401117 	ldw	r5,68(r16)
  467394:	28000326 	beq	r5,zero,4673a4 <_fclose_r+0xa8>
  467398:	8809883a 	mov	r4,r17
  46739c:	0466a380 	call	466a38 <_free_r>
  4673a0:	80001115 	stw	zero,68(r16)
  4673a4:	8000030d 	sth	zero,12(r16)
  4673a8:	04668c00 	call	4668c0 <__sfp_lock_release>
  4673ac:	9005883a 	mov	r2,r18
  4673b0:	dfc00317 	ldw	ra,12(sp)
  4673b4:	dc800217 	ldw	r18,8(sp)
  4673b8:	dc400117 	ldw	r17,4(sp)
  4673bc:	dc000017 	ldw	r16,0(sp)
  4673c0:	dec00404 	addi	sp,sp,16
  4673c4:	f800283a 	ret
  4673c8:	04668c00 	call	4668c0 <__sfp_lock_release>
  4673cc:	0025883a 	mov	r18,zero
  4673d0:	9005883a 	mov	r2,r18
  4673d4:	dfc00317 	ldw	ra,12(sp)
  4673d8:	dc800217 	ldw	r18,8(sp)
  4673dc:	dc400117 	ldw	r17,4(sp)
  4673e0:	dc000017 	ldw	r16,0(sp)
  4673e4:	dec00404 	addi	sp,sp,16
  4673e8:	f800283a 	ret
  4673ec:	0025883a 	mov	r18,zero
  4673f0:	9005883a 	mov	r2,r18
  4673f4:	dfc00317 	ldw	ra,12(sp)
  4673f8:	dc800217 	ldw	r18,8(sp)
  4673fc:	dc400117 	ldw	r17,4(sp)
  467400:	dc000017 	ldw	r16,0(sp)
  467404:	dec00404 	addi	sp,sp,16
  467408:	f800283a 	ret
  46740c:	8809883a 	mov	r4,r17
  467410:	04666b40 	call	4666b4 <__sinit>
  467414:	8080030f 	ldh	r2,12(r16)
  467418:	103fc61e 	bne	r2,zero,467334 <_fclose_r+0x38>
  46741c:	003fea06 	br	4673c8 <_fclose_r+0xcc>
  467420:	81400417 	ldw	r5,16(r16)
  467424:	8809883a 	mov	r4,r17
  467428:	0466a380 	call	466a38 <_free_r>
  46742c:	003fd106 	br	467374 <_fclose_r+0x78>
  467430:	04bfffc4 	movi	r18,-1
  467434:	003fc906 	br	46735c <_fclose_r+0x60>

00467438 <fclose>:
  467438:	008011f4 	movhi	r2,71
  46743c:	109f3a04 	addi	r2,r2,31976
  467440:	200b883a 	mov	r5,r4
  467444:	11000017 	ldw	r4,0(r2)
  467448:	04672fc1 	jmpi	4672fc <_fclose_r>

0046744c <_fstat_r>:
  46744c:	defffd04 	addi	sp,sp,-12
  467450:	dc400115 	stw	r17,4(sp)
  467454:	dc000015 	stw	r16,0(sp)
  467458:	2023883a 	mov	r17,r4
  46745c:	04001234 	movhi	r16,72
  467460:	84263404 	addi	r16,r16,-26416
  467464:	2809883a 	mov	r4,r5
  467468:	300b883a 	mov	r5,r6
  46746c:	dfc00215 	stw	ra,8(sp)
  467470:	80000015 	stw	zero,0(r16)
  467474:	04677b00 	call	4677b0 <fstat>
  467478:	00ffffc4 	movi	r3,-1
  46747c:	10c00526 	beq	r2,r3,467494 <_fstat_r+0x48>
  467480:	dfc00217 	ldw	ra,8(sp)
  467484:	dc400117 	ldw	r17,4(sp)
  467488:	dc000017 	ldw	r16,0(sp)
  46748c:	dec00304 	addi	sp,sp,12
  467490:	f800283a 	ret
  467494:	80c00017 	ldw	r3,0(r16)
  467498:	183ff926 	beq	r3,zero,467480 <_fstat_r+0x34>
  46749c:	88c00015 	stw	r3,0(r17)
  4674a0:	dfc00217 	ldw	ra,8(sp)
  4674a4:	dc400117 	ldw	r17,4(sp)
  4674a8:	dc000017 	ldw	r16,0(sp)
  4674ac:	dec00304 	addi	sp,sp,12
  4674b0:	f800283a 	ret

004674b4 <_isatty_r>:
  4674b4:	defffd04 	addi	sp,sp,-12
  4674b8:	dc400115 	stw	r17,4(sp)
  4674bc:	dc000015 	stw	r16,0(sp)
  4674c0:	2023883a 	mov	r17,r4
  4674c4:	04001234 	movhi	r16,72
  4674c8:	84263404 	addi	r16,r16,-26416
  4674cc:	2809883a 	mov	r4,r5
  4674d0:	dfc00215 	stw	ra,8(sp)
  4674d4:	80000015 	stw	zero,0(r16)
  4674d8:	0467bfc0 	call	467bfc <isatty>
  4674dc:	00ffffc4 	movi	r3,-1
  4674e0:	10c00526 	beq	r2,r3,4674f8 <_isatty_r+0x44>
  4674e4:	dfc00217 	ldw	ra,8(sp)
  4674e8:	dc400117 	ldw	r17,4(sp)
  4674ec:	dc000017 	ldw	r16,0(sp)
  4674f0:	dec00304 	addi	sp,sp,12
  4674f4:	f800283a 	ret
  4674f8:	80c00017 	ldw	r3,0(r16)
  4674fc:	183ff926 	beq	r3,zero,4674e4 <_isatty_r+0x30>
  467500:	88c00015 	stw	r3,0(r17)
  467504:	dfc00217 	ldw	ra,8(sp)
  467508:	dc400117 	ldw	r17,4(sp)
  46750c:	dc000017 	ldw	r16,0(sp)
  467510:	dec00304 	addi	sp,sp,12
  467514:	f800283a 	ret

00467518 <_lseek_r>:
  467518:	defffd04 	addi	sp,sp,-12
  46751c:	dc400115 	stw	r17,4(sp)
  467520:	dc000015 	stw	r16,0(sp)
  467524:	2023883a 	mov	r17,r4
  467528:	04001234 	movhi	r16,72
  46752c:	84263404 	addi	r16,r16,-26416
  467530:	2809883a 	mov	r4,r5
  467534:	300b883a 	mov	r5,r6
  467538:	380d883a 	mov	r6,r7
  46753c:	dfc00215 	stw	ra,8(sp)
  467540:	80000015 	stw	zero,0(r16)
  467544:	0467ddc0 	call	467ddc <lseek>
  467548:	00ffffc4 	movi	r3,-1
  46754c:	10c00526 	beq	r2,r3,467564 <_lseek_r+0x4c>
  467550:	dfc00217 	ldw	ra,8(sp)
  467554:	dc400117 	ldw	r17,4(sp)
  467558:	dc000017 	ldw	r16,0(sp)
  46755c:	dec00304 	addi	sp,sp,12
  467560:	f800283a 	ret
  467564:	80c00017 	ldw	r3,0(r16)
  467568:	183ff926 	beq	r3,zero,467550 <_lseek_r+0x38>
  46756c:	88c00015 	stw	r3,0(r17)
  467570:	dfc00217 	ldw	ra,8(sp)
  467574:	dc400117 	ldw	r17,4(sp)
  467578:	dc000017 	ldw	r16,0(sp)
  46757c:	dec00304 	addi	sp,sp,12
  467580:	f800283a 	ret

00467584 <_read_r>:
  467584:	defffd04 	addi	sp,sp,-12
  467588:	dc400115 	stw	r17,4(sp)
  46758c:	dc000015 	stw	r16,0(sp)
  467590:	2023883a 	mov	r17,r4
  467594:	04001234 	movhi	r16,72
  467598:	84263404 	addi	r16,r16,-26416
  46759c:	2809883a 	mov	r4,r5
  4675a0:	300b883a 	mov	r5,r6
  4675a4:	380d883a 	mov	r6,r7
  4675a8:	dfc00215 	stw	ra,8(sp)
  4675ac:	80000015 	stw	zero,0(r16)
  4675b0:	0467fcc0 	call	467fcc <read>
  4675b4:	00ffffc4 	movi	r3,-1
  4675b8:	10c00526 	beq	r2,r3,4675d0 <_read_r+0x4c>
  4675bc:	dfc00217 	ldw	ra,8(sp)
  4675c0:	dc400117 	ldw	r17,4(sp)
  4675c4:	dc000017 	ldw	r16,0(sp)
  4675c8:	dec00304 	addi	sp,sp,12
  4675cc:	f800283a 	ret
  4675d0:	80c00017 	ldw	r3,0(r16)
  4675d4:	183ff926 	beq	r3,zero,4675bc <_read_r+0x38>
  4675d8:	88c00015 	stw	r3,0(r17)
  4675dc:	dfc00217 	ldw	ra,8(sp)
  4675e0:	dc400117 	ldw	r17,4(sp)
  4675e4:	dc000017 	ldw	r16,0(sp)
  4675e8:	dec00304 	addi	sp,sp,12
  4675ec:	f800283a 	ret

004675f0 <__mulsi3>:
  4675f0:	0005883a 	mov	r2,zero
  4675f4:	20000726 	beq	r4,zero,467614 <__mulsi3+0x24>
  4675f8:	20c0004c 	andi	r3,r4,1
  4675fc:	2008d07a 	srli	r4,r4,1
  467600:	18000126 	beq	r3,zero,467608 <__mulsi3+0x18>
  467604:	1145883a 	add	r2,r2,r5
  467608:	294b883a 	add	r5,r5,r5
  46760c:	203ffa1e 	bne	r4,zero,4675f8 <__mulsi3+0x8>
  467610:	f800283a 	ret
  467614:	f800283a 	ret

00467618 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  467618:	defffe04 	addi	sp,sp,-8
  46761c:	dfc00115 	stw	ra,4(sp)
  467620:	df000015 	stw	fp,0(sp)
  467624:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  467628:	008011f4 	movhi	r2,71
  46762c:	109f4204 	addi	r2,r2,32008
  467630:	10800017 	ldw	r2,0(r2)
  467634:	10000526 	beq	r2,zero,46764c <alt_get_errno+0x34>
  467638:	008011f4 	movhi	r2,71
  46763c:	109f4204 	addi	r2,r2,32008
  467640:	10800017 	ldw	r2,0(r2)
  467644:	103ee83a 	callr	r2
  467648:	00000206 	br	467654 <alt_get_errno+0x3c>
  46764c:	00801234 	movhi	r2,72
  467650:	10a63404 	addi	r2,r2,-26416
}
  467654:	e037883a 	mov	sp,fp
  467658:	dfc00117 	ldw	ra,4(sp)
  46765c:	df000017 	ldw	fp,0(sp)
  467660:	dec00204 	addi	sp,sp,8
  467664:	f800283a 	ret

00467668 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
  467668:	defffb04 	addi	sp,sp,-20
  46766c:	dfc00415 	stw	ra,16(sp)
  467670:	df000315 	stw	fp,12(sp)
  467674:	df000304 	addi	fp,sp,12
  467678:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
  46767c:	e0bfff17 	ldw	r2,-4(fp)
  467680:	10000716 	blt	r2,zero,4676a0 <close+0x38>
  467684:	e13fff17 	ldw	r4,-4(fp)
  467688:	01400304 	movi	r5,12
  46768c:	04675f00 	call	4675f0 <__mulsi3>
  467690:	00c011f4 	movhi	r3,71
  467694:	18dab304 	addi	r3,r3,27340
  467698:	10c5883a 	add	r2,r2,r3
  46769c:	00000106 	br	4676a4 <close+0x3c>
  4676a0:	0005883a 	mov	r2,zero
  4676a4:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
  4676a8:	e0bffd17 	ldw	r2,-12(fp)
  4676ac:	10001826 	beq	r2,zero,467710 <close+0xa8>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
  4676b0:	e0bffd17 	ldw	r2,-12(fp)
  4676b4:	10800017 	ldw	r2,0(r2)
  4676b8:	10800417 	ldw	r2,16(r2)
  4676bc:	10000626 	beq	r2,zero,4676d8 <close+0x70>
  4676c0:	e0bffd17 	ldw	r2,-12(fp)
  4676c4:	10800017 	ldw	r2,0(r2)
  4676c8:	10800417 	ldw	r2,16(r2)
  4676cc:	e13ffd17 	ldw	r4,-12(fp)
  4676d0:	103ee83a 	callr	r2
  4676d4:	00000106 	br	4676dc <close+0x74>
  4676d8:	0005883a 	mov	r2,zero
  4676dc:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
  4676e0:	e13fff17 	ldw	r4,-4(fp)
  4676e4:	04680c00 	call	4680c0 <alt_release_fd>
    if (rval < 0)
  4676e8:	e0bffe17 	ldw	r2,-8(fp)
  4676ec:	1000060e 	bge	r2,zero,467708 <close+0xa0>
    {
      ALT_ERRNO = -rval;
  4676f0:	04676180 	call	467618 <alt_get_errno>
  4676f4:	e0fffe17 	ldw	r3,-8(fp)
  4676f8:	00c7c83a 	sub	r3,zero,r3
  4676fc:	10c00015 	stw	r3,0(r2)
      return -1;
  467700:	00bfffc4 	movi	r2,-1
  467704:	00000606 	br	467720 <close+0xb8>
    }
    return 0;
  467708:	0005883a 	mov	r2,zero
  46770c:	00000406 	br	467720 <close+0xb8>
  }
  else
  {
    ALT_ERRNO = EBADFD;
  467710:	04676180 	call	467618 <alt_get_errno>
  467714:	00c01444 	movi	r3,81
  467718:	10c00015 	stw	r3,0(r2)
    return -1;
  46771c:	00bfffc4 	movi	r2,-1
  }
}
  467720:	e037883a 	mov	sp,fp
  467724:	dfc00117 	ldw	ra,4(sp)
  467728:	df000017 	ldw	fp,0(sp)
  46772c:	dec00204 	addi	sp,sp,8
  467730:	f800283a 	ret

00467734 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
  467734:	defffc04 	addi	sp,sp,-16
  467738:	df000315 	stw	fp,12(sp)
  46773c:	df000304 	addi	fp,sp,12
  467740:	e13ffd15 	stw	r4,-12(fp)
  467744:	e17ffe15 	stw	r5,-8(fp)
  467748:	e1bfff15 	stw	r6,-4(fp)
  return len;
  46774c:	e0bfff17 	ldw	r2,-4(fp)
}
  467750:	e037883a 	mov	sp,fp
  467754:	df000017 	ldw	fp,0(sp)
  467758:	dec00104 	addi	sp,sp,4
  46775c:	f800283a 	ret

00467760 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  467760:	defffe04 	addi	sp,sp,-8
  467764:	dfc00115 	stw	ra,4(sp)
  467768:	df000015 	stw	fp,0(sp)
  46776c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  467770:	008011f4 	movhi	r2,71
  467774:	109f4204 	addi	r2,r2,32008
  467778:	10800017 	ldw	r2,0(r2)
  46777c:	10000526 	beq	r2,zero,467794 <alt_get_errno+0x34>
  467780:	008011f4 	movhi	r2,71
  467784:	109f4204 	addi	r2,r2,32008
  467788:	10800017 	ldw	r2,0(r2)
  46778c:	103ee83a 	callr	r2
  467790:	00000206 	br	46779c <alt_get_errno+0x3c>
  467794:	00801234 	movhi	r2,72
  467798:	10a63404 	addi	r2,r2,-26416
}
  46779c:	e037883a 	mov	sp,fp
  4677a0:	dfc00117 	ldw	ra,4(sp)
  4677a4:	df000017 	ldw	fp,0(sp)
  4677a8:	dec00204 	addi	sp,sp,8
  4677ac:	f800283a 	ret

004677b0 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
  4677b0:	defffb04 	addi	sp,sp,-20
  4677b4:	dfc00415 	stw	ra,16(sp)
  4677b8:	df000315 	stw	fp,12(sp)
  4677bc:	df000304 	addi	fp,sp,12
  4677c0:	e13ffe15 	stw	r4,-8(fp)
  4677c4:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  4677c8:	e0bffe17 	ldw	r2,-8(fp)
  4677cc:	10000716 	blt	r2,zero,4677ec <fstat+0x3c>
  4677d0:	e13ffe17 	ldw	r4,-8(fp)
  4677d4:	01400304 	movi	r5,12
  4677d8:	04675f00 	call	4675f0 <__mulsi3>
  4677dc:	00c011f4 	movhi	r3,71
  4677e0:	18dab304 	addi	r3,r3,27340
  4677e4:	10c5883a 	add	r2,r2,r3
  4677e8:	00000106 	br	4677f0 <fstat+0x40>
  4677ec:	0005883a 	mov	r2,zero
  4677f0:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
  4677f4:	e0bffd17 	ldw	r2,-12(fp)
  4677f8:	10001026 	beq	r2,zero,46783c <fstat+0x8c>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
  4677fc:	e0bffd17 	ldw	r2,-12(fp)
  467800:	10800017 	ldw	r2,0(r2)
  467804:	10800817 	ldw	r2,32(r2)
  467808:	10000726 	beq	r2,zero,467828 <fstat+0x78>
    {
      return fd->dev->fstat(fd, st);
  46780c:	e0bffd17 	ldw	r2,-12(fp)
  467810:	10800017 	ldw	r2,0(r2)
  467814:	10800817 	ldw	r2,32(r2)
  467818:	e13ffd17 	ldw	r4,-12(fp)
  46781c:	e17fff17 	ldw	r5,-4(fp)
  467820:	103ee83a 	callr	r2
  467824:	00000906 	br	46784c <fstat+0x9c>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
  467828:	e0bfff17 	ldw	r2,-4(fp)
  46782c:	00c80004 	movi	r3,8192
  467830:	10c00115 	stw	r3,4(r2)
      return 0;
  467834:	0005883a 	mov	r2,zero
  467838:	00000406 	br	46784c <fstat+0x9c>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
  46783c:	04677600 	call	467760 <alt_get_errno>
  467840:	00c01444 	movi	r3,81
  467844:	10c00015 	stw	r3,0(r2)
    return -1;
  467848:	00bfffc4 	movi	r2,-1
  }
}
  46784c:	e037883a 	mov	sp,fp
  467850:	dfc00117 	ldw	ra,4(sp)
  467854:	df000017 	ldw	fp,0(sp)
  467858:	dec00204 	addi	sp,sp,8
  46785c:	f800283a 	ret

00467860 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  467860:	defff904 	addi	sp,sp,-28
  467864:	dfc00615 	stw	ra,24(sp)
  467868:	df000515 	stw	fp,20(sp)
  46786c:	df000504 	addi	fp,sp,20
  467870:	e13ffc15 	stw	r4,-16(fp)
  467874:	e17ffd15 	stw	r5,-12(fp)
  467878:	e1bffe15 	stw	r6,-8(fp)
  46787c:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
  467880:	e0800217 	ldw	r2,8(fp)
  467884:	d8800015 	stw	r2,0(sp)
  467888:	e13ffc17 	ldw	r4,-16(fp)
  46788c:	e17ffd17 	ldw	r5,-12(fp)
  467890:	e1bffe17 	ldw	r6,-8(fp)
  467894:	e1ffff17 	ldw	r7,-4(fp)
  467898:	0467a900 	call	467a90 <alt_iic_isr_register>
}  
  46789c:	e037883a 	mov	sp,fp
  4678a0:	dfc00117 	ldw	ra,4(sp)
  4678a4:	df000017 	ldw	fp,0(sp)
  4678a8:	dec00204 	addi	sp,sp,8
  4678ac:	f800283a 	ret

004678b0 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
  4678b0:	defff804 	addi	sp,sp,-32
  4678b4:	df000715 	stw	fp,28(sp)
  4678b8:	df000704 	addi	fp,sp,28
  4678bc:	e13ffe15 	stw	r4,-8(fp)
  4678c0:	e17fff15 	stw	r5,-4(fp)
  4678c4:	e0bfff17 	ldw	r2,-4(fp)
  4678c8:	e0bff915 	stw	r2,-28(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  4678cc:	0005303a 	rdctl	r2,status
  4678d0:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  4678d4:	e0fffa17 	ldw	r3,-24(fp)
  4678d8:	00bfff84 	movi	r2,-2
  4678dc:	1884703a 	and	r2,r3,r2
  4678e0:	1001703a 	wrctl	status,r2
  
  return context;
  4678e4:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  4678e8:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active |= (1 << id);
  4678ec:	e0bff917 	ldw	r2,-28(fp)
  4678f0:	00c00044 	movi	r3,1
  4678f4:	1884983a 	sll	r2,r3,r2
  4678f8:	1007883a 	mov	r3,r2
  4678fc:	00801234 	movhi	r2,72
  467900:	10a63604 	addi	r2,r2,-26408
  467904:	10800017 	ldw	r2,0(r2)
  467908:	1886b03a 	or	r3,r3,r2
  46790c:	00801234 	movhi	r2,72
  467910:	10a63604 	addi	r2,r2,-26408
  467914:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  467918:	00801234 	movhi	r2,72
  46791c:	10a63604 	addi	r2,r2,-26408
  467920:	10800017 	ldw	r2,0(r2)
  467924:	100170fa 	wrctl	ienable,r2
  467928:	e0bffb17 	ldw	r2,-20(fp)
  46792c:	e0bffc15 	stw	r2,-16(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  467930:	0005303a 	rdctl	r2,status
  467934:	e0bffd15 	stw	r2,-12(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  467938:	e0fffd17 	ldw	r3,-12(fp)
  46793c:	00bfff84 	movi	r2,-2
  467940:	1884703a 	and	r2,r3,r2
  467944:	e0bffd15 	stw	r2,-12(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  467948:	e0bffc17 	ldw	r2,-16(fp)
  46794c:	1080004c 	andi	r2,r2,1
  467950:	e0fffd17 	ldw	r3,-12(fp)
  467954:	1884b03a 	or	r2,r3,r2
  467958:	e0bffd15 	stw	r2,-12(fp)
  
  NIOS2_WRITE_STATUS (status);
  46795c:	e0bffd17 	ldw	r2,-12(fp)
  467960:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  467964:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
}
  467968:	e037883a 	mov	sp,fp
  46796c:	df000017 	ldw	fp,0(sp)
  467970:	dec00104 	addi	sp,sp,4
  467974:	f800283a 	ret

00467978 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
  467978:	defff804 	addi	sp,sp,-32
  46797c:	df000715 	stw	fp,28(sp)
  467980:	df000704 	addi	fp,sp,28
  467984:	e13ffe15 	stw	r4,-8(fp)
  467988:	e17fff15 	stw	r5,-4(fp)
  46798c:	e0bfff17 	ldw	r2,-4(fp)
  467990:	e0bff915 	stw	r2,-28(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  467994:	0005303a 	rdctl	r2,status
  467998:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46799c:	e0fffa17 	ldw	r3,-24(fp)
  4679a0:	00bfff84 	movi	r2,-2
  4679a4:	1884703a 	and	r2,r3,r2
  4679a8:	1001703a 	wrctl	status,r2
  
  return context;
  4679ac:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  4679b0:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
  4679b4:	e0bff917 	ldw	r2,-28(fp)
  4679b8:	00c00044 	movi	r3,1
  4679bc:	1884983a 	sll	r2,r3,r2
  4679c0:	0084303a 	nor	r2,zero,r2
  4679c4:	1007883a 	mov	r3,r2
  4679c8:	00801234 	movhi	r2,72
  4679cc:	10a63604 	addi	r2,r2,-26408
  4679d0:	10800017 	ldw	r2,0(r2)
  4679d4:	1886703a 	and	r3,r3,r2
  4679d8:	00801234 	movhi	r2,72
  4679dc:	10a63604 	addi	r2,r2,-26408
  4679e0:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  4679e4:	00801234 	movhi	r2,72
  4679e8:	10a63604 	addi	r2,r2,-26408
  4679ec:	10800017 	ldw	r2,0(r2)
  4679f0:	100170fa 	wrctl	ienable,r2
  4679f4:	e0bffb17 	ldw	r2,-20(fp)
  4679f8:	e0bffc15 	stw	r2,-16(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  4679fc:	0005303a 	rdctl	r2,status
  467a00:	e0bffd15 	stw	r2,-12(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  467a04:	e0fffd17 	ldw	r3,-12(fp)
  467a08:	00bfff84 	movi	r2,-2
  467a0c:	1884703a 	and	r2,r3,r2
  467a10:	e0bffd15 	stw	r2,-12(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  467a14:	e0bffc17 	ldw	r2,-16(fp)
  467a18:	1080004c 	andi	r2,r2,1
  467a1c:	e0fffd17 	ldw	r3,-12(fp)
  467a20:	1884b03a 	or	r2,r3,r2
  467a24:	e0bffd15 	stw	r2,-12(fp)
  
  NIOS2_WRITE_STATUS (status);
  467a28:	e0bffd17 	ldw	r2,-12(fp)
  467a2c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  467a30:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
}
  467a34:	e037883a 	mov	sp,fp
  467a38:	df000017 	ldw	fp,0(sp)
  467a3c:	dec00104 	addi	sp,sp,4
  467a40:	f800283a 	ret

00467a44 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
  467a44:	defffc04 	addi	sp,sp,-16
  467a48:	df000315 	stw	fp,12(sp)
  467a4c:	df000304 	addi	fp,sp,12
  467a50:	e13ffe15 	stw	r4,-8(fp)
  467a54:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
  467a58:	000530fa 	rdctl	r2,ienable
  467a5c:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
  467a60:	e0bfff17 	ldw	r2,-4(fp)
  467a64:	00c00044 	movi	r3,1
  467a68:	1884983a 	sll	r2,r3,r2
  467a6c:	1007883a 	mov	r3,r2
  467a70:	e0bffd17 	ldw	r2,-12(fp)
  467a74:	1884703a 	and	r2,r3,r2
  467a78:	1004c03a 	cmpne	r2,r2,zero
  467a7c:	10803fcc 	andi	r2,r2,255
}
  467a80:	e037883a 	mov	sp,fp
  467a84:	df000017 	ldw	fp,0(sp)
  467a88:	dec00104 	addi	sp,sp,4
  467a8c:	f800283a 	ret

00467a90 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  467a90:	defff404 	addi	sp,sp,-48
  467a94:	dfc00b15 	stw	ra,44(sp)
  467a98:	df000a15 	stw	fp,40(sp)
  467a9c:	df000a04 	addi	fp,sp,40
  467aa0:	e13ffc15 	stw	r4,-16(fp)
  467aa4:	e17ffd15 	stw	r5,-12(fp)
  467aa8:	e1bffe15 	stw	r6,-8(fp)
  467aac:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
  467ab0:	00bffa84 	movi	r2,-22
  467ab4:	e0bff615 	stw	r2,-40(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  467ab8:	e0bffd17 	ldw	r2,-12(fp)
  467abc:	e0bff715 	stw	r2,-36(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
  467ac0:	e0bff717 	ldw	r2,-36(fp)
  467ac4:	10800808 	cmpgei	r2,r2,32
  467ac8:	1000321e 	bne	r2,zero,467b94 <alt_iic_isr_register+0x104>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  467acc:	0005303a 	rdctl	r2,status
  467ad0:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  467ad4:	e0fff917 	ldw	r3,-28(fp)
  467ad8:	00bfff84 	movi	r2,-2
  467adc:	1884703a 	and	r2,r3,r2
  467ae0:	1001703a 	wrctl	status,r2
  
  return context;
  467ae4:	e0bff917 	ldw	r2,-28(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
  467ae8:	e0bff815 	stw	r2,-32(fp)

    alt_irq[id].handler = isr;
  467aec:	00c01234 	movhi	r3,72
  467af0:	18e66004 	addi	r3,r3,-26240
  467af4:	e0bff717 	ldw	r2,-36(fp)
  467af8:	100490fa 	slli	r2,r2,3
  467afc:	1885883a 	add	r2,r3,r2
  467b00:	e0fffe17 	ldw	r3,-8(fp)
  467b04:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
  467b08:	00c01234 	movhi	r3,72
  467b0c:	18e66004 	addi	r3,r3,-26240
  467b10:	e0bff717 	ldw	r2,-36(fp)
  467b14:	100490fa 	slli	r2,r2,3
  467b18:	1885883a 	add	r2,r3,r2
  467b1c:	10800104 	addi	r2,r2,4
  467b20:	e0ffff17 	ldw	r3,-4(fp)
  467b24:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
  467b28:	e0bffe17 	ldw	r2,-8(fp)
  467b2c:	10000526 	beq	r2,zero,467b44 <alt_iic_isr_register+0xb4>
  467b30:	e0bff717 	ldw	r2,-36(fp)
  467b34:	e13ffc17 	ldw	r4,-16(fp)
  467b38:	100b883a 	mov	r5,r2
  467b3c:	04678b00 	call	4678b0 <alt_ic_irq_enable>
  467b40:	00000406 	br	467b54 <alt_iic_isr_register+0xc4>
  467b44:	e0bff717 	ldw	r2,-36(fp)
  467b48:	e13ffc17 	ldw	r4,-16(fp)
  467b4c:	100b883a 	mov	r5,r2
  467b50:	04679780 	call	467978 <alt_ic_irq_disable>
  467b54:	e0bff615 	stw	r2,-40(fp)
  467b58:	e0bff817 	ldw	r2,-32(fp)
  467b5c:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  467b60:	0005303a 	rdctl	r2,status
  467b64:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  467b68:	e0fffb17 	ldw	r3,-20(fp)
  467b6c:	00bfff84 	movi	r2,-2
  467b70:	1884703a 	and	r2,r3,r2
  467b74:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  467b78:	e0bffa17 	ldw	r2,-24(fp)
  467b7c:	1080004c 	andi	r2,r2,1
  467b80:	e0fffb17 	ldw	r3,-20(fp)
  467b84:	1884b03a 	or	r2,r3,r2
  467b88:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
  467b8c:	e0bffb17 	ldw	r2,-20(fp)
  467b90:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
  467b94:	e0bff617 	ldw	r2,-40(fp)
}
  467b98:	e037883a 	mov	sp,fp
  467b9c:	dfc00117 	ldw	ra,4(sp)
  467ba0:	df000017 	ldw	fp,0(sp)
  467ba4:	dec00204 	addi	sp,sp,8
  467ba8:	f800283a 	ret

00467bac <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  467bac:	defffe04 	addi	sp,sp,-8
  467bb0:	dfc00115 	stw	ra,4(sp)
  467bb4:	df000015 	stw	fp,0(sp)
  467bb8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  467bbc:	008011f4 	movhi	r2,71
  467bc0:	109f4204 	addi	r2,r2,32008
  467bc4:	10800017 	ldw	r2,0(r2)
  467bc8:	10000526 	beq	r2,zero,467be0 <alt_get_errno+0x34>
  467bcc:	008011f4 	movhi	r2,71
  467bd0:	109f4204 	addi	r2,r2,32008
  467bd4:	10800017 	ldw	r2,0(r2)
  467bd8:	103ee83a 	callr	r2
  467bdc:	00000206 	br	467be8 <alt_get_errno+0x3c>
  467be0:	00801234 	movhi	r2,72
  467be4:	10a63404 	addi	r2,r2,-26416
}
  467be8:	e037883a 	mov	sp,fp
  467bec:	dfc00117 	ldw	ra,4(sp)
  467bf0:	df000017 	ldw	fp,0(sp)
  467bf4:	dec00204 	addi	sp,sp,8
  467bf8:	f800283a 	ret

00467bfc <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
  467bfc:	deffed04 	addi	sp,sp,-76
  467c00:	dfc01215 	stw	ra,72(sp)
  467c04:	df001115 	stw	fp,68(sp)
  467c08:	df001104 	addi	fp,sp,68
  467c0c:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  467c10:	e0bfff17 	ldw	r2,-4(fp)
  467c14:	10000716 	blt	r2,zero,467c34 <isatty+0x38>
  467c18:	e13fff17 	ldw	r4,-4(fp)
  467c1c:	01400304 	movi	r5,12
  467c20:	04675f00 	call	4675f0 <__mulsi3>
  467c24:	00c011f4 	movhi	r3,71
  467c28:	18dab304 	addi	r3,r3,27340
  467c2c:	10c5883a 	add	r2,r2,r3
  467c30:	00000106 	br	467c38 <isatty+0x3c>
  467c34:	0005883a 	mov	r2,zero
  467c38:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
  467c3c:	e0bfef17 	ldw	r2,-68(fp)
  467c40:	10000e26 	beq	r2,zero,467c7c <isatty+0x80>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
  467c44:	e0bfef17 	ldw	r2,-68(fp)
  467c48:	10800017 	ldw	r2,0(r2)
  467c4c:	10800817 	ldw	r2,32(r2)
  467c50:	1000021e 	bne	r2,zero,467c5c <isatty+0x60>
    {
      return 1;
  467c54:	00800044 	movi	r2,1
  467c58:	00000c06 	br	467c8c <isatty+0x90>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
  467c5c:	e0bff004 	addi	r2,fp,-64
  467c60:	e13fff17 	ldw	r4,-4(fp)
  467c64:	100b883a 	mov	r5,r2
  467c68:	04677b00 	call	4677b0 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
  467c6c:	e0bff117 	ldw	r2,-60(fp)
  467c70:	10880020 	cmpeqi	r2,r2,8192
  467c74:	10803fcc 	andi	r2,r2,255
  467c78:	00000406 	br	467c8c <isatty+0x90>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
  467c7c:	0467bac0 	call	467bac <alt_get_errno>
  467c80:	00c01444 	movi	r3,81
  467c84:	10c00015 	stw	r3,0(r2)
    return 0;
  467c88:	0005883a 	mov	r2,zero
  }
}
  467c8c:	e037883a 	mov	sp,fp
  467c90:	dfc00117 	ldw	ra,4(sp)
  467c94:	df000017 	ldw	fp,0(sp)
  467c98:	dec00204 	addi	sp,sp,8
  467c9c:	f800283a 	ret

00467ca0 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  467ca0:	defffc04 	addi	sp,sp,-16
  467ca4:	df000315 	stw	fp,12(sp)
  467ca8:	df000304 	addi	fp,sp,12
  467cac:	e13ffd15 	stw	r4,-12(fp)
  467cb0:	e17ffe15 	stw	r5,-8(fp)
  467cb4:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
  467cb8:	e0fffe17 	ldw	r3,-8(fp)
  467cbc:	e0bffd17 	ldw	r2,-12(fp)
  467cc0:	18800e26 	beq	r3,r2,467cfc <alt_load_section+0x5c>
  {
    while( to != end )
  467cc4:	00000a06 	br	467cf0 <alt_load_section+0x50>
    {
      *to++ = *from++;
  467cc8:	e0bffd17 	ldw	r2,-12(fp)
  467ccc:	10c00017 	ldw	r3,0(r2)
  467cd0:	e0bffe17 	ldw	r2,-8(fp)
  467cd4:	10c00015 	stw	r3,0(r2)
  467cd8:	e0bffe17 	ldw	r2,-8(fp)
  467cdc:	10800104 	addi	r2,r2,4
  467ce0:	e0bffe15 	stw	r2,-8(fp)
  467ce4:	e0bffd17 	ldw	r2,-12(fp)
  467ce8:	10800104 	addi	r2,r2,4
  467cec:	e0bffd15 	stw	r2,-12(fp)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
  467cf0:	e0fffe17 	ldw	r3,-8(fp)
  467cf4:	e0bfff17 	ldw	r2,-4(fp)
  467cf8:	18bff31e 	bne	r3,r2,467cc8 <alt_load_section+0x28>
    {
      *to++ = *from++;
    }
  }
}
  467cfc:	e037883a 	mov	sp,fp
  467d00:	df000017 	ldw	fp,0(sp)
  467d04:	dec00104 	addi	sp,sp,4
  467d08:	f800283a 	ret

00467d0c <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
  467d0c:	defffe04 	addi	sp,sp,-8
  467d10:	dfc00115 	stw	ra,4(sp)
  467d14:	df000015 	stw	fp,0(sp)
  467d18:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
  467d1c:	010011f4 	movhi	r4,71
  467d20:	211f6804 	addi	r4,r4,32160
  467d24:	014011f4 	movhi	r5,71
  467d28:	2958a704 	addi	r5,r5,25244
  467d2c:	018011f4 	movhi	r6,71
  467d30:	319f6804 	addi	r6,r6,32160
  467d34:	0467ca00 	call	467ca0 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
  467d38:	010011b4 	movhi	r4,70
  467d3c:	21100804 	addi	r4,r4,16416
  467d40:	014011b4 	movhi	r5,70
  467d44:	29500804 	addi	r5,r5,16416
  467d48:	018011b4 	movhi	r6,70
  467d4c:	31907804 	addi	r6,r6,16864
  467d50:	0467ca00 	call	467ca0 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
  467d54:	010011f4 	movhi	r4,71
  467d58:	2117f104 	addi	r4,r4,24516
  467d5c:	014011f4 	movhi	r5,71
  467d60:	2957f104 	addi	r5,r5,24516
  467d64:	018011f4 	movhi	r6,71
  467d68:	3198a704 	addi	r6,r6,25244
  467d6c:	0467ca00 	call	467ca0 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  467d70:	04739280 	call	473928 <alt_dcache_flush_all>
  alt_icache_flush_all();
  467d74:	0473b7c0 	call	473b7c <alt_icache_flush_all>
}
  467d78:	e037883a 	mov	sp,fp
  467d7c:	dfc00117 	ldw	ra,4(sp)
  467d80:	df000017 	ldw	fp,0(sp)
  467d84:	dec00204 	addi	sp,sp,8
  467d88:	f800283a 	ret

00467d8c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  467d8c:	defffe04 	addi	sp,sp,-8
  467d90:	dfc00115 	stw	ra,4(sp)
  467d94:	df000015 	stw	fp,0(sp)
  467d98:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  467d9c:	008011f4 	movhi	r2,71
  467da0:	109f4204 	addi	r2,r2,32008
  467da4:	10800017 	ldw	r2,0(r2)
  467da8:	10000526 	beq	r2,zero,467dc0 <alt_get_errno+0x34>
  467dac:	008011f4 	movhi	r2,71
  467db0:	109f4204 	addi	r2,r2,32008
  467db4:	10800017 	ldw	r2,0(r2)
  467db8:	103ee83a 	callr	r2
  467dbc:	00000206 	br	467dc8 <alt_get_errno+0x3c>
  467dc0:	00801234 	movhi	r2,72
  467dc4:	10a63404 	addi	r2,r2,-26416
}
  467dc8:	e037883a 	mov	sp,fp
  467dcc:	dfc00117 	ldw	ra,4(sp)
  467dd0:	df000017 	ldw	fp,0(sp)
  467dd4:	dec00204 	addi	sp,sp,8
  467dd8:	f800283a 	ret

00467ddc <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
  467ddc:	defff904 	addi	sp,sp,-28
  467de0:	dfc00615 	stw	ra,24(sp)
  467de4:	df000515 	stw	fp,20(sp)
  467de8:	df000504 	addi	fp,sp,20
  467dec:	e13ffd15 	stw	r4,-12(fp)
  467df0:	e17ffe15 	stw	r5,-8(fp)
  467df4:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
  467df8:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  467dfc:	e0bffd17 	ldw	r2,-12(fp)
  467e00:	10000716 	blt	r2,zero,467e20 <lseek+0x44>
  467e04:	e13ffd17 	ldw	r4,-12(fp)
  467e08:	01400304 	movi	r5,12
  467e0c:	04675f00 	call	4675f0 <__mulsi3>
  467e10:	00c011f4 	movhi	r3,71
  467e14:	18dab304 	addi	r3,r3,27340
  467e18:	10c5883a 	add	r2,r2,r3
  467e1c:	00000106 	br	467e24 <lseek+0x48>
  467e20:	0005883a 	mov	r2,zero
  467e24:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
  467e28:	e0bffc17 	ldw	r2,-16(fp)
  467e2c:	10001026 	beq	r2,zero,467e70 <lseek+0x94>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
  467e30:	e0bffc17 	ldw	r2,-16(fp)
  467e34:	10800017 	ldw	r2,0(r2)
  467e38:	10800717 	ldw	r2,28(r2)
  467e3c:	10000926 	beq	r2,zero,467e64 <lseek+0x88>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
  467e40:	e0bffc17 	ldw	r2,-16(fp)
  467e44:	10800017 	ldw	r2,0(r2)
  467e48:	10800717 	ldw	r2,28(r2)
  467e4c:	e13ffc17 	ldw	r4,-16(fp)
  467e50:	e17ffe17 	ldw	r5,-8(fp)
  467e54:	e1bfff17 	ldw	r6,-4(fp)
  467e58:	103ee83a 	callr	r2
  467e5c:	e0bffb15 	stw	r2,-20(fp)
  467e60:	00000506 	br	467e78 <lseek+0x9c>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
  467e64:	00bfde84 	movi	r2,-134
  467e68:	e0bffb15 	stw	r2,-20(fp)
  467e6c:	00000206 	br	467e78 <lseek+0x9c>
    }
  }
  else  
  {
    rc = -EBADFD;
  467e70:	00bfebc4 	movi	r2,-81
  467e74:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
  467e78:	e0bffb17 	ldw	r2,-20(fp)
  467e7c:	1000060e 	bge	r2,zero,467e98 <lseek+0xbc>
  {
    ALT_ERRNO = -rc;
  467e80:	0467d8c0 	call	467d8c <alt_get_errno>
  467e84:	e0fffb17 	ldw	r3,-20(fp)
  467e88:	00c7c83a 	sub	r3,zero,r3
  467e8c:	10c00015 	stw	r3,0(r2)
    rc = -1;
  467e90:	00bfffc4 	movi	r2,-1
  467e94:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
  467e98:	e0bffb17 	ldw	r2,-20(fp)
}
  467e9c:	e037883a 	mov	sp,fp
  467ea0:	dfc00117 	ldw	ra,4(sp)
  467ea4:	df000017 	ldw	fp,0(sp)
  467ea8:	dec00204 	addi	sp,sp,8
  467eac:	f800283a 	ret

00467eb0 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
  467eb0:	defffb04 	addi	sp,sp,-20
  467eb4:	dfc00415 	stw	ra,16(sp)
  467eb8:	df000315 	stw	fp,12(sp)
  467ebc:	df000304 	addi	fp,sp,12
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
  467ec0:	0009883a 	mov	r4,zero
  467ec4:	047226c0 	call	47226c <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
  467ec8:	04691640 	call	469164 <OSInit>
  467ecc:	01000044 	movi	r4,1
  467ed0:	046ec440 	call	46ec44 <OSSemCreate>
  467ed4:	00c01234 	movhi	r3,72
  467ed8:	18e63b04 	addi	r3,r3,-26388
  467edc:	18800015 	stw	r2,0(r3)
  467ee0:	01000044 	movi	r4,1
  467ee4:	046ec440 	call	46ec44 <OSSemCreate>
  467ee8:	00c01234 	movhi	r3,72
  467eec:	18e63d04 	addi	r3,r3,-26380
  467ef0:	18800015 	stw	r2,0(r3)
  467ef4:	00801234 	movhi	r2,72
  467ef8:	10a63504 	addi	r2,r2,-26412
  467efc:	e0bffe15 	stw	r2,-8(fp)
  467f00:	00800044 	movi	r2,1
  467f04:	e0bfff0d 	sth	r2,-4(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
  467f08:	e0bfff0b 	ldhu	r2,-4(fp)
  467f0c:	1009883a 	mov	r4,r2
  467f10:	046ec440 	call	46ec44 <OSSemCreate>
  467f14:	e0fffe17 	ldw	r3,-8(fp)
  467f18:	18800015 	stw	r2,0(r3)
  return *sem ? 0 : -1;
  467f1c:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
  467f20:	04722a00 	call	4722a0 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
  467f24:	010011f4 	movhi	r4,71
  467f28:	21180704 	addi	r4,r4,24604
  467f2c:	014011f4 	movhi	r5,71
  467f30:	29580704 	addi	r5,r5,24604
  467f34:	018011f4 	movhi	r6,71
  467f38:	31980704 	addi	r6,r6,24604
  467f3c:	0473c8c0 	call	473c8c <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
  467f40:	0473a340 	call	473a34 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
  467f44:	010011f4 	movhi	r4,71
  467f48:	210ea404 	addi	r4,r4,14992
  467f4c:	04749040 	call	474904 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
  467f50:	d1270417 	ldw	r4,-25584(gp)
  467f54:	d0e70517 	ldw	r3,-25580(gp)
  467f58:	d0a70617 	ldw	r2,-25576(gp)
  467f5c:	180b883a 	mov	r5,r3
  467f60:	100d883a 	mov	r6,r2
  467f64:	04644d80 	call	4644d8 <main>
  467f68:	e0bffd15 	stw	r2,-12(fp)
  close(STDOUT_FILENO);
  467f6c:	01000044 	movi	r4,1
  467f70:	04676680 	call	467668 <close>
  exit (result);
  467f74:	e13ffd17 	ldw	r4,-12(fp)
  467f78:	04749180 	call	474918 <exit>

00467f7c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  467f7c:	defffe04 	addi	sp,sp,-8
  467f80:	dfc00115 	stw	ra,4(sp)
  467f84:	df000015 	stw	fp,0(sp)
  467f88:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  467f8c:	008011f4 	movhi	r2,71
  467f90:	109f4204 	addi	r2,r2,32008
  467f94:	10800017 	ldw	r2,0(r2)
  467f98:	10000526 	beq	r2,zero,467fb0 <alt_get_errno+0x34>
  467f9c:	008011f4 	movhi	r2,71
  467fa0:	109f4204 	addi	r2,r2,32008
  467fa4:	10800017 	ldw	r2,0(r2)
  467fa8:	103ee83a 	callr	r2
  467fac:	00000206 	br	467fb8 <alt_get_errno+0x3c>
  467fb0:	00801234 	movhi	r2,72
  467fb4:	10a63404 	addi	r2,r2,-26416
}
  467fb8:	e037883a 	mov	sp,fp
  467fbc:	dfc00117 	ldw	ra,4(sp)
  467fc0:	df000017 	ldw	fp,0(sp)
  467fc4:	dec00204 	addi	sp,sp,8
  467fc8:	f800283a 	ret

00467fcc <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
  467fcc:	defff904 	addi	sp,sp,-28
  467fd0:	dfc00615 	stw	ra,24(sp)
  467fd4:	df000515 	stw	fp,20(sp)
  467fd8:	df000504 	addi	fp,sp,20
  467fdc:	e13ffd15 	stw	r4,-12(fp)
  467fe0:	e17ffe15 	stw	r5,-8(fp)
  467fe4:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  467fe8:	e0bffd17 	ldw	r2,-12(fp)
  467fec:	10000716 	blt	r2,zero,46800c <read+0x40>
  467ff0:	e13ffd17 	ldw	r4,-12(fp)
  467ff4:	01400304 	movi	r5,12
  467ff8:	04675f00 	call	4675f0 <__mulsi3>
  467ffc:	00c011f4 	movhi	r3,71
  468000:	18dab304 	addi	r3,r3,27340
  468004:	10c5883a 	add	r2,r2,r3
  468008:	00000106 	br	468010 <read+0x44>
  46800c:	0005883a 	mov	r2,zero
  468010:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
  468014:	e0bffb17 	ldw	r2,-20(fp)
  468018:	10002026 	beq	r2,zero,46809c <read+0xd0>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
  46801c:	e0bffb17 	ldw	r2,-20(fp)
  468020:	10800217 	ldw	r2,8(r2)
  468024:	108000cc 	andi	r2,r2,3
  468028:	10800060 	cmpeqi	r2,r2,1
  46802c:	1000171e 	bne	r2,zero,46808c <read+0xc0>
        (fd->dev->read))
  468030:	e0bffb17 	ldw	r2,-20(fp)
  468034:	10800017 	ldw	r2,0(r2)
  468038:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
  46803c:	10001326 	beq	r2,zero,46808c <read+0xc0>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
  468040:	e0bffb17 	ldw	r2,-20(fp)
  468044:	10800017 	ldw	r2,0(r2)
  468048:	10c00517 	ldw	r3,20(r2)
  46804c:	e0bfff17 	ldw	r2,-4(fp)
  468050:	e13ffb17 	ldw	r4,-20(fp)
  468054:	e17ffe17 	ldw	r5,-8(fp)
  468058:	100d883a 	mov	r6,r2
  46805c:	183ee83a 	callr	r3
  468060:	e0bffc15 	stw	r2,-16(fp)
  468064:	e0bffc17 	ldw	r2,-16(fp)
  468068:	1000060e 	bge	r2,zero,468084 <read+0xb8>
        {
          ALT_ERRNO = -rval;
  46806c:	0467f7c0 	call	467f7c <alt_get_errno>
  468070:	e0fffc17 	ldw	r3,-16(fp)
  468074:	00c7c83a 	sub	r3,zero,r3
  468078:	10c00015 	stw	r3,0(r2)
          return -1;
  46807c:	00bfffc4 	movi	r2,-1
  468080:	00000a06 	br	4680ac <read+0xe0>
        }
        return rval;
  468084:	e0bffc17 	ldw	r2,-16(fp)
  468088:	00000806 	br	4680ac <read+0xe0>
      }
      else
      {
        ALT_ERRNO = EACCES;
  46808c:	0467f7c0 	call	467f7c <alt_get_errno>
  468090:	00c00344 	movi	r3,13
  468094:	10c00015 	stw	r3,0(r2)
  468098:	00000306 	br	4680a8 <read+0xdc>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
  46809c:	0467f7c0 	call	467f7c <alt_get_errno>
  4680a0:	00c01444 	movi	r3,81
  4680a4:	10c00015 	stw	r3,0(r2)
  }
  return -1;
  4680a8:	00bfffc4 	movi	r2,-1
}
  4680ac:	e037883a 	mov	sp,fp
  4680b0:	dfc00117 	ldw	ra,4(sp)
  4680b4:	df000017 	ldw	fp,0(sp)
  4680b8:	dec00204 	addi	sp,sp,8
  4680bc:	f800283a 	ret

004680c0 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
  4680c0:	defffc04 	addi	sp,sp,-16
  4680c4:	dfc00315 	stw	ra,12(sp)
  4680c8:	df000215 	stw	fp,8(sp)
  4680cc:	dc000115 	stw	r16,4(sp)
  4680d0:	df000104 	addi	fp,sp,4
  4680d4:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
  4680d8:	e0bfff17 	ldw	r2,-4(fp)
  4680dc:	108000d0 	cmplti	r2,r2,3
  4680e0:	1000111e 	bne	r2,zero,468128 <alt_release_fd+0x68>
  {
    alt_fd_list[fd].fd_flags = 0;
  4680e4:	040011f4 	movhi	r16,71
  4680e8:	841ab304 	addi	r16,r16,27340
  4680ec:	e0bfff17 	ldw	r2,-4(fp)
  4680f0:	1009883a 	mov	r4,r2
  4680f4:	01400304 	movi	r5,12
  4680f8:	04675f00 	call	4675f0 <__mulsi3>
  4680fc:	8085883a 	add	r2,r16,r2
  468100:	10800204 	addi	r2,r2,8
  468104:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
  468108:	040011f4 	movhi	r16,71
  46810c:	841ab304 	addi	r16,r16,27340
  468110:	e0bfff17 	ldw	r2,-4(fp)
  468114:	1009883a 	mov	r4,r2
  468118:	01400304 	movi	r5,12
  46811c:	04675f00 	call	4675f0 <__mulsi3>
  468120:	8085883a 	add	r2,r16,r2
  468124:	10000015 	stw	zero,0(r2)
  }
}
  468128:	e037883a 	mov	sp,fp
  46812c:	dfc00217 	ldw	ra,8(sp)
  468130:	df000117 	ldw	fp,4(sp)
  468134:	dc000017 	ldw	r16,0(sp)
  468138:	dec00304 	addi	sp,sp,12
  46813c:	f800283a 	ret

00468140 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
  468140:	defff704 	addi	sp,sp,-36
  468144:	df000815 	stw	fp,32(sp)
  468148:	df000804 	addi	fp,sp,32
  46814c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  468150:	0005303a 	rdctl	r2,status
  468154:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  468158:	e0fffa17 	ldw	r3,-24(fp)
  46815c:	00bfff84 	movi	r2,-2
  468160:	1884703a 	and	r2,r3,r2
  468164:	1001703a 	wrctl	status,r2
  
  return context;
  468168:	e0bffa17 	ldw	r2,-24(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
  46816c:	e0bff815 	stw	r2,-32(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
  468170:	d0a01117 	ldw	r2,-32700(gp)
  468174:	10c000c4 	addi	r3,r2,3
  468178:	00bfff04 	movi	r2,-4
  46817c:	1884703a 	and	r2,r3,r2
  468180:	d0a01115 	stw	r2,-32700(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
  468184:	d0e01117 	ldw	r3,-32700(gp)
  468188:	e0bfff17 	ldw	r2,-4(fp)
  46818c:	1885883a 	add	r2,r3,r2
  468190:	00c01274 	movhi	r3,73
  468194:	18d80004 	addi	r3,r3,24576
  468198:	1880112e 	bgeu	r3,r2,4681e0 <sbrk+0xa0>
  46819c:	e0bff817 	ldw	r2,-32(fp)
  4681a0:	e0bffb15 	stw	r2,-20(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  4681a4:	0005303a 	rdctl	r2,status
  4681a8:	e0bffc15 	stw	r2,-16(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  4681ac:	e0fffc17 	ldw	r3,-16(fp)
  4681b0:	00bfff84 	movi	r2,-2
  4681b4:	1884703a 	and	r2,r3,r2
  4681b8:	e0bffc15 	stw	r2,-16(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  4681bc:	e0bffb17 	ldw	r2,-20(fp)
  4681c0:	1080004c 	andi	r2,r2,1
  4681c4:	e0fffc17 	ldw	r3,-16(fp)
  4681c8:	1884b03a 	or	r2,r3,r2
  4681cc:	e0bffc15 	stw	r2,-16(fp)
  
  NIOS2_WRITE_STATUS (status);
  4681d0:	e0bffc17 	ldw	r2,-16(fp)
  4681d4:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  4681d8:	00bfffc4 	movi	r2,-1
  4681dc:	00001606 	br	468238 <sbrk+0xf8>
  }
#endif

  prev_heap_end = heap_end; 
  4681e0:	d0a01117 	ldw	r2,-32700(gp)
  4681e4:	e0bff915 	stw	r2,-28(fp)
  heap_end += incr; 
  4681e8:	d0e01117 	ldw	r3,-32700(gp)
  4681ec:	e0bfff17 	ldw	r2,-4(fp)
  4681f0:	1885883a 	add	r2,r3,r2
  4681f4:	d0a01115 	stw	r2,-32700(gp)
  4681f8:	e0bff817 	ldw	r2,-32(fp)
  4681fc:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  468200:	0005303a 	rdctl	r2,status
  468204:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  468208:	e0fffe17 	ldw	r3,-8(fp)
  46820c:	00bfff84 	movi	r2,-2
  468210:	1884703a 	and	r2,r3,r2
  468214:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  468218:	e0bffd17 	ldw	r2,-12(fp)
  46821c:	1080004c 	andi	r2,r2,1
  468220:	e0fffe17 	ldw	r3,-8(fp)
  468224:	1884b03a 	or	r2,r3,r2
  468228:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
  46822c:	e0bffe17 	ldw	r2,-8(fp)
  468230:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
  468234:	e0bff917 	ldw	r2,-28(fp)
} 
  468238:	e037883a 	mov	sp,fp
  46823c:	df000017 	ldw	fp,0(sp)
  468240:	dec00104 	addi	sp,sp,4
  468244:	f800283a 	ret

00468248 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  468248:	defffe04 	addi	sp,sp,-8
  46824c:	dfc00115 	stw	ra,4(sp)
  468250:	df000015 	stw	fp,0(sp)
  468254:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  468258:	008011f4 	movhi	r2,71
  46825c:	109f4204 	addi	r2,r2,32008
  468260:	10800017 	ldw	r2,0(r2)
  468264:	10000526 	beq	r2,zero,46827c <alt_get_errno+0x34>
  468268:	008011f4 	movhi	r2,71
  46826c:	109f4204 	addi	r2,r2,32008
  468270:	10800017 	ldw	r2,0(r2)
  468274:	103ee83a 	callr	r2
  468278:	00000206 	br	468284 <alt_get_errno+0x3c>
  46827c:	00801234 	movhi	r2,72
  468280:	10a63404 	addi	r2,r2,-26416
}
  468284:	e037883a 	mov	sp,fp
  468288:	dfc00117 	ldw	ra,4(sp)
  46828c:	df000017 	ldw	fp,0(sp)
  468290:	dec00204 	addi	sp,sp,8
  468294:	f800283a 	ret

00468298 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
  468298:	defff904 	addi	sp,sp,-28
  46829c:	dfc00615 	stw	ra,24(sp)
  4682a0:	df000515 	stw	fp,20(sp)
  4682a4:	df000504 	addi	fp,sp,20
  4682a8:	e13ffd15 	stw	r4,-12(fp)
  4682ac:	e17ffe15 	stw	r5,-8(fp)
  4682b0:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  4682b4:	e0bffd17 	ldw	r2,-12(fp)
  4682b8:	10000716 	blt	r2,zero,4682d8 <write+0x40>
  4682bc:	e13ffd17 	ldw	r4,-12(fp)
  4682c0:	01400304 	movi	r5,12
  4682c4:	04675f00 	call	4675f0 <__mulsi3>
  4682c8:	00c011f4 	movhi	r3,71
  4682cc:	18dab304 	addi	r3,r3,27340
  4682d0:	10c5883a 	add	r2,r2,r3
  4682d4:	00000106 	br	4682dc <write+0x44>
  4682d8:	0005883a 	mov	r2,zero
  4682dc:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
  4682e0:	e0bffb17 	ldw	r2,-20(fp)
  4682e4:	10001f26 	beq	r2,zero,468364 <write+0xcc>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
  4682e8:	e0bffb17 	ldw	r2,-20(fp)
  4682ec:	10800217 	ldw	r2,8(r2)
  4682f0:	108000cc 	andi	r2,r2,3
  4682f4:	10001726 	beq	r2,zero,468354 <write+0xbc>
  4682f8:	e0bffb17 	ldw	r2,-20(fp)
  4682fc:	10800017 	ldw	r2,0(r2)
  468300:	10800617 	ldw	r2,24(r2)
  468304:	10001326 	beq	r2,zero,468354 <write+0xbc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
  468308:	e0bffb17 	ldw	r2,-20(fp)
  46830c:	10800017 	ldw	r2,0(r2)
  468310:	10c00617 	ldw	r3,24(r2)
  468314:	e0bfff17 	ldw	r2,-4(fp)
  468318:	e13ffb17 	ldw	r4,-20(fp)
  46831c:	e17ffe17 	ldw	r5,-8(fp)
  468320:	100d883a 	mov	r6,r2
  468324:	183ee83a 	callr	r3
  468328:	e0bffc15 	stw	r2,-16(fp)
  46832c:	e0bffc17 	ldw	r2,-16(fp)
  468330:	1000060e 	bge	r2,zero,46834c <write+0xb4>
      {
        ALT_ERRNO = -rval;
  468334:	04682480 	call	468248 <alt_get_errno>
  468338:	e0fffc17 	ldw	r3,-16(fp)
  46833c:	00c7c83a 	sub	r3,zero,r3
  468340:	10c00015 	stw	r3,0(r2)
        return -1;
  468344:	00bfffc4 	movi	r2,-1
  468348:	00000a06 	br	468374 <write+0xdc>
      }
      return rval;
  46834c:	e0bffc17 	ldw	r2,-16(fp)
  468350:	00000806 	br	468374 <write+0xdc>
    }
    else
    {
      ALT_ERRNO = EACCES;
  468354:	04682480 	call	468248 <alt_get_errno>
  468358:	00c00344 	movi	r3,13
  46835c:	10c00015 	stw	r3,0(r2)
  468360:	00000306 	br	468370 <write+0xd8>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
  468364:	04682480 	call	468248 <alt_get_errno>
  468368:	00c01444 	movi	r3,81
  46836c:	10c00015 	stw	r3,0(r2)
  }
  return -1;
  468370:	00bfffc4 	movi	r2,-1
}
  468374:	e037883a 	mov	sp,fp
  468378:	dfc00117 	ldw	ra,4(sp)
  46837c:	df000017 	ldw	fp,0(sp)
  468380:	dec00204 	addi	sp,sp,8
  468384:	f800283a 	ret

00468388 <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
  468388:	deffdf04 	addi	sp,sp,-132
  46838c:	dfc02015 	stw	ra,128(sp)
  468390:	df001f15 	stw	fp,124(sp)
  468394:	df001f04 	addi	fp,sp,124
  468398:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  46839c:	e0bfe204 	addi	r2,fp,-120
  4683a0:	01003fc4 	movi	r4,255
  4683a4:	100b883a 	mov	r5,r2
  4683a8:	04717800 	call	471780 <OSTaskQuery>
  4683ac:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
  4683b0:	e0bffe83 	ldbu	r2,-6(fp)
  4683b4:	10803fcc 	andi	r2,r2,255
  4683b8:	10001c1e 	bne	r2,zero,46842c <__env_lock+0xa4>
    return;

  id = tcb.OSTCBPrio;
  4683bc:	e0bfee83 	ldbu	r2,-70(fp)
  4683c0:	10803fcc 	andi	r2,r2,255
  4683c4:	e0bfe115 	stw	r2,-124(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
  4683c8:	d0e70817 	ldw	r3,-25568(gp)
  4683cc:	e0bffd04 	addi	r2,fp,-12
  4683d0:	1809883a 	mov	r4,r3
  4683d4:	100b883a 	mov	r5,r2
  4683d8:	046f6e00 	call	46f6e0 <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
  4683dc:	e0bffe43 	ldbu	r2,-7(fp)
  4683e0:	10803fcc 	andi	r2,r2,255
  4683e4:	10000726 	beq	r2,zero,468404 <__env_lock+0x7c>
  4683e8:	d0a01217 	ldw	r2,-32696(gp)
  4683ec:	e0ffe117 	ldw	r3,-124(fp)
  4683f0:	1880041e 	bne	r3,r2,468404 <__env_lock+0x7c>
  {
    /* we do; just count the recursion */

    locks++;
  4683f4:	d0a70717 	ldw	r2,-25572(gp)
  4683f8:	10800044 	addi	r2,r2,1
  4683fc:	d0a70715 	stw	r2,-25572(gp)
  468400:	00000a06 	br	46842c <__env_lock+0xa4>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
  468404:	d0e70817 	ldw	r3,-25568(gp)
  468408:	e0bffe84 	addi	r2,fp,-6
  46840c:	1809883a 	mov	r4,r3
  468410:	000b883a 	mov	r5,zero
  468414:	100d883a 	mov	r6,r2
  468418:	046f0900 	call	46f090 <OSSemPend>
    locks  = 1;
  46841c:	00800044 	movi	r2,1
  468420:	d0a70715 	stw	r2,-25572(gp)
    lockid = id;
  468424:	e0bfe117 	ldw	r2,-124(fp)
  468428:	d0a01215 	stw	r2,-32696(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
  46842c:	e037883a 	mov	sp,fp
  468430:	dfc00117 	ldw	ra,4(sp)
  468434:	df000017 	ldw	fp,0(sp)
  468438:	dec00204 	addi	sp,sp,8
  46843c:	f800283a 	ret

00468440 <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
  468440:	defffd04 	addi	sp,sp,-12
  468444:	dfc00215 	stw	ra,8(sp)
  468448:	df000115 	stw	fp,4(sp)
  46844c:	df000104 	addi	fp,sp,4
  468450:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
  468454:	d0a70717 	ldw	r2,-25572(gp)
  468458:	10000b26 	beq	r2,zero,468488 <__env_unlock+0x48>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
  46845c:	d0a70717 	ldw	r2,-25572(gp)
  468460:	10bfffc4 	addi	r2,r2,-1
  468464:	d0a70715 	stw	r2,-25572(gp)
  468468:	d0a70717 	ldw	r2,-25572(gp)
  46846c:	1000071e 	bne	r2,zero,46848c <__env_unlock+0x4c>
  {
    lockid = -1;
  468470:	00bfffc4 	movi	r2,-1
  468474:	d0a01215 	stw	r2,-32696(gp)
    OSSemPost( alt_envsem );
  468478:	d0a70817 	ldw	r2,-25568(gp)
  46847c:	1009883a 	mov	r4,r2
  468480:	046f54c0 	call	46f54c <OSSemPost>
  468484:	00000106 	br	46848c <__env_unlock+0x4c>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
    return;
  468488:	0001883a 	nop
  {
    lockid = -1;
    OSSemPost( alt_envsem );
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
  46848c:	e037883a 	mov	sp,fp
  468490:	dfc00117 	ldw	ra,4(sp)
  468494:	df000017 	ldw	fp,0(sp)
  468498:	dec00204 	addi	sp,sp,8
  46849c:	f800283a 	ret

004684a0 <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
  4684a0:	deffd904 	addi	sp,sp,-156
  4684a4:	dfc02615 	stw	ra,152(sp)
  4684a8:	df002515 	stw	fp,148(sp)
  4684ac:	df002504 	addi	fp,sp,148
  4684b0:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
  4684b4:	e03fdb15 	stw	zero,-148(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
  4684b8:	00801234 	movhi	r2,72
  4684bc:	10a63e44 	addi	r2,r2,-26375
  4684c0:	10800003 	ldbu	r2,0(r2)
  4684c4:	10803fcc 	andi	r2,r2,255
  4684c8:	10800058 	cmpnei	r2,r2,1
  4684cc:	10004a1e 	bne	r2,zero,4685f8 <__malloc_lock+0x158>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  4684d0:	e0bfe204 	addi	r2,fp,-120
  4684d4:	01003fc4 	movi	r4,255
  4684d8:	100b883a 	mov	r5,r2
  4684dc:	04717800 	call	471780 <OSTaskQuery>
  4684e0:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
  4684e4:	e0bffe83 	ldbu	r2,-6(fp)
  4684e8:	10803fcc 	andi	r2,r2,255
  4684ec:	1000421e 	bne	r2,zero,4685f8 <__malloc_lock+0x158>
    return;

  id = tcb.OSTCBPrio;
  4684f0:	e0bfee83 	ldbu	r2,-70(fp)
  4684f4:	10803fcc 	andi	r2,r2,255
  4684f8:	e0bfdc15 	stw	r2,-144(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
  4684fc:	d0e70a17 	ldw	r3,-25560(gp)
  468500:	e0bffd04 	addi	r2,fp,-12
  468504:	1809883a 	mov	r4,r3
  468508:	100b883a 	mov	r5,r2
  46850c:	046f6e00 	call	46f6e0 <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  468510:	0005303a 	rdctl	r2,status
  468514:	e0bfdd15 	stw	r2,-140(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  468518:	e0ffdd17 	ldw	r3,-140(fp)
  46851c:	00bfff84 	movi	r2,-2
  468520:	1884703a 	and	r2,r3,r2
  468524:	1001703a 	wrctl	status,r2
  
  return context;
  468528:	e0bfdd17 	ldw	r2,-140(fp)
  
  OS_ENTER_CRITICAL();
  46852c:	e0bfdb15 	stw	r2,-148(fp)

  if( !semdata.OSCnt && id == lockid ) 
  468530:	e0bffd0b 	ldhu	r2,-12(fp)
  468534:	10bfffcc 	andi	r2,r2,65535
  468538:	1000161e 	bne	r2,zero,468594 <__malloc_lock+0xf4>
  46853c:	d0a01317 	ldw	r2,-32692(gp)
  468540:	e0ffdc17 	ldw	r3,-144(fp)
  468544:	1880131e 	bne	r3,r2,468594 <__malloc_lock+0xf4>
  {
    /* we do; just count the recursion */
    locks++;
  468548:	d0a70917 	ldw	r2,-25564(gp)
  46854c:	10800044 	addi	r2,r2,1
  468550:	d0a70915 	stw	r2,-25564(gp)
  468554:	e0bfdb17 	ldw	r2,-148(fp)
  468558:	e0bfde15 	stw	r2,-136(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46855c:	0005303a 	rdctl	r2,status
  468560:	e0bfdf15 	stw	r2,-132(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  468564:	e0ffdf17 	ldw	r3,-132(fp)
  468568:	00bfff84 	movi	r2,-2
  46856c:	1884703a 	and	r2,r3,r2
  468570:	e0bfdf15 	stw	r2,-132(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  468574:	e0bfde17 	ldw	r2,-136(fp)
  468578:	1080004c 	andi	r2,r2,1
  46857c:	e0ffdf17 	ldw	r3,-132(fp)
  468580:	1884b03a 	or	r2,r3,r2
  468584:	e0bfdf15 	stw	r2,-132(fp)
  
  NIOS2_WRITE_STATUS (status);
  468588:	e0bfdf17 	ldw	r2,-132(fp)
  46858c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
  468590:	00001906 	br	4685f8 <__malloc_lock+0x158>
  468594:	e0bfdb17 	ldw	r2,-148(fp)
  468598:	e0bfe015 	stw	r2,-128(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46859c:	0005303a 	rdctl	r2,status
  4685a0:	e0bfe115 	stw	r2,-124(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  4685a4:	e0ffe117 	ldw	r3,-124(fp)
  4685a8:	00bfff84 	movi	r2,-2
  4685ac:	1884703a 	and	r2,r3,r2
  4685b0:	e0bfe115 	stw	r2,-124(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  4685b4:	e0bfe017 	ldw	r2,-128(fp)
  4685b8:	1080004c 	andi	r2,r2,1
  4685bc:	e0ffe117 	ldw	r3,-124(fp)
  4685c0:	1884b03a 	or	r2,r3,r2
  4685c4:	e0bfe115 	stw	r2,-124(fp)
  
  NIOS2_WRITE_STATUS (status);
  4685c8:	e0bfe117 	ldw	r2,-124(fp)
  4685cc:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
  4685d0:	d0e70a17 	ldw	r3,-25560(gp)
  4685d4:	e0bffe84 	addi	r2,fp,-6
  4685d8:	1809883a 	mov	r4,r3
  4685dc:	000b883a 	mov	r5,zero
  4685e0:	100d883a 	mov	r6,r2
  4685e4:	046f0900 	call	46f090 <OSSemPend>
    locks  = 1;
  4685e8:	00800044 	movi	r2,1
  4685ec:	d0a70915 	stw	r2,-25564(gp)
    lockid = id;
  4685f0:	e0bfdc17 	ldw	r2,-144(fp)
  4685f4:	d0a01315 	stw	r2,-32692(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
  4685f8:	e037883a 	mov	sp,fp
  4685fc:	dfc00117 	ldw	ra,4(sp)
  468600:	df000017 	ldw	fp,0(sp)
  468604:	dec00204 	addi	sp,sp,8
  468608:	f800283a 	ret

0046860c <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
  46860c:	defff504 	addi	sp,sp,-44
  468610:	dfc00a15 	stw	ra,40(sp)
  468614:	df000915 	stw	fp,36(sp)
  468618:	df000904 	addi	fp,sp,36
  46861c:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
  468620:	e03ff715 	stw	zero,-36(fp)
#endif 

  if (OSRunning != OS_TRUE)
  468624:	00801234 	movhi	r2,72
  468628:	10a63e44 	addi	r2,r2,-26375
  46862c:	10800003 	ldbu	r2,0(r2)
  468630:	10803fcc 	andi	r2,r2,255
  468634:	10800060 	cmpeqi	r2,r2,1
  468638:	10004426 	beq	r2,zero,46874c <__malloc_unlock+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46863c:	0005303a 	rdctl	r2,status
  468640:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  468644:	e0fff817 	ldw	r3,-32(fp)
  468648:	00bfff84 	movi	r2,-2
  46864c:	1884703a 	and	r2,r3,r2
  468650:	1001703a 	wrctl	status,r2
  
  return context;
  468654:	e0bff817 	ldw	r2,-32(fp)
      return;

  OS_ENTER_CRITICAL();
  468658:	e0bff715 	stw	r2,-36(fp)
  if (locks == 0)
  46865c:	d0a70917 	ldw	r2,-25564(gp)
  468660:	1000101e 	bne	r2,zero,4686a4 <__malloc_unlock+0x98>
  468664:	e0bff717 	ldw	r2,-36(fp)
  468668:	e0bff915 	stw	r2,-28(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46866c:	0005303a 	rdctl	r2,status
  468670:	e0bffa15 	stw	r2,-24(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  468674:	e0fffa17 	ldw	r3,-24(fp)
  468678:	00bfff84 	movi	r2,-2
  46867c:	1884703a 	and	r2,r3,r2
  468680:	e0bffa15 	stw	r2,-24(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  468684:	e0bff917 	ldw	r2,-28(fp)
  468688:	1080004c 	andi	r2,r2,1
  46868c:	e0fffa17 	ldw	r3,-24(fp)
  468690:	1884b03a 	or	r2,r3,r2
  468694:	e0bffa15 	stw	r2,-24(fp)
  
  NIOS2_WRITE_STATUS (status);
  468698:	e0bffa17 	ldw	r2,-24(fp)
  46869c:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
  4686a0:	00002b06 	br	468750 <__malloc_unlock+0x144>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
  4686a4:	d0a70917 	ldw	r2,-25564(gp)
  4686a8:	10bfffc4 	addi	r2,r2,-1
  4686ac:	d0a70915 	stw	r2,-25564(gp)
  4686b0:	d0a70917 	ldw	r2,-25564(gp)
  4686b4:	1000151e 	bne	r2,zero,46870c <__malloc_unlock+0x100>
  {
    lockid = -1;
  4686b8:	00bfffc4 	movi	r2,-1
  4686bc:	d0a01315 	stw	r2,-32692(gp)
  4686c0:	e0bff717 	ldw	r2,-36(fp)
  4686c4:	e0bffb15 	stw	r2,-20(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  4686c8:	0005303a 	rdctl	r2,status
  4686cc:	e0bffc15 	stw	r2,-16(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  4686d0:	e0fffc17 	ldw	r3,-16(fp)
  4686d4:	00bfff84 	movi	r2,-2
  4686d8:	1884703a 	and	r2,r3,r2
  4686dc:	e0bffc15 	stw	r2,-16(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  4686e0:	e0bffb17 	ldw	r2,-20(fp)
  4686e4:	1080004c 	andi	r2,r2,1
  4686e8:	e0fffc17 	ldw	r3,-16(fp)
  4686ec:	1884b03a 	or	r2,r3,r2
  4686f0:	e0bffc15 	stw	r2,-16(fp)
  
  NIOS2_WRITE_STATUS (status);
  4686f4:	e0bffc17 	ldw	r2,-16(fp)
  4686f8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
  4686fc:	d0a70a17 	ldw	r2,-25560(gp)
  468700:	1009883a 	mov	r4,r2
  468704:	046f54c0 	call	46f54c <OSSemPost>
  468708:	00001106 	br	468750 <__malloc_unlock+0x144>
  46870c:	e0bff717 	ldw	r2,-36(fp)
  468710:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  468714:	0005303a 	rdctl	r2,status
  468718:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46871c:	e0fffe17 	ldw	r3,-8(fp)
  468720:	00bfff84 	movi	r2,-2
  468724:	1884703a 	and	r2,r3,r2
  468728:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46872c:	e0bffd17 	ldw	r2,-12(fp)
  468730:	1080004c 	andi	r2,r2,1
  468734:	e0fffe17 	ldw	r3,-8(fp)
  468738:	1884b03a 	or	r2,r3,r2
  46873c:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
  468740:	e0bffe17 	ldw	r2,-8(fp)
  468744:	1001703a 	wrctl	status,r2
  468748:	00000106 	br	468750 <__malloc_unlock+0x144>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif 

  if (OSRunning != OS_TRUE)
      return;
  46874c:	0001883a 	nop
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
  468750:	e037883a 	mov	sp,fp
  468754:	dfc00117 	ldw	ra,4(sp)
  468758:	df000017 	ldw	fp,0(sp)
  46875c:	dec00204 	addi	sp,sp,8
  468760:	f800283a 	ret

00468764 <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
  468764:	defff604 	addi	sp,sp,-40
  468768:	dfc00915 	stw	ra,36(sp)
  46876c:	df000815 	stw	fp,32(sp)
  468770:	df000804 	addi	fp,sp,32
  468774:	e13ffd15 	stw	r4,-12(fp)
  468778:	e17ffe15 	stw	r5,-8(fp)
  46877c:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
  468780:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
  468784:	e0bfff17 	ldw	r2,-4(fp)
  468788:	1000021e 	bne	r2,zero,468794 <OSEventNameGet+0x30>
        return (0);
  46878c:	0005883a 	mov	r2,zero
  468790:	00004206 	br	46889c <OSEventNameGet+0x138>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
  468794:	e0bffd17 	ldw	r2,-12(fp)
  468798:	1000051e 	bne	r2,zero,4687b0 <OSEventNameGet+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
  46879c:	e0bfff17 	ldw	r2,-4(fp)
  4687a0:	00c00104 	movi	r3,4
  4687a4:	10c00005 	stb	r3,0(r2)
        return (0);
  4687a8:	0005883a 	mov	r2,zero
  4687ac:	00003b06 	br	46889c <OSEventNameGet+0x138>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
  4687b0:	e0bffe17 	ldw	r2,-8(fp)
  4687b4:	1000051e 	bne	r2,zero,4687cc <OSEventNameGet+0x68>
        *perr = OS_ERR_PNAME_NULL;
  4687b8:	e0bfff17 	ldw	r2,-4(fp)
  4687bc:	00c00304 	movi	r3,12
  4687c0:	10c00005 	stb	r3,0(r2)
        return (0);
  4687c4:	0005883a 	mov	r2,zero
  4687c8:	00003406 	br	46889c <OSEventNameGet+0x138>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
  4687cc:	d0a71903 	ldbu	r2,-25500(gp)
  4687d0:	10803fcc 	andi	r2,r2,255
  4687d4:	10000526 	beq	r2,zero,4687ec <OSEventNameGet+0x88>
        *perr  = OS_ERR_NAME_GET_ISR;
  4687d8:	e0bfff17 	ldw	r2,-4(fp)
  4687dc:	00c00444 	movi	r3,17
  4687e0:	10c00005 	stb	r3,0(r2)
        return (0);
  4687e4:	0005883a 	mov	r2,zero
  4687e8:	00002c06 	br	46889c <OSEventNameGet+0x138>
    }
    switch (pevent->OSEventType) {
  4687ec:	e0bffd17 	ldw	r2,-12(fp)
  4687f0:	10800003 	ldbu	r2,0(r2)
  4687f4:	10803fcc 	andi	r2,r2,255
  4687f8:	10bfffc4 	addi	r2,r2,-1
  4687fc:	10800128 	cmpgeui	r2,r2,4
  468800:	1000221e 	bne	r2,zero,46888c <OSEventNameGet+0x128>
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
  468804:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  468808:	0005303a 	rdctl	r2,status
  46880c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  468810:	e0fffa17 	ldw	r3,-24(fp)
  468814:	00bfff84 	movi	r2,-2
  468818:	1884703a 	and	r2,r3,r2
  46881c:	1001703a 	wrctl	status,r2
  
  return context;
  468820:	e0bffa17 	ldw	r2,-24(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
  468824:	e0bff815 	stw	r2,-32(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
  468828:	e0bffd17 	ldw	r2,-12(fp)
  46882c:	10800384 	addi	r2,r2,14
  468830:	e13ffe17 	ldw	r4,-8(fp)
  468834:	100b883a 	mov	r5,r2
  468838:	046a6000 	call	46a600 <OS_StrCopy>
  46883c:	e0bff905 	stb	r2,-28(fp)
  468840:	e0bff817 	ldw	r2,-32(fp)
  468844:	e0bffb15 	stw	r2,-20(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  468848:	0005303a 	rdctl	r2,status
  46884c:	e0bffc15 	stw	r2,-16(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  468850:	e0fffc17 	ldw	r3,-16(fp)
  468854:	00bfff84 	movi	r2,-2
  468858:	1884703a 	and	r2,r3,r2
  46885c:	e0bffc15 	stw	r2,-16(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  468860:	e0bffb17 	ldw	r2,-20(fp)
  468864:	1080004c 	andi	r2,r2,1
  468868:	e0fffc17 	ldw	r3,-16(fp)
  46886c:	1884b03a 	or	r2,r3,r2
  468870:	e0bffc15 	stw	r2,-16(fp)
  
  NIOS2_WRITE_STATUS (status);
  468874:	e0bffc17 	ldw	r2,-16(fp)
  468878:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
  46887c:	e0bfff17 	ldw	r2,-4(fp)
  468880:	10000005 	stb	zero,0(r2)
    return (len);
  468884:	e0bff903 	ldbu	r2,-28(fp)
  468888:	00000406 	br	46889c <OSEventNameGet+0x138>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
  46888c:	e0bfff17 	ldw	r2,-4(fp)
  468890:	00c00044 	movi	r3,1
  468894:	10c00005 	stb	r3,0(r2)
             return (0);
  468898:	0005883a 	mov	r2,zero
    OS_ENTER_CRITICAL();
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return (len);
}
  46889c:	e037883a 	mov	sp,fp
  4688a0:	dfc00117 	ldw	ra,4(sp)
  4688a4:	df000017 	ldw	fp,0(sp)
  4688a8:	dec00204 	addi	sp,sp,8
  4688ac:	f800283a 	ret

004688b0 <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
  4688b0:	defff404 	addi	sp,sp,-48
  4688b4:	dfc00b15 	stw	ra,44(sp)
  4688b8:	df000a15 	stw	fp,40(sp)
  4688bc:	df000a04 	addi	fp,sp,40
  4688c0:	e13ffd15 	stw	r4,-12(fp)
  4688c4:	e17ffe15 	stw	r5,-8(fp)
  4688c8:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
  4688cc:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
  4688d0:	e0bfff17 	ldw	r2,-4(fp)
  4688d4:	10005726 	beq	r2,zero,468a34 <OSEventNameSet+0x184>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
  4688d8:	e0bffd17 	ldw	r2,-12(fp)
  4688dc:	1000041e 	bne	r2,zero,4688f0 <OSEventNameSet+0x40>
        *perr = OS_ERR_PEVENT_NULL;
  4688e0:	e0bfff17 	ldw	r2,-4(fp)
  4688e4:	00c00104 	movi	r3,4
  4688e8:	10c00005 	stb	r3,0(r2)
        return;
  4688ec:	00005206 	br	468a38 <OSEventNameSet+0x188>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
  4688f0:	e0bffe17 	ldw	r2,-8(fp)
  4688f4:	1000041e 	bne	r2,zero,468908 <OSEventNameSet+0x58>
        *perr = OS_ERR_PNAME_NULL;
  4688f8:	e0bfff17 	ldw	r2,-4(fp)
  4688fc:	00c00304 	movi	r3,12
  468900:	10c00005 	stb	r3,0(r2)
        return;
  468904:	00004c06 	br	468a38 <OSEventNameSet+0x188>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
  468908:	d0a71903 	ldbu	r2,-25500(gp)
  46890c:	10803fcc 	andi	r2,r2,255
  468910:	10000426 	beq	r2,zero,468924 <OSEventNameSet+0x74>
        *perr = OS_ERR_NAME_SET_ISR;
  468914:	e0bfff17 	ldw	r2,-4(fp)
  468918:	00c00484 	movi	r3,18
  46891c:	10c00005 	stb	r3,0(r2)
        return;
  468920:	00004506 	br	468a38 <OSEventNameSet+0x188>
    }
    switch (pevent->OSEventType) {
  468924:	e0bffd17 	ldw	r2,-12(fp)
  468928:	10800003 	ldbu	r2,0(r2)
  46892c:	10803fcc 	andi	r2,r2,255
  468930:	10bfffc4 	addi	r2,r2,-1
  468934:	10800128 	cmpgeui	r2,r2,4
  468938:	1000101e 	bne	r2,zero,46897c <OSEventNameSet+0xcc>
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
  46893c:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  468940:	0005303a 	rdctl	r2,status
  468944:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  468948:	e0fff817 	ldw	r3,-32(fp)
  46894c:	00bfff84 	movi	r2,-2
  468950:	1884703a 	and	r2,r3,r2
  468954:	1001703a 	wrctl	status,r2
  
  return context;
  468958:	e0bff817 	ldw	r2,-32(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
  46895c:	e0bff615 	stw	r2,-40(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
  468960:	e13ffe17 	ldw	r4,-8(fp)
  468964:	046a67c0 	call	46a67c <OS_StrLen>
  468968:	e0bff705 	stb	r2,-36(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
  46896c:	e0bff703 	ldbu	r2,-36(fp)
  468970:	10800830 	cmpltui	r2,r2,32
  468974:	1000181e 	bne	r2,zero,4689d8 <OSEventNameSet+0x128>
  468978:	00000406 	br	46898c <OSEventNameSet+0xdc>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
  46897c:	e0bfff17 	ldw	r2,-4(fp)
  468980:	00c00044 	movi	r3,1
  468984:	10c00005 	stb	r3,0(r2)
             return;
  468988:	00002b06 	br	468a38 <OSEventNameSet+0x188>
  46898c:	e0bff617 	ldw	r2,-40(fp)
  468990:	e0bff915 	stw	r2,-28(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  468994:	0005303a 	rdctl	r2,status
  468998:	e0bffa15 	stw	r2,-24(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46899c:	e0fffa17 	ldw	r3,-24(fp)
  4689a0:	00bfff84 	movi	r2,-2
  4689a4:	1884703a 	and	r2,r3,r2
  4689a8:	e0bffa15 	stw	r2,-24(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  4689ac:	e0bff917 	ldw	r2,-28(fp)
  4689b0:	1080004c 	andi	r2,r2,1
  4689b4:	e0fffa17 	ldw	r3,-24(fp)
  4689b8:	1884b03a 	or	r2,r3,r2
  4689bc:	e0bffa15 	stw	r2,-24(fp)
  
  NIOS2_WRITE_STATUS (status);
  4689c0:	e0bffa17 	ldw	r2,-24(fp)
  4689c4:	1001703a 	wrctl	status,r2
    }
    OS_ENTER_CRITICAL();
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
  4689c8:	e0bfff17 	ldw	r2,-4(fp)
  4689cc:	00c002c4 	movi	r3,11
  4689d0:	10c00005 	stb	r3,0(r2)
        return;
  4689d4:	00001806 	br	468a38 <OSEventNameSet+0x188>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
  4689d8:	e0bffd17 	ldw	r2,-12(fp)
  4689dc:	10800384 	addi	r2,r2,14
  4689e0:	1009883a 	mov	r4,r2
  4689e4:	e17ffe17 	ldw	r5,-8(fp)
  4689e8:	046a6000 	call	46a600 <OS_StrCopy>
  4689ec:	e0bff617 	ldw	r2,-40(fp)
  4689f0:	e0bffb15 	stw	r2,-20(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  4689f4:	0005303a 	rdctl	r2,status
  4689f8:	e0bffc15 	stw	r2,-16(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  4689fc:	e0fffc17 	ldw	r3,-16(fp)
  468a00:	00bfff84 	movi	r2,-2
  468a04:	1884703a 	and	r2,r3,r2
  468a08:	e0bffc15 	stw	r2,-16(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  468a0c:	e0bffb17 	ldw	r2,-20(fp)
  468a10:	1080004c 	andi	r2,r2,1
  468a14:	e0fffc17 	ldw	r3,-16(fp)
  468a18:	1884b03a 	or	r2,r3,r2
  468a1c:	e0bffc15 	stw	r2,-16(fp)
  
  NIOS2_WRITE_STATUS (status);
  468a20:	e0bffc17 	ldw	r2,-16(fp)
  468a24:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
  468a28:	e0bfff17 	ldw	r2,-4(fp)
  468a2c:	10000005 	stb	zero,0(r2)
  468a30:	00000106 	br	468a38 <OSEventNameSet+0x188>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
  468a34:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
  468a38:	e037883a 	mov	sp,fp
  468a3c:	dfc00117 	ldw	ra,4(sp)
  468a40:	df000017 	ldw	fp,0(sp)
  468a44:	dec00204 	addi	sp,sp,8
  468a48:	f800283a 	ret

00468a4c <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
  468a4c:	deffe804 	addi	sp,sp,-96
  468a50:	dfc01715 	stw	ra,92(sp)
  468a54:	df001615 	stw	fp,88(sp)
  468a58:	df001604 	addi	fp,sp,88
  468a5c:	e13ffc15 	stw	r4,-16(fp)
  468a60:	e17ffd15 	stw	r5,-12(fp)
  468a64:	e1bffe15 	stw	r6,-8(fp)
  468a68:	3805883a 	mov	r2,r7
  468a6c:	e0bfff0d 	sth	r2,-4(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
  468a70:	e03fee15 	stw	zero,-72(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
  468a74:	e0800217 	ldw	r2,8(fp)
  468a78:	1000021e 	bne	r2,zero,468a84 <OSEventPendMulti+0x38>
        return (0);
  468a7c:	0005883a 	mov	r2,zero
  468a80:	0001b306 	br	469150 <OSEventPendMulti+0x704>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
  468a84:	e0bffc17 	ldw	r2,-16(fp)
  468a88:	1000051e 	bne	r2,zero,468aa0 <OSEventPendMulti+0x54>
       *perr =  OS_ERR_PEVENT_NULL;
  468a8c:	e0800217 	ldw	r2,8(fp)
  468a90:	00c00104 	movi	r3,4
  468a94:	10c00005 	stb	r3,0(r2)
        return (0);
  468a98:	0005883a 	mov	r2,zero
  468a9c:	0001ac06 	br	469150 <OSEventPendMulti+0x704>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
  468aa0:	e0bffd17 	ldw	r2,-12(fp)
  468aa4:	1000051e 	bne	r2,zero,468abc <OSEventPendMulti+0x70>
       *perr =  OS_ERR_PEVENT_NULL;
  468aa8:	e0800217 	ldw	r2,8(fp)
  468aac:	00c00104 	movi	r3,4
  468ab0:	10c00005 	stb	r3,0(r2)
        return (0);
  468ab4:	0005883a 	mov	r2,zero
  468ab8:	0001a506 	br	469150 <OSEventPendMulti+0x704>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
  468abc:	e0bffe17 	ldw	r2,-8(fp)
  468ac0:	1000051e 	bne	r2,zero,468ad8 <OSEventPendMulti+0x8c>
       *perr =  OS_ERR_PEVENT_NULL;
  468ac4:	e0800217 	ldw	r2,8(fp)
  468ac8:	00c00104 	movi	r3,4
  468acc:	10c00005 	stb	r3,0(r2)
        return (0);
  468ad0:	0005883a 	mov	r2,zero
  468ad4:	00019e06 	br	469150 <OSEventPendMulti+0x704>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
  468ad8:	e0bffd17 	ldw	r2,-12(fp)
  468adc:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
  468ae0:	e0bffc17 	ldw	r2,-16(fp)
  468ae4:	e0bfea15 	stw	r2,-88(fp)
    pevent      = *pevents;
  468ae8:	e0bfea17 	ldw	r2,-88(fp)
  468aec:	10800017 	ldw	r2,0(r2)
  468af0:	e0bfeb15 	stw	r2,-84(fp)
    while  (pevent != (OS_EVENT *)0) {
  468af4:	00001906 	br	468b5c <OSEventPendMulti+0x110>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
  468af8:	e0bfeb17 	ldw	r2,-84(fp)
  468afc:	10800003 	ldbu	r2,0(r2)
  468b00:	10803fcc 	andi	r2,r2,255
  468b04:	10c000a0 	cmpeqi	r3,r2,2
  468b08:	1800091e 	bne	r3,zero,468b30 <OSEventPendMulti+0xe4>
  468b0c:	10c000e0 	cmpeqi	r3,r2,3
  468b10:	1800091e 	bne	r3,zero,468b38 <OSEventPendMulti+0xec>
  468b14:	10800060 	cmpeqi	r2,r2,1
  468b18:	1000091e 	bne	r2,zero,468b40 <OSEventPendMulti+0xf4>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
  468b1c:	e0800217 	ldw	r2,8(fp)
  468b20:	00c00044 	movi	r3,1
  468b24:	10c00005 	stb	r3,0(r2)
                 return (0);
  468b28:	0005883a 	mov	r2,zero
  468b2c:	00018806 	br	469150 <OSEventPendMulti+0x704>
            case OS_EVENT_TYPE_MBOX:
                 break;
#endif
#if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 break;
  468b30:	0001883a 	nop
  468b34:	00000306 	br	468b44 <OSEventPendMulti+0xf8>
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
#if (OS_SEM_EN  > 0)
            case OS_EVENT_TYPE_SEM:
                 break;
  468b38:	0001883a 	nop
  468b3c:	00000106 	br	468b44 <OSEventPendMulti+0xf8>
#endif
#if (OS_MBOX_EN > 0)
            case OS_EVENT_TYPE_MBOX:
                 break;
  468b40:	0001883a 	nop
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
                 return (0);
        }
        pevents++;
  468b44:	e0bfea17 	ldw	r2,-88(fp)
  468b48:	10800104 	addi	r2,r2,4
  468b4c:	e0bfea15 	stw	r2,-88(fp)
        pevent = *pevents;
  468b50:	e0bfea17 	ldw	r2,-88(fp)
  468b54:	10800017 	ldw	r2,0(r2)
  468b58:	e0bfeb15 	stw	r2,-84(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
  468b5c:	e0bfeb17 	ldw	r2,-84(fp)
  468b60:	103fe51e 	bne	r2,zero,468af8 <OSEventPendMulti+0xac>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
  468b64:	d0a71903 	ldbu	r2,-25500(gp)
  468b68:	10803fcc 	andi	r2,r2,255
  468b6c:	10000526 	beq	r2,zero,468b84 <OSEventPendMulti+0x138>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
  468b70:	e0800217 	ldw	r2,8(fp)
  468b74:	00c00084 	movi	r3,2
  468b78:	10c00005 	stb	r3,0(r2)
        return (0);
  468b7c:	0005883a 	mov	r2,zero
  468b80:	00017306 	br	469150 <OSEventPendMulti+0x704>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
  468b84:	d0a70b03 	ldbu	r2,-25556(gp)
  468b88:	10803fcc 	andi	r2,r2,255
  468b8c:	10000526 	beq	r2,zero,468ba4 <OSEventPendMulti+0x158>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
  468b90:	e0800217 	ldw	r2,8(fp)
  468b94:	00c00344 	movi	r3,13
  468b98:	10c00005 	stb	r3,0(r2)
        return (0);
  468b9c:	0005883a 	mov	r2,zero
  468ba0:	00016b06 	br	469150 <OSEventPendMulti+0x704>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  468ba4:	0005303a 	rdctl	r2,status
  468ba8:	e0bff015 	stw	r2,-64(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  468bac:	e0fff017 	ldw	r3,-64(fp)
  468bb0:	00bfff84 	movi	r2,-2
  468bb4:	1884703a 	and	r2,r3,r2
  468bb8:	1001703a 	wrctl	status,r2
  
  return context;
  468bbc:	e0bff017 	ldw	r2,-64(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
  468bc0:	e0bfee15 	stw	r2,-72(fp)
    events_rdy     =  OS_FALSE;
  468bc4:	e03fec05 	stb	zero,-80(fp)
    events_rdy_nbr =  0;
  468bc8:	e03fec8d 	sth	zero,-78(fp)
    events_stat    =  OS_STAT_RDY;
  468bcc:	e03fed05 	stb	zero,-76(fp)
    pevents        =  pevents_pend;
  468bd0:	e0bffc17 	ldw	r2,-16(fp)
  468bd4:	e0bfea15 	stw	r2,-88(fp)
    pevent         = *pevents;
  468bd8:	e0bfea17 	ldw	r2,-88(fp)
  468bdc:	10800017 	ldw	r2,0(r2)
  468be0:	e0bfeb15 	stw	r2,-84(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
  468be4:	00009206 	br	468e30 <OSEventPendMulti+0x3e4>
        switch (pevent->OSEventType) {
  468be8:	e0bfeb17 	ldw	r2,-84(fp)
  468bec:	10800003 	ldbu	r2,0(r2)
  468bf0:	10803fcc 	andi	r2,r2,255
  468bf4:	10c000a0 	cmpeqi	r3,r2,2
  468bf8:	1800401e 	bne	r3,zero,468cfc <OSEventPendMulti+0x2b0>
  468bfc:	10c000e0 	cmpeqi	r3,r2,3
  468c00:	1800031e 	bne	r3,zero,468c10 <OSEventPendMulti+0x1c4>
  468c04:	10800060 	cmpeqi	r2,r2,1
  468c08:	1000201e 	bne	r2,zero,468c8c <OSEventPendMulti+0x240>
  468c0c:	00006c06 	br	468dc0 <OSEventPendMulti+0x374>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
  468c10:	e0bfeb17 	ldw	r2,-84(fp)
  468c14:	1080020b 	ldhu	r2,8(r2)
  468c18:	10bfffcc 	andi	r2,r2,65535
  468c1c:	10001726 	beq	r2,zero,468c7c <OSEventPendMulti+0x230>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
  468c20:	e0bfeb17 	ldw	r2,-84(fp)
  468c24:	1080020b 	ldhu	r2,8(r2)
  468c28:	10bfffc4 	addi	r2,r2,-1
  468c2c:	1007883a 	mov	r3,r2
  468c30:	e0bfeb17 	ldw	r2,-84(fp)
  468c34:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
  468c38:	e0bffd17 	ldw	r2,-12(fp)
  468c3c:	e0ffeb17 	ldw	r3,-84(fp)
  468c40:	10c00015 	stw	r3,0(r2)
  468c44:	e0bffd17 	ldw	r2,-12(fp)
  468c48:	10800104 	addi	r2,r2,4
  468c4c:	e0bffd15 	stw	r2,-12(fp)
                      events_rdy   =  OS_TRUE;
  468c50:	00800044 	movi	r2,1
  468c54:	e0bfec05 	stb	r2,-80(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
  468c58:	e0bffe17 	ldw	r2,-8(fp)
  468c5c:	10000015 	stw	zero,0(r2)
  468c60:	e0bffe17 	ldw	r2,-8(fp)
  468c64:	10800104 	addi	r2,r2,4
  468c68:	e0bffe15 	stw	r2,-8(fp)
                      events_rdy_nbr++;
  468c6c:	e0bfec8b 	ldhu	r2,-78(fp)
  468c70:	10800044 	addi	r2,r2,1
  468c74:	e0bfec8d 	sth	r2,-78(fp)

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
                 }
                 break;
  468c78:	00006706 	br	468e18 <OSEventPendMulti+0x3cc>
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
                      events_rdy_nbr++;

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
  468c7c:	e0bfed03 	ldbu	r2,-76(fp)
  468c80:	10800054 	ori	r2,r2,1
  468c84:	e0bfed05 	stb	r2,-76(fp)
                 }
                 break;
  468c88:	00006306 	br	468e18 <OSEventPendMulti+0x3cc>
#endif

#if (OS_MBOX_EN > 0)
            case OS_EVENT_TYPE_MBOX:
                 if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
  468c8c:	e0bfeb17 	ldw	r2,-84(fp)
  468c90:	10800117 	ldw	r2,4(r2)
  468c94:	10001526 	beq	r2,zero,468cec <OSEventPendMulti+0x2a0>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
  468c98:	e0bfeb17 	ldw	r2,-84(fp)
  468c9c:	10c00117 	ldw	r3,4(r2)
  468ca0:	e0bffe17 	ldw	r2,-8(fp)
  468ca4:	10c00015 	stw	r3,0(r2)
  468ca8:	e0bffe17 	ldw	r2,-8(fp)
  468cac:	10800104 	addi	r2,r2,4
  468cb0:	e0bffe15 	stw	r2,-8(fp)
                     pevent->OSEventPtr  = (void *)0;
  468cb4:	e0bfeb17 	ldw	r2,-84(fp)
  468cb8:	10000115 	stw	zero,4(r2)
                    *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
  468cbc:	e0bffd17 	ldw	r2,-12(fp)
  468cc0:	e0ffeb17 	ldw	r3,-84(fp)
  468cc4:	10c00015 	stw	r3,0(r2)
  468cc8:	e0bffd17 	ldw	r2,-12(fp)
  468ccc:	10800104 	addi	r2,r2,4
  468cd0:	e0bffd15 	stw	r2,-12(fp)
                      events_rdy         =  OS_TRUE;
  468cd4:	00800044 	movi	r2,1
  468cd8:	e0bfec05 	stb	r2,-80(fp)
                      events_rdy_nbr++;
  468cdc:	e0bfec8b 	ldhu	r2,-78(fp)
  468ce0:	10800044 	addi	r2,r2,1
  468ce4:	e0bfec8d 	sth	r2,-78(fp)

                 } else {
                      events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
                 }
                 break;
  468ce8:	00004b06 	br	468e18 <OSEventPendMulti+0x3cc>
                    *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
                      events_rdy         =  OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
  468cec:	e0bfed03 	ldbu	r2,-76(fp)
  468cf0:	10800094 	ori	r2,r2,2
  468cf4:	e0bfed05 	stb	r2,-76(fp)
                 }
                 break;
  468cf8:	00004706 	br	468e18 <OSEventPendMulti+0x3cc>
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
  468cfc:	e0bfeb17 	ldw	r2,-84(fp)
  468d00:	10800117 	ldw	r2,4(r2)
  468d04:	e0bfef15 	stw	r2,-68(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
  468d08:	e0bfef17 	ldw	r2,-68(fp)
  468d0c:	1080058b 	ldhu	r2,22(r2)
  468d10:	10bfffcc 	andi	r2,r2,65535
  468d14:	10002626 	beq	r2,zero,468db0 <OSEventPendMulti+0x364>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
  468d18:	e0bfef17 	ldw	r2,-68(fp)
  468d1c:	10800417 	ldw	r2,16(r2)
  468d20:	11000017 	ldw	r4,0(r2)
  468d24:	e0fffe17 	ldw	r3,-8(fp)
  468d28:	19000015 	stw	r4,0(r3)
  468d2c:	e0fffe17 	ldw	r3,-8(fp)
  468d30:	18c00104 	addi	r3,r3,4
  468d34:	e0fffe15 	stw	r3,-8(fp)
  468d38:	10c00104 	addi	r3,r2,4
  468d3c:	e0bfef17 	ldw	r2,-68(fp)
  468d40:	10c00415 	stw	r3,16(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
  468d44:	e0bfef17 	ldw	r2,-68(fp)
  468d48:	10c00417 	ldw	r3,16(r2)
  468d4c:	e0bfef17 	ldw	r2,-68(fp)
  468d50:	10800217 	ldw	r2,8(r2)
  468d54:	1880041e 	bne	r3,r2,468d68 <OSEventPendMulti+0x31c>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
  468d58:	e0bfef17 	ldw	r2,-68(fp)
  468d5c:	10c00117 	ldw	r3,4(r2)
  468d60:	e0bfef17 	ldw	r2,-68(fp)
  468d64:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
  468d68:	e0bfef17 	ldw	r2,-68(fp)
  468d6c:	1080058b 	ldhu	r2,22(r2)
  468d70:	10bfffc4 	addi	r2,r2,-1
  468d74:	1007883a 	mov	r3,r2
  468d78:	e0bfef17 	ldw	r2,-68(fp)
  468d7c:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
  468d80:	e0bffd17 	ldw	r2,-12(fp)
  468d84:	e0ffeb17 	ldw	r3,-84(fp)
  468d88:	10c00015 	stw	r3,0(r2)
  468d8c:	e0bffd17 	ldw	r2,-12(fp)
  468d90:	10800104 	addi	r2,r2,4
  468d94:	e0bffd15 	stw	r2,-12(fp)
                      events_rdy   = OS_TRUE;
  468d98:	00800044 	movi	r2,1
  468d9c:	e0bfec05 	stb	r2,-80(fp)
                      events_rdy_nbr++;
  468da0:	e0bfec8b 	ldhu	r2,-78(fp)
  468da4:	10800044 	addi	r2,r2,1
  468da8:	e0bfec8d 	sth	r2,-78(fp)

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
                 }
                 break;
  468dac:	00001a06 	br	468e18 <OSEventPendMulti+0x3cc>
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
  468db0:	e0bfed03 	ldbu	r2,-76(fp)
  468db4:	10800114 	ori	r2,r2,4
  468db8:	e0bfed05 	stb	r2,-76(fp)
                 }
                 break;
  468dbc:	00001606 	br	468e18 <OSEventPendMulti+0x3cc>
  468dc0:	e0bfee17 	ldw	r2,-72(fp)
  468dc4:	e0bff115 	stw	r2,-60(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  468dc8:	0005303a 	rdctl	r2,status
  468dcc:	e0bff215 	stw	r2,-56(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  468dd0:	e0fff217 	ldw	r3,-56(fp)
  468dd4:	00bfff84 	movi	r2,-2
  468dd8:	1884703a 	and	r2,r3,r2
  468ddc:	e0bff215 	stw	r2,-56(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  468de0:	e0bff117 	ldw	r2,-60(fp)
  468de4:	1080004c 	andi	r2,r2,1
  468de8:	e0fff217 	ldw	r3,-56(fp)
  468dec:	1884b03a 	or	r2,r3,r2
  468df0:	e0bff215 	stw	r2,-56(fp)
  
  NIOS2_WRITE_STATUS (status);
  468df4:	e0bff217 	ldw	r2,-56(fp)
  468df8:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
  468dfc:	e0bffd17 	ldw	r2,-12(fp)
  468e00:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
  468e04:	e0800217 	ldw	r2,8(fp)
  468e08:	00c00044 	movi	r3,1
  468e0c:	10c00005 	stb	r3,0(r2)
                 return (events_rdy_nbr);
  468e10:	e0bfec8b 	ldhu	r2,-78(fp)
  468e14:	0000ce06 	br	469150 <OSEventPendMulti+0x704>
        }
        pevents++;
  468e18:	e0bfea17 	ldw	r2,-88(fp)
  468e1c:	10800104 	addi	r2,r2,4
  468e20:	e0bfea15 	stw	r2,-88(fp)
        pevent = *pevents;
  468e24:	e0bfea17 	ldw	r2,-88(fp)
  468e28:	10800017 	ldw	r2,0(r2)
  468e2c:	e0bfeb15 	stw	r2,-84(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
  468e30:	e0bfeb17 	ldw	r2,-84(fp)
  468e34:	103f6c1e 	bne	r2,zero,468be8 <OSEventPendMulti+0x19c>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
  468e38:	e0bfec03 	ldbu	r2,-80(fp)
  468e3c:	10800058 	cmpnei	r2,r2,1
  468e40:	1000151e 	bne	r2,zero,468e98 <OSEventPendMulti+0x44c>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
  468e44:	e0bffd17 	ldw	r2,-12(fp)
  468e48:	10000015 	stw	zero,0(r2)
  468e4c:	e0bfee17 	ldw	r2,-72(fp)
  468e50:	e0bff315 	stw	r2,-52(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  468e54:	0005303a 	rdctl	r2,status
  468e58:	e0bff415 	stw	r2,-48(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  468e5c:	e0fff417 	ldw	r3,-48(fp)
  468e60:	00bfff84 	movi	r2,-2
  468e64:	1884703a 	and	r2,r3,r2
  468e68:	e0bff415 	stw	r2,-48(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  468e6c:	e0bff317 	ldw	r2,-52(fp)
  468e70:	1080004c 	andi	r2,r2,1
  468e74:	e0fff417 	ldw	r3,-48(fp)
  468e78:	1884b03a 	or	r2,r3,r2
  468e7c:	e0bff415 	stw	r2,-48(fp)
  
  NIOS2_WRITE_STATUS (status);
  468e80:	e0bff417 	ldw	r2,-48(fp)
  468e84:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
  468e88:	e0800217 	ldw	r2,8(fp)
  468e8c:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
  468e90:	e0bfec8b 	ldhu	r2,-78(fp)
  468e94:	0000ae06 	br	469150 <OSEventPendMulti+0x704>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
  468e98:	d0a71a17 	ldw	r2,-25496(gp)
  468e9c:	d0e71a17 	ldw	r3,-25496(gp)
  468ea0:	19000c03 	ldbu	r4,48(r3)
  468ea4:	e0ffed03 	ldbu	r3,-76(fp)
  468ea8:	20c6b03a 	or	r3,r4,r3
  468eac:	1809883a 	mov	r4,r3
  468eb0:	00ffe004 	movi	r3,-128
  468eb4:	20c6b03a 	or	r3,r4,r3
  468eb8:	10c00c05 	stb	r3,48(r2)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
  468ebc:	d0a71a17 	ldw	r2,-25496(gp)
  468ec0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
  468ec4:	d0a71a17 	ldw	r2,-25496(gp)
  468ec8:	e0ffff0b 	ldhu	r3,-4(fp)
  468ecc:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
  468ed0:	e13ffc17 	ldw	r4,-16(fp)
  468ed4:	0469d1c0 	call	469d1c <OS_EventTaskWaitMulti>
  468ed8:	e0bfee17 	ldw	r2,-72(fp)
  468edc:	e0bff515 	stw	r2,-44(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  468ee0:	0005303a 	rdctl	r2,status
  468ee4:	e0bff615 	stw	r2,-40(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  468ee8:	e0fff617 	ldw	r3,-40(fp)
  468eec:	00bfff84 	movi	r2,-2
  468ef0:	1884703a 	and	r2,r3,r2
  468ef4:	e0bff615 	stw	r2,-40(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  468ef8:	e0bff517 	ldw	r2,-44(fp)
  468efc:	1080004c 	andi	r2,r2,1
  468f00:	e0fff617 	ldw	r3,-40(fp)
  468f04:	1884b03a 	or	r2,r3,r2
  468f08:	e0bff615 	stw	r2,-40(fp)
  
  NIOS2_WRITE_STATUS (status);
  468f0c:	e0bff617 	ldw	r2,-40(fp)
  468f10:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
  468f14:	046a4980 	call	46a498 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  468f18:	0005303a 	rdctl	r2,status
  468f1c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  468f20:	e0fff717 	ldw	r3,-36(fp)
  468f24:	00bfff84 	movi	r2,-2
  468f28:	1884703a 	and	r2,r3,r2
  468f2c:	1001703a 	wrctl	status,r2
  
  return context;
  468f30:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
  468f34:	e0bfee15 	stw	r2,-72(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
  468f38:	d0a71a17 	ldw	r2,-25496(gp)
  468f3c:	10800c43 	ldbu	r2,49(r2)
  468f40:	10803fcc 	andi	r2,r2,255
  468f44:	10000226 	beq	r2,zero,468f50 <OSEventPendMulti+0x504>
  468f48:	108000a0 	cmpeqi	r2,r2,2
  468f4c:	10001926 	beq	r2,zero,468fb4 <OSEventPendMulti+0x568>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
  468f50:	d0a71a17 	ldw	r2,-25496(gp)
  468f54:	10800717 	ldw	r2,28(r2)
  468f58:	e0bfeb15 	stw	r2,-84(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
  468f5c:	e0bfeb17 	ldw	r2,-84(fp)
  468f60:	10000c26 	beq	r2,zero,468f94 <OSEventPendMulti+0x548>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
  468f64:	e0bffd17 	ldw	r2,-12(fp)
  468f68:	e0ffeb17 	ldw	r3,-84(fp)
  468f6c:	10c00015 	stw	r3,0(r2)
  468f70:	e0bffd17 	ldw	r2,-12(fp)
  468f74:	10800104 	addi	r2,r2,4
  468f78:	e0bffd15 	stw	r2,-12(fp)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
  468f7c:	e0bffd17 	ldw	r2,-12(fp)
  468f80:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
  468f84:	e0bfec8b 	ldhu	r2,-78(fp)
  468f88:	10800044 	addi	r2,r2,1
  468f8c:	e0bfec8d 	sth	r2,-78(fp)

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
             }
			 break;
  468f90:	00000d06 	br	468fc8 <OSEventPendMulti+0x57c>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
                  events_rdy_nbr++;

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
  468f94:	d0a71a17 	ldw	r2,-25496(gp)
  468f98:	00c00044 	movi	r3,1
  468f9c:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
  468fa0:	d0a71a17 	ldw	r2,-25496(gp)
  468fa4:	1009883a 	mov	r4,r2
  468fa8:	e17ffc17 	ldw	r5,-16(fp)
  468fac:	0469f140 	call	469f14 <OS_EventTaskRemoveMulti>
             }
			 break;
  468fb0:	00000506 	br	468fc8 <OSEventPendMulti+0x57c>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
  468fb4:	d0a71a17 	ldw	r2,-25496(gp)
  468fb8:	1009883a 	mov	r4,r2
  468fbc:	e17ffc17 	ldw	r5,-16(fp)
  468fc0:	0469f140 	call	469f14 <OS_EventTaskRemoveMulti>
             break;
  468fc4:	0001883a 	nop
    }

    switch (OSTCBCur->OSTCBStatPend) {
  468fc8:	d0a71a17 	ldw	r2,-25496(gp)
  468fcc:	10800c43 	ldbu	r2,49(r2)
  468fd0:	10803fcc 	andi	r2,r2,255
  468fd4:	10000326 	beq	r2,zero,468fe4 <OSEventPendMulti+0x598>
  468fd8:	108000a0 	cmpeqi	r2,r2,2
  468fdc:	1000301e 	bne	r2,zero,4690a0 <OSEventPendMulti+0x654>
  468fe0:	00003806 	br	4690c4 <OSEventPendMulti+0x678>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
  468fe4:	e0bfeb17 	ldw	r2,-84(fp)
  468fe8:	10800003 	ldbu	r2,0(r2)
  468fec:	10803fcc 	andi	r2,r2,255
  468ff0:	0080120e 	bge	zero,r2,46903c <OSEventPendMulti+0x5f0>
  468ff4:	10c000d0 	cmplti	r3,r2,3
  468ff8:	1800081e 	bne	r3,zero,46901c <OSEventPendMulti+0x5d0>
  468ffc:	108000e0 	cmpeqi	r2,r2,3
  469000:	10000e26 	beq	r2,zero,46903c <OSEventPendMulti+0x5f0>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
  469004:	e0bffe17 	ldw	r2,-8(fp)
  469008:	10000015 	stw	zero,0(r2)
  46900c:	e0bffe17 	ldw	r2,-8(fp)
  469010:	10800104 	addi	r2,r2,4
  469014:	e0bffe15 	stw	r2,-8(fp)
                      break;
  469018:	00001e06 	br	469094 <OSEventPendMulti+0x648>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
  46901c:	d0a71a17 	ldw	r2,-25496(gp)
  469020:	10c00917 	ldw	r3,36(r2)
  469024:	e0bffe17 	ldw	r2,-8(fp)
  469028:	10c00015 	stw	r3,0(r2)
  46902c:	e0bffe17 	ldw	r2,-8(fp)
  469030:	10800104 	addi	r2,r2,4
  469034:	e0bffe15 	stw	r2,-8(fp)
                      break;
  469038:	00001606 	br	469094 <OSEventPendMulti+0x648>
  46903c:	e0bfee17 	ldw	r2,-72(fp)
  469040:	e0bff815 	stw	r2,-32(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  469044:	0005303a 	rdctl	r2,status
  469048:	e0bff915 	stw	r2,-28(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46904c:	e0fff917 	ldw	r3,-28(fp)
  469050:	00bfff84 	movi	r2,-2
  469054:	1884703a 	and	r2,r3,r2
  469058:	e0bff915 	stw	r2,-28(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46905c:	e0bff817 	ldw	r2,-32(fp)
  469060:	1080004c 	andi	r2,r2,1
  469064:	e0fff917 	ldw	r3,-28(fp)
  469068:	1884b03a 	or	r2,r3,r2
  46906c:	e0bff915 	stw	r2,-28(fp)
  
  NIOS2_WRITE_STATUS (status);
  469070:	e0bff917 	ldw	r2,-28(fp)
  469074:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
  469078:	e0bffd17 	ldw	r2,-12(fp)
  46907c:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
  469080:	e0800217 	ldw	r2,8(fp)
  469084:	00c00044 	movi	r3,1
  469088:	10c00005 	stb	r3,0(r2)
                      return (events_rdy_nbr);
  46908c:	e0bfec8b 	ldhu	r2,-78(fp)
  469090:	00002f06 	br	469150 <OSEventPendMulti+0x704>
             }
            *perr = OS_ERR_NONE;
  469094:	e0800217 	ldw	r2,8(fp)
  469098:	10000005 	stb	zero,0(r2)
             break;
  46909c:	00001206 	br	4690e8 <OSEventPendMulti+0x69c>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
  4690a0:	e0bffe17 	ldw	r2,-8(fp)
  4690a4:	10000015 	stw	zero,0(r2)
  4690a8:	e0bffe17 	ldw	r2,-8(fp)
  4690ac:	10800104 	addi	r2,r2,4
  4690b0:	e0bffe15 	stw	r2,-8(fp)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
  4690b4:	e0800217 	ldw	r2,8(fp)
  4690b8:	00c00384 	movi	r3,14
  4690bc:	10c00005 	stb	r3,0(r2)
             break;
  4690c0:	00000906 	br	4690e8 <OSEventPendMulti+0x69c>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
  4690c4:	e0bffe17 	ldw	r2,-8(fp)
  4690c8:	10000015 	stw	zero,0(r2)
  4690cc:	e0bffe17 	ldw	r2,-8(fp)
  4690d0:	10800104 	addi	r2,r2,4
  4690d4:	e0bffe15 	stw	r2,-8(fp)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
  4690d8:	e0800217 	ldw	r2,8(fp)
  4690dc:	00c00284 	movi	r3,10
  4690e0:	10c00005 	stb	r3,0(r2)
             break;
  4690e4:	0001883a 	nop
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
  4690e8:	d0a71a17 	ldw	r2,-25496(gp)
  4690ec:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
  4690f0:	d0a71a17 	ldw	r2,-25496(gp)
  4690f4:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
  4690f8:	d0a71a17 	ldw	r2,-25496(gp)
  4690fc:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
  469100:	d0a71a17 	ldw	r2,-25496(gp)
  469104:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
  469108:	d0a71a17 	ldw	r2,-25496(gp)
  46910c:	10000915 	stw	zero,36(r2)
  469110:	e0bfee17 	ldw	r2,-72(fp)
  469114:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  469118:	0005303a 	rdctl	r2,status
  46911c:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  469120:	e0fffb17 	ldw	r3,-20(fp)
  469124:	00bfff84 	movi	r2,-2
  469128:	1884703a 	and	r2,r3,r2
  46912c:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  469130:	e0bffa17 	ldw	r2,-24(fp)
  469134:	1080004c 	andi	r2,r2,1
  469138:	e0fffb17 	ldw	r3,-20(fp)
  46913c:	1884b03a 	or	r2,r3,r2
  469140:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
  469144:	e0bffb17 	ldw	r2,-20(fp)
  469148:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
  46914c:	e0bfec8b 	ldhu	r2,-78(fp)
}
  469150:	e037883a 	mov	sp,fp
  469154:	dfc00117 	ldw	ra,4(sp)
  469158:	df000017 	ldw	fp,0(sp)
  46915c:	dec00204 	addi	sp,sp,8
  469160:	f800283a 	ret

00469164 <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
  469164:	defffe04 	addi	sp,sp,-8
  469168:	dfc00115 	stw	ra,4(sp)
  46916c:	df000015 	stw	fp,0(sp)
  469170:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
  469174:	04745dc0 	call	4745dc <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
  469178:	046a1500 	call	46a150 <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
  46917c:	046a1940 	call	46a194 <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
  469180:	046a2f80 	call	46a2f8 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
  469184:	046a0740 	call	46a074 <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
  469188:	046c9780 	call	46c978 <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
  46918c:	046d44c0 	call	46d44c <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
  469190:	046eabc0 	call	46eabc <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
  469194:	046a2000 	call	46a200 <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
  469198:	046a27c0 	call	46a27c <OS_InitTaskStat>

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
  46919c:	04745f80 	call	4745f8 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
  4691a0:	046ac700 	call	46ac70 <OSDebugInit>
#endif
}
  4691a4:	e037883a 	mov	sp,fp
  4691a8:	dfc00117 	ldw	ra,4(sp)
  4691ac:	df000017 	ldw	fp,0(sp)
  4691b0:	dec00204 	addi	sp,sp,8
  4691b4:	f800283a 	ret

004691b8 <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
  4691b8:	defffb04 	addi	sp,sp,-20
  4691bc:	df000415 	stw	fp,16(sp)
  4691c0:	df000404 	addi	fp,sp,16
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
  4691c4:	e03ffc15 	stw	zero,-16(fp)
#endif

    if (OSRunning == OS_TRUE) {
  4691c8:	d0a70b43 	ldbu	r2,-25555(gp)
  4691cc:	10803fcc 	andi	r2,r2,255
  4691d0:	10800058 	cmpnei	r2,r2,1
  4691d4:	10001e1e 	bne	r2,zero,469250 <OSIntEnter+0x98>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  4691d8:	0005303a 	rdctl	r2,status
  4691dc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  4691e0:	e0fffd17 	ldw	r3,-12(fp)
  4691e4:	00bfff84 	movi	r2,-2
  4691e8:	1884703a 	and	r2,r3,r2
  4691ec:	1001703a 	wrctl	status,r2
  
  return context;
  4691f0:	e0bffd17 	ldw	r2,-12(fp)
        OS_ENTER_CRITICAL();
  4691f4:	e0bffc15 	stw	r2,-16(fp)
        if (OSIntNesting < 255u) {
  4691f8:	d0a71903 	ldbu	r2,-25500(gp)
  4691fc:	10803fcc 	andi	r2,r2,255
  469200:	10803fe0 	cmpeqi	r2,r2,255
  469204:	1000031e 	bne	r2,zero,469214 <OSIntEnter+0x5c>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
  469208:	d0a71903 	ldbu	r2,-25500(gp)
  46920c:	10800044 	addi	r2,r2,1
  469210:	d0a71905 	stb	r2,-25500(gp)
  469214:	e0bffc17 	ldw	r2,-16(fp)
  469218:	e0bffe15 	stw	r2,-8(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46921c:	0005303a 	rdctl	r2,status
  469220:	e0bfff15 	stw	r2,-4(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  469224:	e0ffff17 	ldw	r3,-4(fp)
  469228:	00bfff84 	movi	r2,-2
  46922c:	1884703a 	and	r2,r3,r2
  469230:	e0bfff15 	stw	r2,-4(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  469234:	e0bffe17 	ldw	r2,-8(fp)
  469238:	1080004c 	andi	r2,r2,1
  46923c:	e0ffff17 	ldw	r3,-4(fp)
  469240:	1884b03a 	or	r2,r3,r2
  469244:	e0bfff15 	stw	r2,-4(fp)
  
  NIOS2_WRITE_STATUS (status);
  469248:	e0bfff17 	ldw	r2,-4(fp)
  46924c:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
    }
}
  469250:	e037883a 	mov	sp,fp
  469254:	df000017 	ldw	fp,0(sp)
  469258:	dec00104 	addi	sp,sp,4
  46925c:	f800283a 	ret

00469260 <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
  469260:	defff604 	addi	sp,sp,-40
  469264:	dfc00915 	stw	ra,36(sp)
  469268:	df000815 	stw	fp,32(sp)
  46926c:	df000804 	addi	fp,sp,32
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
  469270:	e03ff815 	stw	zero,-32(fp)
#endif



    if (OSRunning == OS_TRUE) {
  469274:	d0a70b43 	ldbu	r2,-25555(gp)
  469278:	10803fcc 	andi	r2,r2,255
  46927c:	10800058 	cmpnei	r2,r2,1
  469280:	1000611e 	bne	r2,zero,469408 <OSIntExit+0x1a8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  469284:	0005303a 	rdctl	r2,status
  469288:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46928c:	e0fffd17 	ldw	r3,-12(fp)
  469290:	00bfff84 	movi	r2,-2
  469294:	1884703a 	and	r2,r3,r2
  469298:	1001703a 	wrctl	status,r2
  
  return context;
  46929c:	e0bffd17 	ldw	r2,-12(fp)
        OS_ENTER_CRITICAL();
  4692a0:	e0bff815 	stw	r2,-32(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
  4692a4:	d0a71903 	ldbu	r2,-25500(gp)
  4692a8:	10803fcc 	andi	r2,r2,255
  4692ac:	10000326 	beq	r2,zero,4692bc <OSIntExit+0x5c>
            OSIntNesting--;
  4692b0:	d0a71903 	ldbu	r2,-25500(gp)
  4692b4:	10bfffc4 	addi	r2,r2,-1
  4692b8:	d0a71905 	stb	r2,-25500(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
  4692bc:	d0a71903 	ldbu	r2,-25500(gp)
  4692c0:	10803fcc 	andi	r2,r2,255
  4692c4:	1000411e 	bne	r2,zero,4693cc <OSIntExit+0x16c>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
  4692c8:	d0a70b03 	ldbu	r2,-25556(gp)
  4692cc:	10803fcc 	andi	r2,r2,255
  4692d0:	10003e1e 	bne	r2,zero,4693cc <OSIntExit+0x16c>
                OS_SchedNew();
  4692d4:	046a5900 	call	46a590 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
  4692d8:	d0e70d03 	ldbu	r3,-25548(gp)
  4692dc:	d0a70d43 	ldbu	r2,-25547(gp)
  4692e0:	18c03fcc 	andi	r3,r3,255
  4692e4:	10803fcc 	andi	r2,r2,255
  4692e8:	18803826 	beq	r3,r2,4693cc <OSIntExit+0x16c>
                	//preemption is occuring.
                	//pause the task in the fingerprint unit

                	//Is this a critical task?
                	//Here we pause the task
                	if(OSPrioCur < 16){
  4692ec:	d0a70d43 	ldbu	r2,-25547(gp)
  4692f0:	10803fcc 	andi	r2,r2,255
  4692f4:	10800428 	cmpgeui	r2,r2,16
  4692f8:	10000f1e 	bne	r2,zero,469338 <OSIntExit+0xd8>

                		INT32U* fprint_pause_reg = (INT32U*)(0x8100000 \
  4692fc:	00820434 	movhi	r2,2064
  469300:	10800104 	addi	r2,r2,4
  469304:	e0bff915 	stw	r2,-28(fp)
                												+ 4);
                		INT32U x = *fprint_pause_reg;
  469308:	e0bff917 	ldw	r2,-28(fp)
  46930c:	10800017 	ldw	r2,0(r2)
  469310:	e0bffa15 	stw	r2,-24(fp)
                		*fprint_pause_reg = x | (1 << OSPrioCur);
  469314:	d0a70d43 	ldbu	r2,-25547(gp)
  469318:	10803fcc 	andi	r2,r2,255
  46931c:	00c00044 	movi	r3,1
  469320:	1884983a 	sll	r2,r3,r2
  469324:	1007883a 	mov	r3,r2
  469328:	e0bffa17 	ldw	r2,-24(fp)
  46932c:	1886b03a 	or	r3,r3,r2
  469330:	e0bff917 	ldw	r2,-28(fp)
  469334:	10c00015 	stw	r3,0(r2)


                	}

                	OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
  469338:	d0a70d03 	ldbu	r2,-25548(gp)
  46933c:	10803fcc 	andi	r2,r2,255
  469340:	00c01234 	movhi	r3,72
  469344:	18f31404 	addi	r3,r3,-13232
  469348:	1085883a 	add	r2,r2,r2
  46934c:	1085883a 	add	r2,r2,r2
  469350:	1885883a 	add	r2,r3,r2
  469354:	10800017 	ldw	r2,0(r2)
  469358:	d0a71515 	stw	r2,-25516(gp)

#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
  46935c:	d0a71517 	ldw	r2,-25516(gp)
  469360:	10c00e17 	ldw	r3,56(r2)
  469364:	18c00044 	addi	r3,r3,1
  469368:	10c00e15 	stw	r3,56(r2)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
  46936c:	d0a71017 	ldw	r2,-25536(gp)
  469370:	10800044 	addi	r2,r2,1
  469374:	d0a71015 	stw	r2,-25536(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
  469378:	04741840 	call	474184 <OSCtxSw>

                    //Here is where we resume the task
                    if(OSPrioCur < 16){
  46937c:	d0a70d43 	ldbu	r2,-25547(gp)
  469380:	10803fcc 	andi	r2,r2,255
  469384:	10800428 	cmpgeui	r2,r2,16
  469388:	1000101e 	bne	r2,zero,4693cc <OSIntExit+0x16c>

                    	INT32U* fprint_pause_reg = (INT32U*)(0x8100000 \
  46938c:	00820434 	movhi	r2,2064
  469390:	10800104 	addi	r2,r2,4
  469394:	e0bffb15 	stw	r2,-20(fp)
                                    							+ 4);
                    	INT32U x = *fprint_pause_reg;
  469398:	e0bffb17 	ldw	r2,-20(fp)
  46939c:	10800017 	ldw	r2,0(r2)
  4693a0:	e0bffc15 	stw	r2,-16(fp)
                    	*fprint_pause_reg = x & ~(1 << OSPrioCur);
  4693a4:	d0a70d43 	ldbu	r2,-25547(gp)
  4693a8:	10803fcc 	andi	r2,r2,255
  4693ac:	00c00044 	movi	r3,1
  4693b0:	1884983a 	sll	r2,r3,r2
  4693b4:	0084303a 	nor	r2,zero,r2
  4693b8:	1007883a 	mov	r3,r2
  4693bc:	e0bffc17 	ldw	r2,-16(fp)
  4693c0:	1886703a 	and	r3,r3,r2
  4693c4:	e0bffb17 	ldw	r2,-20(fp)
  4693c8:	10c00015 	stw	r3,0(r2)
  4693cc:	e0bff817 	ldw	r2,-32(fp)
  4693d0:	e0bffe15 	stw	r2,-8(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  4693d4:	0005303a 	rdctl	r2,status
  4693d8:	e0bfff15 	stw	r2,-4(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  4693dc:	e0ffff17 	ldw	r3,-4(fp)
  4693e0:	00bfff84 	movi	r2,-2
  4693e4:	1884703a 	and	r2,r3,r2
  4693e8:	e0bfff15 	stw	r2,-4(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  4693ec:	e0bffe17 	ldw	r2,-8(fp)
  4693f0:	1080004c 	andi	r2,r2,1
  4693f4:	e0ffff17 	ldw	r3,-4(fp)
  4693f8:	1884b03a 	or	r2,r3,r2
  4693fc:	e0bfff15 	stw	r2,-4(fp)
  
  NIOS2_WRITE_STATUS (status);
  469400:	e0bfff17 	ldw	r2,-4(fp)
  469404:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
  469408:	e037883a 	mov	sp,fp
  46940c:	dfc00117 	ldw	ra,4(sp)
  469410:	df000017 	ldw	fp,0(sp)
  469414:	dec00204 	addi	sp,sp,8
  469418:	f800283a 	ret

0046941c <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
  46941c:	defffb04 	addi	sp,sp,-20
  469420:	df000415 	stw	fp,16(sp)
  469424:	df000404 	addi	fp,sp,16
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
  469428:	e03ffc15 	stw	zero,-16(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
  46942c:	d0a70b43 	ldbu	r2,-25555(gp)
  469430:	10803fcc 	andi	r2,r2,255
  469434:	10800058 	cmpnei	r2,r2,1
  469438:	1000211e 	bne	r2,zero,4694c0 <OSSchedLock+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46943c:	0005303a 	rdctl	r2,status
  469440:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  469444:	e0fffd17 	ldw	r3,-12(fp)
  469448:	00bfff84 	movi	r2,-2
  46944c:	1884703a 	and	r2,r3,r2
  469450:	1001703a 	wrctl	status,r2
  
  return context;
  469454:	e0bffd17 	ldw	r2,-12(fp)
        OS_ENTER_CRITICAL();
  469458:	e0bffc15 	stw	r2,-16(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
  46945c:	d0a71903 	ldbu	r2,-25500(gp)
  469460:	10803fcc 	andi	r2,r2,255
  469464:	1000071e 	bne	r2,zero,469484 <OSSchedLock+0x68>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
  469468:	d0a70b03 	ldbu	r2,-25556(gp)
  46946c:	10803fcc 	andi	r2,r2,255
  469470:	10803fe0 	cmpeqi	r2,r2,255
  469474:	1000031e 	bne	r2,zero,469484 <OSSchedLock+0x68>
                OSLockNesting++;                 /* Increment lock nesting level                       */
  469478:	d0a70b03 	ldbu	r2,-25556(gp)
  46947c:	10800044 	addi	r2,r2,1
  469480:	d0a70b05 	stb	r2,-25556(gp)
  469484:	e0bffc17 	ldw	r2,-16(fp)
  469488:	e0bffe15 	stw	r2,-8(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46948c:	0005303a 	rdctl	r2,status
  469490:	e0bfff15 	stw	r2,-4(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  469494:	e0ffff17 	ldw	r3,-4(fp)
  469498:	00bfff84 	movi	r2,-2
  46949c:	1884703a 	and	r2,r3,r2
  4694a0:	e0bfff15 	stw	r2,-4(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  4694a4:	e0bffe17 	ldw	r2,-8(fp)
  4694a8:	1080004c 	andi	r2,r2,1
  4694ac:	e0ffff17 	ldw	r3,-4(fp)
  4694b0:	1884b03a 	or	r2,r3,r2
  4694b4:	e0bfff15 	stw	r2,-4(fp)
  
  NIOS2_WRITE_STATUS (status);
  4694b8:	e0bfff17 	ldw	r2,-4(fp)
  4694bc:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
  4694c0:	e037883a 	mov	sp,fp
  4694c4:	df000017 	ldw	fp,0(sp)
  4694c8:	dec00104 	addi	sp,sp,4
  4694cc:	f800283a 	ret

004694d0 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
  4694d0:	defff404 	addi	sp,sp,-48
  4694d4:	dfc00b15 	stw	ra,44(sp)
  4694d8:	df000a15 	stw	fp,40(sp)
  4694dc:	df000a04 	addi	fp,sp,40
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
  4694e0:	e03ff615 	stw	zero,-40(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
  4694e4:	d0a70b43 	ldbu	r2,-25555(gp)
  4694e8:	10803fcc 	andi	r2,r2,255
  4694ec:	10800058 	cmpnei	r2,r2,1
  4694f0:	1000541e 	bne	r2,zero,469644 <OSSchedUnlock+0x174>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  4694f4:	0005303a 	rdctl	r2,status
  4694f8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  4694fc:	e0fff717 	ldw	r3,-36(fp)
  469500:	00bfff84 	movi	r2,-2
  469504:	1884703a 	and	r2,r3,r2
  469508:	1001703a 	wrctl	status,r2
  
  return context;
  46950c:	e0bff717 	ldw	r2,-36(fp)
        OS_ENTER_CRITICAL();
  469510:	e0bff615 	stw	r2,-40(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
  469514:	d0a70b03 	ldbu	r2,-25556(gp)
  469518:	10803fcc 	andi	r2,r2,255
  46951c:	10003a26 	beq	r2,zero,469608 <OSSchedUnlock+0x138>
            OSLockNesting--;                               /* Decrement lock nesting level             */
  469520:	d0a70b03 	ldbu	r2,-25556(gp)
  469524:	10bfffc4 	addi	r2,r2,-1
  469528:	d0a70b05 	stb	r2,-25556(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
  46952c:	d0a70b03 	ldbu	r2,-25556(gp)
  469530:	10803fcc 	andi	r2,r2,255
  469534:	1000241e 	bne	r2,zero,4695c8 <OSSchedUnlock+0xf8>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
  469538:	d0a71903 	ldbu	r2,-25500(gp)
  46953c:	10803fcc 	andi	r2,r2,255
  469540:	1000111e 	bne	r2,zero,469588 <OSSchedUnlock+0xb8>
  469544:	e0bff617 	ldw	r2,-40(fp)
  469548:	e0bff815 	stw	r2,-32(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46954c:	0005303a 	rdctl	r2,status
  469550:	e0bff915 	stw	r2,-28(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  469554:	e0fff917 	ldw	r3,-28(fp)
  469558:	00bfff84 	movi	r2,-2
  46955c:	1884703a 	and	r2,r3,r2
  469560:	e0bff915 	stw	r2,-28(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  469564:	e0bff817 	ldw	r2,-32(fp)
  469568:	1080004c 	andi	r2,r2,1
  46956c:	e0fff917 	ldw	r3,-28(fp)
  469570:	1884b03a 	or	r2,r3,r2
  469574:	e0bff915 	stw	r2,-28(fp)
  
  NIOS2_WRITE_STATUS (status);
  469578:	e0bff917 	ldw	r2,-28(fp)
  46957c:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
  469580:	046a4980 	call	46a498 <OS_Sched>
  469584:	00002f06 	br	469644 <OSSchedUnlock+0x174>
  469588:	e0bff617 	ldw	r2,-40(fp)
  46958c:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  469590:	0005303a 	rdctl	r2,status
  469594:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  469598:	e0fffb17 	ldw	r3,-20(fp)
  46959c:	00bfff84 	movi	r2,-2
  4695a0:	1884703a 	and	r2,r3,r2
  4695a4:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  4695a8:	e0bffa17 	ldw	r2,-24(fp)
  4695ac:	1080004c 	andi	r2,r2,1
  4695b0:	e0fffb17 	ldw	r3,-20(fp)
  4695b4:	1884b03a 	or	r2,r3,r2
  4695b8:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
  4695bc:	e0bffb17 	ldw	r2,-20(fp)
  4695c0:	1001703a 	wrctl	status,r2
  4695c4:	00001f06 	br	469644 <OSSchedUnlock+0x174>
  4695c8:	e0bff617 	ldw	r2,-40(fp)
  4695cc:	e0bffc15 	stw	r2,-16(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  4695d0:	0005303a 	rdctl	r2,status
  4695d4:	e0bffd15 	stw	r2,-12(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  4695d8:	e0fffd17 	ldw	r3,-12(fp)
  4695dc:	00bfff84 	movi	r2,-2
  4695e0:	1884703a 	and	r2,r3,r2
  4695e4:	e0bffd15 	stw	r2,-12(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  4695e8:	e0bffc17 	ldw	r2,-16(fp)
  4695ec:	1080004c 	andi	r2,r2,1
  4695f0:	e0fffd17 	ldw	r3,-12(fp)
  4695f4:	1884b03a 	or	r2,r3,r2
  4695f8:	e0bffd15 	stw	r2,-12(fp)
  
  NIOS2_WRITE_STATUS (status);
  4695fc:	e0bffd17 	ldw	r2,-12(fp)
  469600:	1001703a 	wrctl	status,r2
  469604:	00000f06 	br	469644 <OSSchedUnlock+0x174>
  469608:	e0bff617 	ldw	r2,-40(fp)
  46960c:	e0bffe15 	stw	r2,-8(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  469610:	0005303a 	rdctl	r2,status
  469614:	e0bfff15 	stw	r2,-4(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  469618:	e0ffff17 	ldw	r3,-4(fp)
  46961c:	00bfff84 	movi	r2,-2
  469620:	1884703a 	and	r2,r3,r2
  469624:	e0bfff15 	stw	r2,-4(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  469628:	e0bffe17 	ldw	r2,-8(fp)
  46962c:	1080004c 	andi	r2,r2,1
  469630:	e0ffff17 	ldw	r3,-4(fp)
  469634:	1884b03a 	or	r2,r3,r2
  469638:	e0bfff15 	stw	r2,-4(fp)
  
  NIOS2_WRITE_STATUS (status);
  46963c:	e0bfff17 	ldw	r2,-4(fp)
  469640:	1001703a 	wrctl	status,r2
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
  469644:	e037883a 	mov	sp,fp
  469648:	dfc00117 	ldw	ra,4(sp)
  46964c:	df000017 	ldw	fp,0(sp)
  469650:	dec00204 	addi	sp,sp,8
  469654:	f800283a 	ret

00469658 <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
  469658:	defffe04 	addi	sp,sp,-8
  46965c:	dfc00115 	stw	ra,4(sp)
  469660:	df000015 	stw	fp,0(sp)
  469664:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
  469668:	d0a70b43 	ldbu	r2,-25555(gp)
  46966c:	10803fcc 	andi	r2,r2,255
  469670:	10000f1e 	bne	r2,zero,4696b0 <OSStart+0x58>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
  469674:	046a5900 	call	46a590 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
  469678:	d0a70d03 	ldbu	r2,-25548(gp)
  46967c:	d0a70d45 	stb	r2,-25547(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
  469680:	d0a70d03 	ldbu	r2,-25548(gp)
  469684:	10803fcc 	andi	r2,r2,255
  469688:	00c01234 	movhi	r3,72
  46968c:	18f31404 	addi	r3,r3,-13232
  469690:	1085883a 	add	r2,r2,r2
  469694:	1085883a 	add	r2,r2,r2
  469698:	1885883a 	add	r2,r3,r2
  46969c:	10800017 	ldw	r2,0(r2)
  4696a0:	d0a71515 	stw	r2,-25516(gp)
        OSTCBCur      = OSTCBHighRdy;
  4696a4:	d0a71517 	ldw	r2,-25516(gp)
  4696a8:	d0a71a15 	stw	r2,-25496(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
  4696ac:	04742100 	call	474210 <OSStartHighRdy>
    }
}
  4696b0:	e037883a 	mov	sp,fp
  4696b4:	dfc00117 	ldw	ra,4(sp)
  4696b8:	df000017 	ldw	fp,0(sp)
  4696bc:	dec00204 	addi	sp,sp,8
  4696c0:	f800283a 	ret

004696c4 <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
  4696c4:	defff704 	addi	sp,sp,-36
  4696c8:	dfc00815 	stw	ra,32(sp)
  4696cc:	df000715 	stw	fp,28(sp)
  4696d0:	df000704 	addi	fp,sp,28
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
  4696d4:	e03ff915 	stw	zero,-28(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
  4696d8:	01000084 	movi	r4,2
  4696dc:	04719a00 	call	4719a0 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  4696e0:	0005303a 	rdctl	r2,status
  4696e4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  4696e8:	e0fffa17 	ldw	r3,-24(fp)
  4696ec:	00bfff84 	movi	r2,-2
  4696f0:	1884703a 	and	r2,r3,r2
  4696f4:	1001703a 	wrctl	status,r2
  
  return context;
  4696f8:	e0bffa17 	ldw	r2,-24(fp)
    OS_ENTER_CRITICAL();
  4696fc:	e0bff915 	stw	r2,-28(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
  469700:	d0270c15 	stw	zero,-25552(gp)
  469704:	e0bff917 	ldw	r2,-28(fp)
  469708:	e0bffb15 	stw	r2,-20(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46970c:	0005303a 	rdctl	r2,status
  469710:	e0bffc15 	stw	r2,-16(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  469714:	e0fffc17 	ldw	r3,-16(fp)
  469718:	00bfff84 	movi	r2,-2
  46971c:	1884703a 	and	r2,r3,r2
  469720:	e0bffc15 	stw	r2,-16(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  469724:	e0bffb17 	ldw	r2,-20(fp)
  469728:	1080004c 	andi	r2,r2,1
  46972c:	e0fffc17 	ldw	r3,-16(fp)
  469730:	1884b03a 	or	r2,r3,r2
  469734:	e0bffc15 	stw	r2,-16(fp)
  
  NIOS2_WRITE_STATUS (status);
  469738:	e0bffc17 	ldw	r2,-16(fp)
  46973c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
  469740:	01000284 	movi	r4,10
  469744:	04719a00 	call	4719a0 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  469748:	0005303a 	rdctl	r2,status
  46974c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  469750:	e0fffd17 	ldw	r3,-12(fp)
  469754:	00bfff84 	movi	r2,-2
  469758:	1884703a 	and	r2,r3,r2
  46975c:	1001703a 	wrctl	status,r2
  
  return context;
  469760:	e0bffd17 	ldw	r2,-12(fp)
    OS_ENTER_CRITICAL();
  469764:	e0bff915 	stw	r2,-28(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
  469768:	d0a70c17 	ldw	r2,-25552(gp)
  46976c:	d0a71115 	stw	r2,-25532(gp)
    OSStatRdy    = OS_TRUE;
  469770:	00800044 	movi	r2,1
  469774:	d0a71d05 	stb	r2,-25484(gp)
  469778:	e0bff917 	ldw	r2,-28(fp)
  46977c:	e0bffe15 	stw	r2,-8(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  469780:	0005303a 	rdctl	r2,status
  469784:	e0bfff15 	stw	r2,-4(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  469788:	e0ffff17 	ldw	r3,-4(fp)
  46978c:	00bfff84 	movi	r2,-2
  469790:	1884703a 	and	r2,r3,r2
  469794:	e0bfff15 	stw	r2,-4(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  469798:	e0bffe17 	ldw	r2,-8(fp)
  46979c:	1080004c 	andi	r2,r2,1
  4697a0:	e0ffff17 	ldw	r3,-4(fp)
  4697a4:	1884b03a 	or	r2,r3,r2
  4697a8:	e0bfff15 	stw	r2,-4(fp)
  
  NIOS2_WRITE_STATUS (status);
  4697ac:	e0bfff17 	ldw	r2,-4(fp)
  4697b0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
  4697b4:	e037883a 	mov	sp,fp
  4697b8:	dfc00117 	ldw	ra,4(sp)
  4697bc:	df000017 	ldw	fp,0(sp)
  4697c0:	dec00204 	addi	sp,sp,8
  4697c4:	f800283a 	ret

004697c8 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
  4697c8:	defff504 	addi	sp,sp,-44
  4697cc:	dfc00a15 	stw	ra,40(sp)
  4697d0:	df000915 	stw	fp,36(sp)
  4697d4:	df000904 	addi	fp,sp,36
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
  4697d8:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
  4697dc:	04745c00 	call	4745c0 <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  4697e0:	0005303a 	rdctl	r2,status
  4697e4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  4697e8:	e0fffa17 	ldw	r3,-24(fp)
  4697ec:	00bfff84 	movi	r2,-2
  4697f0:	1884703a 	and	r2,r3,r2
  4697f4:	1001703a 	wrctl	status,r2
  
  return context;
  4697f8:	e0bffa17 	ldw	r2,-24(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
  4697fc:	e0bff915 	stw	r2,-28(fp)
    OSTime++;
  469800:	d0a71b17 	ldw	r2,-25492(gp)
  469804:	10800044 	addi	r2,r2,1
  469808:	d0a71b15 	stw	r2,-25492(gp)
  46980c:	e0bff917 	ldw	r2,-28(fp)
  469810:	e0bffb15 	stw	r2,-20(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  469814:	0005303a 	rdctl	r2,status
  469818:	e0bffc15 	stw	r2,-16(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46981c:	e0fffc17 	ldw	r3,-16(fp)
  469820:	00bfff84 	movi	r2,-2
  469824:	1884703a 	and	r2,r3,r2
  469828:	e0bffc15 	stw	r2,-16(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46982c:	e0bffb17 	ldw	r2,-20(fp)
  469830:	1080004c 	andi	r2,r2,1
  469834:	e0fffc17 	ldw	r3,-16(fp)
  469838:	1884b03a 	or	r2,r3,r2
  46983c:	e0bffc15 	stw	r2,-16(fp)
  
  NIOS2_WRITE_STATUS (status);
  469840:	e0bffc17 	ldw	r2,-16(fp)
  469844:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
  469848:	d0a70b43 	ldbu	r2,-25555(gp)
  46984c:	10803fcc 	andi	r2,r2,255
  469850:	10800058 	cmpnei	r2,r2,1
  469854:	1000751e 	bne	r2,zero,469a2c <OSTimeTick+0x264>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
  469858:	d0a70f03 	ldbu	r2,-25540(gp)
  46985c:	10803fcc 	andi	r2,r2,255
  469860:	10c00060 	cmpeqi	r3,r2,1
  469864:	1800061e 	bne	r3,zero,469880 <OSTimeTick+0xb8>
  469868:	10c000a0 	cmpeqi	r3,r2,2
  46986c:	1800061e 	bne	r3,zero,469888 <OSTimeTick+0xc0>
  469870:	10000a1e 	bne	r2,zero,46989c <OSTimeTick+0xd4>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
  469874:	00800044 	movi	r2,1
  469878:	e0bff805 	stb	r2,-32(fp)
                 break;
  46987c:	00000b06 	br	4698ac <OSTimeTick+0xe4>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
  469880:	e03ff805 	stb	zero,-32(fp)
                 break;
  469884:	00000906 	br	4698ac <OSTimeTick+0xe4>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
  469888:	00800044 	movi	r2,1
  46988c:	e0bff805 	stb	r2,-32(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
  469890:	00800044 	movi	r2,1
  469894:	d0a70f05 	stb	r2,-25540(gp)
                 break;
  469898:	00000406 	br	4698ac <OSTimeTick+0xe4>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
  46989c:	00800044 	movi	r2,1
  4698a0:	e0bff805 	stb	r2,-32(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
  4698a4:	d0270f05 	stb	zero,-25540(gp)
                 break;
  4698a8:	0001883a 	nop
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
  4698ac:	e0bff803 	ldbu	r2,-32(fp)
  4698b0:	10005d26 	beq	r2,zero,469a28 <OSTimeTick+0x260>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
  4698b4:	d0a70e17 	ldw	r2,-25544(gp)
  4698b8:	e0bff715 	stw	r2,-36(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
  4698bc:	00005406 	br	469a10 <OSTimeTick+0x248>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  4698c0:	0005303a 	rdctl	r2,status
  4698c4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  4698c8:	e0fffd17 	ldw	r3,-12(fp)
  4698cc:	00bfff84 	movi	r2,-2
  4698d0:	1884703a 	and	r2,r3,r2
  4698d4:	1001703a 	wrctl	status,r2
  
  return context;
  4698d8:	e0bffd17 	ldw	r2,-12(fp)
            OS_ENTER_CRITICAL();
  4698dc:	e0bff915 	stw	r2,-28(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
  4698e0:	e0bff717 	ldw	r2,-36(fp)
  4698e4:	10800b8b 	ldhu	r2,46(r2)
  4698e8:	10bfffcc 	andi	r2,r2,65535
  4698ec:	10003626 	beq	r2,zero,4699c8 <OSTimeTick+0x200>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
  4698f0:	e0bff717 	ldw	r2,-36(fp)
  4698f4:	10800b8b 	ldhu	r2,46(r2)
  4698f8:	10bfffc4 	addi	r2,r2,-1
  4698fc:	1007883a 	mov	r3,r2
  469900:	e0bff717 	ldw	r2,-36(fp)
  469904:	10c00b8d 	sth	r3,46(r2)
  469908:	e0bff717 	ldw	r2,-36(fp)
  46990c:	10800b8b 	ldhu	r2,46(r2)
  469910:	10bfffcc 	andi	r2,r2,65535
  469914:	10002c1e 	bne	r2,zero,4699c8 <OSTimeTick+0x200>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
  469918:	e0bff717 	ldw	r2,-36(fp)
  46991c:	10800c03 	ldbu	r2,48(r2)
  469920:	10803fcc 	andi	r2,r2,255
  469924:	10800dcc 	andi	r2,r2,55
  469928:	10000b26 	beq	r2,zero,469958 <OSTimeTick+0x190>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
  46992c:	e0bff717 	ldw	r2,-36(fp)
  469930:	10c00c03 	ldbu	r3,48(r2)
  469934:	00bff204 	movi	r2,-56
  469938:	1884703a 	and	r2,r3,r2
  46993c:	1007883a 	mov	r3,r2
  469940:	e0bff717 	ldw	r2,-36(fp)
  469944:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
  469948:	e0bff717 	ldw	r2,-36(fp)
  46994c:	00c00044 	movi	r3,1
  469950:	10c00c45 	stb	r3,49(r2)
  469954:	00000206 	br	469960 <OSTimeTick+0x198>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
  469958:	e0bff717 	ldw	r2,-36(fp)
  46995c:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
  469960:	e0bff717 	ldw	r2,-36(fp)
  469964:	10800c03 	ldbu	r2,48(r2)
  469968:	10803fcc 	andi	r2,r2,255
  46996c:	1080020c 	andi	r2,r2,8
  469970:	1000151e 	bne	r2,zero,4699c8 <OSTimeTick+0x200>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
  469974:	e0bff717 	ldw	r2,-36(fp)
  469978:	10c00d83 	ldbu	r3,54(r2)
  46997c:	d0a71703 	ldbu	r2,-25508(gp)
  469980:	1884b03a 	or	r2,r3,r2
  469984:	d0a71705 	stb	r2,-25508(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
  469988:	e0bff717 	ldw	r2,-36(fp)
  46998c:	10800d03 	ldbu	r2,52(r2)
  469990:	11003fcc 	andi	r4,r2,255
  469994:	e0bff717 	ldw	r2,-36(fp)
  469998:	10800d03 	ldbu	r2,52(r2)
  46999c:	10c03fcc 	andi	r3,r2,255
  4699a0:	d0a71744 	addi	r2,gp,-25507
  4699a4:	1885883a 	add	r2,r3,r2
  4699a8:	10c00003 	ldbu	r3,0(r2)
  4699ac:	e0bff717 	ldw	r2,-36(fp)
  4699b0:	10800d43 	ldbu	r2,53(r2)
  4699b4:	1884b03a 	or	r2,r3,r2
  4699b8:	1007883a 	mov	r3,r2
  4699bc:	d0a71744 	addi	r2,gp,-25507
  4699c0:	2085883a 	add	r2,r4,r2
  4699c4:	10c00005 	stb	r3,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
  4699c8:	e0bff717 	ldw	r2,-36(fp)
  4699cc:	10800517 	ldw	r2,20(r2)
  4699d0:	e0bff715 	stw	r2,-36(fp)
  4699d4:	e0bff917 	ldw	r2,-28(fp)
  4699d8:	e0bffe15 	stw	r2,-8(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  4699dc:	0005303a 	rdctl	r2,status
  4699e0:	e0bfff15 	stw	r2,-4(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  4699e4:	e0ffff17 	ldw	r3,-4(fp)
  4699e8:	00bfff84 	movi	r2,-2
  4699ec:	1884703a 	and	r2,r3,r2
  4699f0:	e0bfff15 	stw	r2,-4(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  4699f4:	e0bffe17 	ldw	r2,-8(fp)
  4699f8:	1080004c 	andi	r2,r2,1
  4699fc:	e0ffff17 	ldw	r3,-4(fp)
  469a00:	1884b03a 	or	r2,r3,r2
  469a04:	e0bfff15 	stw	r2,-4(fp)
  
  NIOS2_WRITE_STATUS (status);
  469a08:	e0bfff17 	ldw	r2,-4(fp)
  469a0c:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
  469a10:	e0bff717 	ldw	r2,-36(fp)
  469a14:	10800c83 	ldbu	r2,50(r2)
  469a18:	10803fcc 	andi	r2,r2,255
  469a1c:	10800518 	cmpnei	r2,r2,20
  469a20:	103fa71e 	bne	r2,zero,4698c0 <OSTimeTick+0xf8>
  469a24:	00000106 	br	469a2c <OSTimeTick+0x264>
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
  469a28:	0001883a 	nop
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
  469a2c:	e037883a 	mov	sp,fp
  469a30:	dfc00117 	ldw	ra,4(sp)
  469a34:	df000017 	ldw	fp,0(sp)
  469a38:	dec00204 	addi	sp,sp,8
  469a3c:	f800283a 	ret

00469a40 <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
  469a40:	deffff04 	addi	sp,sp,-4
  469a44:	df000015 	stw	fp,0(sp)
  469a48:	d839883a 	mov	fp,sp
    return (OS_VERSION);
  469a4c:	00804784 	movi	r2,286
}
  469a50:	e037883a 	mov	sp,fp
  469a54:	df000017 	ldw	fp,0(sp)
  469a58:	dec00104 	addi	sp,sp,4
  469a5c:	f800283a 	ret

00469a60 <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
  469a60:	deffff04 	addi	sp,sp,-4
  469a64:	df000015 	stw	fp,0(sp)
  469a68:	d839883a 	mov	fp,sp
}
  469a6c:	e037883a 	mov	sp,fp
  469a70:	df000017 	ldw	fp,0(sp)
  469a74:	dec00104 	addi	sp,sp,4
  469a78:	f800283a 	ret

00469a7c <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
  469a7c:	defff804 	addi	sp,sp,-32
  469a80:	dfc00715 	stw	ra,28(sp)
  469a84:	df000615 	stw	fp,24(sp)
  469a88:	df000604 	addi	fp,sp,24
  469a8c:	e13ffc15 	stw	r4,-16(fp)
  469a90:	e17ffd15 	stw	r5,-12(fp)
  469a94:	3007883a 	mov	r3,r6
  469a98:	3805883a 	mov	r2,r7
  469a9c:	e0fffe05 	stb	r3,-8(fp)
  469aa0:	e0bfff05 	stb	r2,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
  469aa4:	e0bffc17 	ldw	r2,-16(fp)
  469aa8:	10800283 	ldbu	r2,10(r2)
  469aac:	10803fcc 	andi	r2,r2,255
  469ab0:	00c011f4 	movhi	r3,71
  469ab4:	18d80e04 	addi	r3,r3,24632
  469ab8:	1885883a 	add	r2,r3,r2
  469abc:	10800003 	ldbu	r2,0(r2)
  469ac0:	e0bffa05 	stb	r2,-24(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
  469ac4:	e0bffa03 	ldbu	r2,-24(fp)
  469ac8:	e0fffc17 	ldw	r3,-16(fp)
  469acc:	1885883a 	add	r2,r3,r2
  469ad0:	10800204 	addi	r2,r2,8
  469ad4:	108000c3 	ldbu	r2,3(r2)
  469ad8:	10803fcc 	andi	r2,r2,255
  469adc:	00c011f4 	movhi	r3,71
  469ae0:	18d80e04 	addi	r3,r3,24632
  469ae4:	1885883a 	add	r2,r3,r2
  469ae8:	10800003 	ldbu	r2,0(r2)
  469aec:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
  469af0:	e0bffa03 	ldbu	r2,-24(fp)
  469af4:	100490fa 	slli	r2,r2,3
  469af8:	1007883a 	mov	r3,r2
  469afc:	e0bffa43 	ldbu	r2,-23(fp)
  469b00:	1885883a 	add	r2,r3,r2
  469b04:	e0bffa85 	stb	r2,-22(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
  469b08:	e0bffa83 	ldbu	r2,-22(fp)
  469b0c:	00c01234 	movhi	r3,72
  469b10:	18f31404 	addi	r3,r3,-13232
  469b14:	1085883a 	add	r2,r2,r2
  469b18:	1085883a 	add	r2,r2,r2
  469b1c:	1885883a 	add	r2,r3,r2
  469b20:	10800017 	ldw	r2,0(r2)
  469b24:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
  469b28:	e0bffb17 	ldw	r2,-20(fp)
  469b2c:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
  469b30:	e0bffb17 	ldw	r2,-20(fp)
  469b34:	e0fffd17 	ldw	r3,-12(fp)
  469b38:	10c00915 	stw	r3,36(r2)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
  469b3c:	e0bffb17 	ldw	r2,-20(fp)
  469b40:	10800c03 	ldbu	r2,48(r2)
  469b44:	1007883a 	mov	r3,r2
  469b48:	e0bffe03 	ldbu	r2,-8(fp)
  469b4c:	0084303a 	nor	r2,zero,r2
  469b50:	1884703a 	and	r2,r3,r2
  469b54:	1007883a 	mov	r3,r2
  469b58:	e0bffb17 	ldw	r2,-20(fp)
  469b5c:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
  469b60:	e0bffb17 	ldw	r2,-20(fp)
  469b64:	e0ffff03 	ldbu	r3,-4(fp)
  469b68:	10c00c45 	stb	r3,49(r2)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
  469b6c:	e0bffb17 	ldw	r2,-20(fp)
  469b70:	10800c03 	ldbu	r2,48(r2)
  469b74:	10803fcc 	andi	r2,r2,255
  469b78:	1080020c 	andi	r2,r2,8
  469b7c:	1000111e 	bne	r2,zero,469bc4 <OS_EventTaskRdy+0x148>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
  469b80:	e0bffb17 	ldw	r2,-20(fp)
  469b84:	10c00d83 	ldbu	r3,54(r2)
  469b88:	d0a71703 	ldbu	r2,-25508(gp)
  469b8c:	1884b03a 	or	r2,r3,r2
  469b90:	d0a71705 	stb	r2,-25508(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
  469b94:	e13ffa03 	ldbu	r4,-24(fp)
  469b98:	e0fffa03 	ldbu	r3,-24(fp)
  469b9c:	d0a71744 	addi	r2,gp,-25507
  469ba0:	1885883a 	add	r2,r3,r2
  469ba4:	10c00003 	ldbu	r3,0(r2)
  469ba8:	e0bffb17 	ldw	r2,-20(fp)
  469bac:	10800d43 	ldbu	r2,53(r2)
  469bb0:	1884b03a 	or	r2,r3,r2
  469bb4:	1007883a 	mov	r3,r2
  469bb8:	d0a71744 	addi	r2,gp,-25507
  469bbc:	2085883a 	add	r2,r4,r2
  469bc0:	10c00005 	stb	r3,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
  469bc4:	e13ffb17 	ldw	r4,-20(fp)
  469bc8:	e17ffc17 	ldw	r5,-16(fp)
  469bcc:	0469e640 	call	469e64 <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
  469bd0:	e0bffb17 	ldw	r2,-20(fp)
  469bd4:	10800817 	ldw	r2,32(r2)
  469bd8:	10000826 	beq	r2,zero,469bfc <OS_EventTaskRdy+0x180>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
  469bdc:	e0bffb17 	ldw	r2,-20(fp)
  469be0:	10800817 	ldw	r2,32(r2)
  469be4:	e13ffb17 	ldw	r4,-20(fp)
  469be8:	100b883a 	mov	r5,r2
  469bec:	0469f140 	call	469f14 <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
  469bf0:	e0bffb17 	ldw	r2,-20(fp)
  469bf4:	e0fffc17 	ldw	r3,-16(fp)
  469bf8:	10c00715 	stw	r3,28(r2)
    }
#endif

    return (prio);
  469bfc:	e0bffa83 	ldbu	r2,-22(fp)
}
  469c00:	e037883a 	mov	sp,fp
  469c04:	dfc00117 	ldw	ra,4(sp)
  469c08:	df000017 	ldw	fp,0(sp)
  469c0c:	dec00204 	addi	sp,sp,8
  469c10:	f800283a 	ret

00469c14 <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
  469c14:	defffd04 	addi	sp,sp,-12
  469c18:	df000215 	stw	fp,8(sp)
  469c1c:	df000204 	addi	fp,sp,8
  469c20:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
  469c24:	d0a71a17 	ldw	r2,-25496(gp)
  469c28:	e0ffff17 	ldw	r3,-4(fp)
  469c2c:	10c00715 	stw	r3,28(r2)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
  469c30:	d0a71a17 	ldw	r2,-25496(gp)
  469c34:	10800d03 	ldbu	r2,52(r2)
  469c38:	10803fcc 	andi	r2,r2,255
  469c3c:	d0e71a17 	ldw	r3,-25496(gp)
  469c40:	18c00d03 	ldbu	r3,52(r3)
  469c44:	18c03fcc 	andi	r3,r3,255
  469c48:	e13fff17 	ldw	r4,-4(fp)
  469c4c:	20c7883a 	add	r3,r4,r3
  469c50:	18c00204 	addi	r3,r3,8
  469c54:	190000c3 	ldbu	r4,3(r3)
  469c58:	d0e71a17 	ldw	r3,-25496(gp)
  469c5c:	18c00d43 	ldbu	r3,53(r3)
  469c60:	20c6b03a 	or	r3,r4,r3
  469c64:	e13fff17 	ldw	r4,-4(fp)
  469c68:	2085883a 	add	r2,r4,r2
  469c6c:	10800204 	addi	r2,r2,8
  469c70:	10c000c5 	stb	r3,3(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
  469c74:	e0bfff17 	ldw	r2,-4(fp)
  469c78:	10c00283 	ldbu	r3,10(r2)
  469c7c:	d0a71a17 	ldw	r2,-25496(gp)
  469c80:	10800d83 	ldbu	r2,54(r2)
  469c84:	1884b03a 	or	r2,r3,r2
  469c88:	1007883a 	mov	r3,r2
  469c8c:	e0bfff17 	ldw	r2,-4(fp)
  469c90:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
  469c94:	d0a71a17 	ldw	r2,-25496(gp)
  469c98:	10800d03 	ldbu	r2,52(r2)
  469c9c:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
  469ca0:	e13ffe03 	ldbu	r4,-8(fp)
  469ca4:	e0fffe03 	ldbu	r3,-8(fp)
  469ca8:	d0a71744 	addi	r2,gp,-25507
  469cac:	1885883a 	add	r2,r3,r2
  469cb0:	10800003 	ldbu	r2,0(r2)
  469cb4:	1007883a 	mov	r3,r2
  469cb8:	d0a71a17 	ldw	r2,-25496(gp)
  469cbc:	10800d43 	ldbu	r2,53(r2)
  469cc0:	0084303a 	nor	r2,zero,r2
  469cc4:	1884703a 	and	r2,r3,r2
  469cc8:	1007883a 	mov	r3,r2
  469ccc:	d0a71744 	addi	r2,gp,-25507
  469cd0:	2085883a 	add	r2,r4,r2
  469cd4:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0) {
  469cd8:	e0fffe03 	ldbu	r3,-8(fp)
  469cdc:	d0a71744 	addi	r2,gp,-25507
  469ce0:	1885883a 	add	r2,r3,r2
  469ce4:	10800003 	ldbu	r2,0(r2)
  469ce8:	10803fcc 	andi	r2,r2,255
  469cec:	1000071e 	bne	r2,zero,469d0c <OS_EventTaskWait+0xf8>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
  469cf0:	d0a71a17 	ldw	r2,-25496(gp)
  469cf4:	10800d83 	ldbu	r2,54(r2)
  469cf8:	0084303a 	nor	r2,zero,r2
  469cfc:	1007883a 	mov	r3,r2
  469d00:	d0a71703 	ldbu	r2,-25508(gp)
  469d04:	1884703a 	and	r2,r3,r2
  469d08:	d0a71705 	stb	r2,-25508(gp)
    }
}
  469d0c:	e037883a 	mov	sp,fp
  469d10:	df000017 	ldw	fp,0(sp)
  469d14:	dec00104 	addi	sp,sp,4
  469d18:	f800283a 	ret

00469d1c <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
  469d1c:	defffb04 	addi	sp,sp,-20
  469d20:	df000415 	stw	fp,16(sp)
  469d24:	df000404 	addi	fp,sp,16
  469d28:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
  469d2c:	d0a71a17 	ldw	r2,-25496(gp)
  469d30:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
  469d34:	d0a71a17 	ldw	r2,-25496(gp)
  469d38:	e0ffff17 	ldw	r3,-4(fp)
  469d3c:	10c00815 	stw	r3,32(r2)

    pevents =  pevents_wait;
  469d40:	e0bfff17 	ldw	r2,-4(fp)
  469d44:	e0bffc15 	stw	r2,-16(fp)
    pevent  = *pevents;
  469d48:	e0bffc17 	ldw	r2,-16(fp)
  469d4c:	10800017 	ldw	r2,0(r2)
  469d50:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
  469d54:	00001f06 	br	469dd4 <OS_EventTaskWaitMulti+0xb8>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
  469d58:	d0a71a17 	ldw	r2,-25496(gp)
  469d5c:	10800d03 	ldbu	r2,52(r2)
  469d60:	10803fcc 	andi	r2,r2,255
  469d64:	d0e71a17 	ldw	r3,-25496(gp)
  469d68:	18c00d03 	ldbu	r3,52(r3)
  469d6c:	18c03fcc 	andi	r3,r3,255
  469d70:	e13ffd17 	ldw	r4,-12(fp)
  469d74:	20c7883a 	add	r3,r4,r3
  469d78:	18c00204 	addi	r3,r3,8
  469d7c:	190000c3 	ldbu	r4,3(r3)
  469d80:	d0e71a17 	ldw	r3,-25496(gp)
  469d84:	18c00d43 	ldbu	r3,53(r3)
  469d88:	20c6b03a 	or	r3,r4,r3
  469d8c:	e13ffd17 	ldw	r4,-12(fp)
  469d90:	2085883a 	add	r2,r4,r2
  469d94:	10800204 	addi	r2,r2,8
  469d98:	10c000c5 	stb	r3,3(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
  469d9c:	e0bffd17 	ldw	r2,-12(fp)
  469da0:	10c00283 	ldbu	r3,10(r2)
  469da4:	d0a71a17 	ldw	r2,-25496(gp)
  469da8:	10800d83 	ldbu	r2,54(r2)
  469dac:	1884b03a 	or	r2,r3,r2
  469db0:	1007883a 	mov	r3,r2
  469db4:	e0bffd17 	ldw	r2,-12(fp)
  469db8:	10c00285 	stb	r3,10(r2)
        pevents++;
  469dbc:	e0bffc17 	ldw	r2,-16(fp)
  469dc0:	10800104 	addi	r2,r2,4
  469dc4:	e0bffc15 	stw	r2,-16(fp)
        pevent = *pevents;
  469dc8:	e0bffc17 	ldw	r2,-16(fp)
  469dcc:	10800017 	ldw	r2,0(r2)
  469dd0:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
  469dd4:	e0bffd17 	ldw	r2,-12(fp)
  469dd8:	103fdf1e 	bne	r2,zero,469d58 <OS_EventTaskWaitMulti+0x3c>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
  469ddc:	d0a71a17 	ldw	r2,-25496(gp)
  469de0:	10800d03 	ldbu	r2,52(r2)
  469de4:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
  469de8:	e13ffe03 	ldbu	r4,-8(fp)
  469dec:	e0fffe03 	ldbu	r3,-8(fp)
  469df0:	d0a71744 	addi	r2,gp,-25507
  469df4:	1885883a 	add	r2,r3,r2
  469df8:	10800003 	ldbu	r2,0(r2)
  469dfc:	1007883a 	mov	r3,r2
  469e00:	d0a71a17 	ldw	r2,-25496(gp)
  469e04:	10800d43 	ldbu	r2,53(r2)
  469e08:	0084303a 	nor	r2,zero,r2
  469e0c:	1884703a 	and	r2,r3,r2
  469e10:	1007883a 	mov	r3,r2
  469e14:	d0a71744 	addi	r2,gp,-25507
  469e18:	2085883a 	add	r2,r4,r2
  469e1c:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0) {
  469e20:	e0fffe03 	ldbu	r3,-8(fp)
  469e24:	d0a71744 	addi	r2,gp,-25507
  469e28:	1885883a 	add	r2,r3,r2
  469e2c:	10800003 	ldbu	r2,0(r2)
  469e30:	10803fcc 	andi	r2,r2,255
  469e34:	1000071e 	bne	r2,zero,469e54 <OS_EventTaskWaitMulti+0x138>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
  469e38:	d0a71a17 	ldw	r2,-25496(gp)
  469e3c:	10800d83 	ldbu	r2,54(r2)
  469e40:	0084303a 	nor	r2,zero,r2
  469e44:	1007883a 	mov	r3,r2
  469e48:	d0a71703 	ldbu	r2,-25508(gp)
  469e4c:	1884703a 	and	r2,r3,r2
  469e50:	d0a71705 	stb	r2,-25508(gp)
    }
}
  469e54:	e037883a 	mov	sp,fp
  469e58:	df000017 	ldw	fp,0(sp)
  469e5c:	dec00104 	addi	sp,sp,4
  469e60:	f800283a 	ret

00469e64 <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
  469e64:	defffc04 	addi	sp,sp,-16
  469e68:	df000315 	stw	fp,12(sp)
  469e6c:	df000304 	addi	fp,sp,12
  469e70:	e13ffe15 	stw	r4,-8(fp)
  469e74:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
  469e78:	e0bffe17 	ldw	r2,-8(fp)
  469e7c:	10800d03 	ldbu	r2,52(r2)
  469e80:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
  469e84:	e0bffd03 	ldbu	r2,-12(fp)
  469e88:	e0fffd03 	ldbu	r3,-12(fp)
  469e8c:	e13fff17 	ldw	r4,-4(fp)
  469e90:	20c7883a 	add	r3,r4,r3
  469e94:	18c00204 	addi	r3,r3,8
  469e98:	18c000c3 	ldbu	r3,3(r3)
  469e9c:	1809883a 	mov	r4,r3
  469ea0:	e0fffe17 	ldw	r3,-8(fp)
  469ea4:	18c00d43 	ldbu	r3,53(r3)
  469ea8:	00c6303a 	nor	r3,zero,r3
  469eac:	20c6703a 	and	r3,r4,r3
  469eb0:	e13fff17 	ldw	r4,-4(fp)
  469eb4:	2085883a 	add	r2,r4,r2
  469eb8:	10800204 	addi	r2,r2,8
  469ebc:	10c000c5 	stb	r3,3(r2)
    if (pevent->OSEventTbl[y] == 0) {
  469ec0:	e0bffd03 	ldbu	r2,-12(fp)
  469ec4:	e0ffff17 	ldw	r3,-4(fp)
  469ec8:	1885883a 	add	r2,r3,r2
  469ecc:	10800204 	addi	r2,r2,8
  469ed0:	108000c3 	ldbu	r2,3(r2)
  469ed4:	10803fcc 	andi	r2,r2,255
  469ed8:	10000a1e 	bne	r2,zero,469f04 <OS_EventTaskRemove+0xa0>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
  469edc:	e0bfff17 	ldw	r2,-4(fp)
  469ee0:	10800283 	ldbu	r2,10(r2)
  469ee4:	1007883a 	mov	r3,r2
  469ee8:	e0bffe17 	ldw	r2,-8(fp)
  469eec:	10800d83 	ldbu	r2,54(r2)
  469ef0:	0084303a 	nor	r2,zero,r2
  469ef4:	1884703a 	and	r2,r3,r2
  469ef8:	1007883a 	mov	r3,r2
  469efc:	e0bfff17 	ldw	r2,-4(fp)
  469f00:	10c00285 	stb	r3,10(r2)
    }
}
  469f04:	e037883a 	mov	sp,fp
  469f08:	df000017 	ldw	fp,0(sp)
  469f0c:	dec00104 	addi	sp,sp,4
  469f10:	f800283a 	ret

00469f14 <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
  469f14:	defffa04 	addi	sp,sp,-24
  469f18:	df000515 	stw	fp,20(sp)
  469f1c:	df000504 	addi	fp,sp,20
  469f20:	e13ffe15 	stw	r4,-8(fp)
  469f24:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
  469f28:	e0bffe17 	ldw	r2,-8(fp)
  469f2c:	10800d03 	ldbu	r2,52(r2)
  469f30:	e0bffd05 	stb	r2,-12(fp)
    bity    =  ptcb->OSTCBBitY;
  469f34:	e0bffe17 	ldw	r2,-8(fp)
  469f38:	10800d83 	ldbu	r2,54(r2)
  469f3c:	e0bffd45 	stb	r2,-11(fp)
    bitx    =  ptcb->OSTCBBitX;
  469f40:	e0bffe17 	ldw	r2,-8(fp)
  469f44:	10800d43 	ldbu	r2,53(r2)
  469f48:	e0bffd85 	stb	r2,-10(fp)
    pevents =  pevents_multi;
  469f4c:	e0bfff17 	ldw	r2,-4(fp)
  469f50:	e0bffb15 	stw	r2,-20(fp)
    pevent  = *pevents;
  469f54:	e0bffb17 	ldw	r2,-20(fp)
  469f58:	10800017 	ldw	r2,0(r2)
  469f5c:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
  469f60:	00002406 	br	469ff4 <OS_EventTaskRemoveMulti+0xe0>
        pevent->OSEventTbl[y]  &= ~bitx;
  469f64:	e0bffd03 	ldbu	r2,-12(fp)
  469f68:	e0fffd03 	ldbu	r3,-12(fp)
  469f6c:	e13ffc17 	ldw	r4,-16(fp)
  469f70:	20c7883a 	add	r3,r4,r3
  469f74:	18c00204 	addi	r3,r3,8
  469f78:	18c000c3 	ldbu	r3,3(r3)
  469f7c:	1809883a 	mov	r4,r3
  469f80:	e0fffd83 	ldbu	r3,-10(fp)
  469f84:	00c6303a 	nor	r3,zero,r3
  469f88:	20c6703a 	and	r3,r4,r3
  469f8c:	e13ffc17 	ldw	r4,-16(fp)
  469f90:	2085883a 	add	r2,r4,r2
  469f94:	10800204 	addi	r2,r2,8
  469f98:	10c000c5 	stb	r3,3(r2)
        if (pevent->OSEventTbl[y] == 0) {
  469f9c:	e0bffd03 	ldbu	r2,-12(fp)
  469fa0:	e0fffc17 	ldw	r3,-16(fp)
  469fa4:	1885883a 	add	r2,r3,r2
  469fa8:	10800204 	addi	r2,r2,8
  469fac:	108000c3 	ldbu	r2,3(r2)
  469fb0:	10803fcc 	andi	r2,r2,255
  469fb4:	1000091e 	bne	r2,zero,469fdc <OS_EventTaskRemoveMulti+0xc8>
            pevent->OSEventGrp &= ~bity;
  469fb8:	e0bffc17 	ldw	r2,-16(fp)
  469fbc:	10800283 	ldbu	r2,10(r2)
  469fc0:	1007883a 	mov	r3,r2
  469fc4:	e0bffd43 	ldbu	r2,-11(fp)
  469fc8:	0084303a 	nor	r2,zero,r2
  469fcc:	1884703a 	and	r2,r3,r2
  469fd0:	1007883a 	mov	r3,r2
  469fd4:	e0bffc17 	ldw	r2,-16(fp)
  469fd8:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
  469fdc:	e0bffb17 	ldw	r2,-20(fp)
  469fe0:	10800104 	addi	r2,r2,4
  469fe4:	e0bffb15 	stw	r2,-20(fp)
        pevent = *pevents;
  469fe8:	e0bffb17 	ldw	r2,-20(fp)
  469fec:	10800017 	ldw	r2,0(r2)
  469ff0:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
  469ff4:	e0bffc17 	ldw	r2,-16(fp)
  469ff8:	103fda1e 	bne	r2,zero,469f64 <OS_EventTaskRemoveMulti+0x50>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
  469ffc:	e037883a 	mov	sp,fp
  46a000:	df000017 	ldw	fp,0(sp)
  46a004:	dec00104 	addi	sp,sp,4
  46a008:	f800283a 	ret

0046a00c <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
  46a00c:	defffc04 	addi	sp,sp,-16
  46a010:	df000315 	stw	fp,12(sp)
  46a014:	df000304 	addi	fp,sp,12
  46a018:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
  46a01c:	e0bfff17 	ldw	r2,-4(fp)
  46a020:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
  46a024:	e0bfff17 	ldw	r2,-4(fp)
  46a028:	108002c4 	addi	r2,r2,11
  46a02c:	e0bffd15 	stw	r2,-12(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
  46a030:	e03ffe05 	stb	zero,-8(fp)
  46a034:	00000806 	br	46a058 <OS_EventWaitListInit+0x4c>
        *ptbl++ = 0;
  46a038:	e0bffd17 	ldw	r2,-12(fp)
  46a03c:	10000005 	stb	zero,0(r2)
  46a040:	e0bffd17 	ldw	r2,-12(fp)
  46a044:	10800044 	addi	r2,r2,1
  46a048:	e0bffd15 	stw	r2,-12(fp)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
  46a04c:	e0bffe03 	ldbu	r2,-8(fp)
  46a050:	10800044 	addi	r2,r2,1
  46a054:	e0bffe05 	stb	r2,-8(fp)
  46a058:	e0bffe03 	ldbu	r2,-8(fp)
  46a05c:	108000f0 	cmpltui	r2,r2,3
  46a060:	103ff51e 	bne	r2,zero,46a038 <OS_EventWaitListInit+0x2c>
        *ptbl++ = 0;
    }
}
  46a064:	e037883a 	mov	sp,fp
  46a068:	df000017 	ldw	fp,0(sp)
  46a06c:	dec00104 	addi	sp,sp,4
  46a070:	f800283a 	ret

0046a074 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
  46a074:	defffb04 	addi	sp,sp,-20
  46a078:	dfc00415 	stw	ra,16(sp)
  46a07c:	df000315 	stw	fp,12(sp)
  46a080:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
  46a084:	01001234 	movhi	r4,72
  46a088:	212f0004 	addi	r4,r4,-17408
  46a08c:	0142d004 	movi	r5,2880
  46a090:	046a3d80 	call	46a3d8 <OS_MemClr>
    pevent1 = &OSEventTbl[0];
  46a094:	00801234 	movhi	r2,72
  46a098:	10af0004 	addi	r2,r2,-17408
  46a09c:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
  46a0a0:	00801234 	movhi	r2,72
  46a0a4:	10af0c04 	addi	r2,r2,-17360
  46a0a8:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
  46a0ac:	e03ffd0d 	sth	zero,-12(fp)
  46a0b0:	00001306 	br	46a100 <OS_InitEventList+0x8c>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
  46a0b4:	e0bffe17 	ldw	r2,-8(fp)
  46a0b8:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
  46a0bc:	e0bffe17 	ldw	r2,-8(fp)
  46a0c0:	e0ffff17 	ldw	r3,-4(fp)
  46a0c4:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
  46a0c8:	e0bffe17 	ldw	r2,-8(fp)
  46a0cc:	00c00fc4 	movi	r3,63
  46a0d0:	10c00385 	stb	r3,14(r2)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
  46a0d4:	e0bffe17 	ldw	r2,-8(fp)
  46a0d8:	100003c5 	stb	zero,15(r2)
#endif
        pevent1++;
  46a0dc:	e0bffe17 	ldw	r2,-8(fp)
  46a0e0:	10800c04 	addi	r2,r2,48
  46a0e4:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
  46a0e8:	e0bfff17 	ldw	r2,-4(fp)
  46a0ec:	10800c04 	addi	r2,r2,48
  46a0f0:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
  46a0f4:	e0bffd0b 	ldhu	r2,-12(fp)
  46a0f8:	10800044 	addi	r2,r2,1
  46a0fc:	e0bffd0d 	sth	r2,-12(fp)
  46a100:	e0bffd0b 	ldhu	r2,-12(fp)
  46a104:	10800ef0 	cmpltui	r2,r2,59
  46a108:	103fea1e 	bne	r2,zero,46a0b4 <OS_InitEventList+0x40>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
  46a10c:	e0bffe17 	ldw	r2,-8(fp)
  46a110:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
  46a114:	e0bffe17 	ldw	r2,-8(fp)
  46a118:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
  46a11c:	e0bffe17 	ldw	r2,-8(fp)
  46a120:	00c00fc4 	movi	r3,63
  46a124:	10c00385 	stb	r3,14(r2)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
  46a128:	e0bffe17 	ldw	r2,-8(fp)
  46a12c:	100003c5 	stb	zero,15(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
  46a130:	00801234 	movhi	r2,72
  46a134:	10af0004 	addi	r2,r2,-17408
  46a138:	d0a71815 	stw	r2,-25504(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
  46a13c:	e037883a 	mov	sp,fp
  46a140:	dfc00117 	ldw	ra,4(sp)
  46a144:	df000017 	ldw	fp,0(sp)
  46a148:	dec00204 	addi	sp,sp,8
  46a14c:	f800283a 	ret

0046a150 <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
  46a150:	deffff04 	addi	sp,sp,-4
  46a154:	df000015 	stw	fp,0(sp)
  46a158:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
  46a15c:	d0271b15 	stw	zero,-25492(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
  46a160:	d0271905 	stb	zero,-25500(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
  46a164:	d0270b05 	stb	zero,-25556(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
  46a168:	d0271345 	stb	zero,-25523(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
  46a16c:	d0270b45 	stb	zero,-25555(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
  46a170:	d0271015 	stw	zero,-25536(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
  46a174:	d0270c15 	stw	zero,-25552(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
  46a178:	d0271e15 	stw	zero,-25480(gp)
    OSIdleCtrMax  = 0L;
  46a17c:	d0271115 	stw	zero,-25532(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
  46a180:	d0271d05 	stb	zero,-25484(gp)
#endif
}
  46a184:	e037883a 	mov	sp,fp
  46a188:	df000017 	ldw	fp,0(sp)
  46a18c:	dec00104 	addi	sp,sp,4
  46a190:	f800283a 	ret

0046a194 <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
  46a194:	defffd04 	addi	sp,sp,-12
  46a198:	df000215 	stw	fp,8(sp)
  46a19c:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
  46a1a0:	d0271705 	stb	zero,-25508(gp)
    prdytbl       = &OSRdyTbl[0];
  46a1a4:	d0a71744 	addi	r2,gp,-25507
  46a1a8:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
  46a1ac:	e03ffe05 	stb	zero,-8(fp)
  46a1b0:	00000806 	br	46a1d4 <OS_InitRdyList+0x40>
        *prdytbl++ = 0;
  46a1b4:	e0bfff17 	ldw	r2,-4(fp)
  46a1b8:	10000005 	stb	zero,0(r2)
  46a1bc:	e0bfff17 	ldw	r2,-4(fp)
  46a1c0:	10800044 	addi	r2,r2,1
  46a1c4:	e0bfff15 	stw	r2,-4(fp)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
  46a1c8:	e0bffe03 	ldbu	r2,-8(fp)
  46a1cc:	10800044 	addi	r2,r2,1
  46a1d0:	e0bffe05 	stb	r2,-8(fp)
  46a1d4:	e0bffe03 	ldbu	r2,-8(fp)
  46a1d8:	108000f0 	cmpltui	r2,r2,3
  46a1dc:	103ff51e 	bne	r2,zero,46a1b4 <OS_InitRdyList+0x20>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
  46a1e0:	d0270d45 	stb	zero,-25547(gp)
    OSPrioHighRdy = 0;
  46a1e4:	d0270d05 	stb	zero,-25548(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
  46a1e8:	d0271515 	stw	zero,-25516(gp)
    OSTCBCur      = (OS_TCB *)0;
  46a1ec:	d0271a15 	stw	zero,-25496(gp)
}
  46a1f0:	e037883a 	mov	sp,fp
  46a1f4:	df000017 	ldw	fp,0(sp)
  46a1f8:	dec00104 	addi	sp,sp,4
  46a1fc:	f800283a 	ret

0046a200 <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
  46a200:	defff804 	addi	sp,sp,-32
  46a204:	dfc00715 	stw	ra,28(sp)
  46a208:	df000615 	stw	fp,24(sp)
  46a20c:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
  46a210:	00bfffd4 	movui	r2,65535
  46a214:	d8800015 	stw	r2,0(sp)
  46a218:	00801234 	movhi	r2,72
  46a21c:	10ad0004 	addi	r2,r2,-19456
  46a220:	d8800115 	stw	r2,4(sp)
  46a224:	00808004 	movi	r2,512
  46a228:	d8800215 	stw	r2,8(sp)
  46a22c:	d8000315 	stw	zero,12(sp)
  46a230:	008000c4 	movi	r2,3
  46a234:	d8800415 	stw	r2,16(sp)
  46a238:	010011f4 	movhi	r4,71
  46a23c:	2129b404 	addi	r4,r4,-22832
  46a240:	000b883a 	mov	r5,zero
  46a244:	01801234 	movhi	r6,72
  46a248:	31aeff04 	addi	r6,r6,-17412
  46a24c:	01c00504 	movi	r7,20
  46a250:	04701940 	call	470194 <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
  46a254:	01000504 	movi	r4,20
  46a258:	014011f4 	movhi	r5,71
  46a25c:	29584e04 	addi	r5,r5,24888
  46a260:	e1bfff04 	addi	r6,fp,-4
  46a264:	0470cf80 	call	470cf8 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
  46a268:	e037883a 	mov	sp,fp
  46a26c:	dfc00117 	ldw	ra,4(sp)
  46a270:	df000017 	ldw	fp,0(sp)
  46a274:	dec00204 	addi	sp,sp,8
  46a278:	f800283a 	ret

0046a27c <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
  46a27c:	defff804 	addi	sp,sp,-32
  46a280:	dfc00715 	stw	ra,28(sp)
  46a284:	df000615 	stw	fp,24(sp)
  46a288:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
  46a28c:	00bfff94 	movui	r2,65534
  46a290:	d8800015 	stw	r2,0(sp)
  46a294:	00801234 	movhi	r2,72
  46a298:	10aa8804 	addi	r2,r2,-21984
  46a29c:	d8800115 	stw	r2,4(sp)
  46a2a0:	00808004 	movi	r2,512
  46a2a4:	d8800215 	stw	r2,8(sp)
  46a2a8:	d8000315 	stw	zero,12(sp)
  46a2ac:	008000c4 	movi	r2,3
  46a2b0:	d8800415 	stw	r2,16(sp)
  46a2b4:	010011f4 	movhi	r4,71
  46a2b8:	2129d604 	addi	r4,r4,-22696
  46a2bc:	000b883a 	mov	r5,zero
  46a2c0:	01801234 	movhi	r6,72
  46a2c4:	31ac8704 	addi	r6,r6,-19940
  46a2c8:	01c004c4 	movi	r7,19
  46a2cc:	04701940 	call	470194 <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
  46a2d0:	010004c4 	movi	r4,19
  46a2d4:	014011f4 	movhi	r5,71
  46a2d8:	29585204 	addi	r5,r5,24904
  46a2dc:	e1bfff04 	addi	r6,fp,-4
  46a2e0:	0470cf80 	call	470cf8 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
  46a2e4:	e037883a 	mov	sp,fp
  46a2e8:	dfc00117 	ldw	ra,4(sp)
  46a2ec:	df000017 	ldw	fp,0(sp)
  46a2f0:	dec00204 	addi	sp,sp,8
  46a2f4:	f800283a 	ret

0046a2f8 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
  46a2f8:	defffb04 	addi	sp,sp,-20
  46a2fc:	dfc00415 	stw	ra,16(sp)
  46a300:	df000315 	stw	fp,12(sp)
  46a304:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
  46a308:	01001234 	movhi	r4,72
  46a30c:	2131d004 	addi	r4,r4,-14528
  46a310:	01414404 	movi	r5,1296
  46a314:	046a3d80 	call	46a3d8 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
  46a318:	01001234 	movhi	r4,72
  46a31c:	21331404 	addi	r4,r4,-13232
  46a320:	01401504 	movi	r5,84
  46a324:	046a3d80 	call	46a3d8 <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
  46a328:	00801234 	movhi	r2,72
  46a32c:	10b1d004 	addi	r2,r2,-14528
  46a330:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
  46a334:	00801234 	movhi	r2,72
  46a338:	10b1eb04 	addi	r2,r2,-14420
  46a33c:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
  46a340:	e03ffd05 	stb	zero,-12(fp)
  46a344:	00001106 	br	46a38c <OS_InitTCBList+0x94>
        ptcb1->OSTCBNext = ptcb2;
  46a348:	e0bffe17 	ldw	r2,-8(fp)
  46a34c:	e0ffff17 	ldw	r3,-4(fp)
  46a350:	10c00515 	stw	r3,20(r2)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
  46a354:	e0bffe17 	ldw	r2,-8(fp)
  46a358:	00c00fc4 	movi	r3,63
  46a35c:	10c01305 	stb	r3,76(r2)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
  46a360:	e0bffe17 	ldw	r2,-8(fp)
  46a364:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
  46a368:	e0bffe17 	ldw	r2,-8(fp)
  46a36c:	10801b04 	addi	r2,r2,108
  46a370:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
  46a374:	e0bfff17 	ldw	r2,-4(fp)
  46a378:	10801b04 	addi	r2,r2,108
  46a37c:	e0bfff15 	stw	r2,-4(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
  46a380:	e0bffd03 	ldbu	r2,-12(fp)
  46a384:	10800044 	addi	r2,r2,1
  46a388:	e0bffd05 	stb	r2,-12(fp)
  46a38c:	e0bffd03 	ldbu	r2,-12(fp)
  46a390:	108002f0 	cmpltui	r2,r2,11
  46a394:	103fec1e 	bne	r2,zero,46a348 <OS_InitTCBList+0x50>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
  46a398:	e0bffe17 	ldw	r2,-8(fp)
  46a39c:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
  46a3a0:	e0bffe17 	ldw	r2,-8(fp)
  46a3a4:	00c00fc4 	movi	r3,63
  46a3a8:	10c01305 	stb	r3,76(r2)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
  46a3ac:	e0bffe17 	ldw	r2,-8(fp)
  46a3b0:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
  46a3b4:	d0270e15 	stw	zero,-25544(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
  46a3b8:	00801234 	movhi	r2,72
  46a3bc:	10b1d004 	addi	r2,r2,-14528
  46a3c0:	d0a71215 	stw	r2,-25528(gp)
}
  46a3c4:	e037883a 	mov	sp,fp
  46a3c8:	dfc00117 	ldw	ra,4(sp)
  46a3cc:	df000017 	ldw	fp,0(sp)
  46a3d0:	dec00204 	addi	sp,sp,8
  46a3d4:	f800283a 	ret

0046a3d8 <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
  46a3d8:	defffd04 	addi	sp,sp,-12
  46a3dc:	df000215 	stw	fp,8(sp)
  46a3e0:	df000204 	addi	fp,sp,8
  46a3e4:	e13ffe15 	stw	r4,-8(fp)
  46a3e8:	2805883a 	mov	r2,r5
  46a3ec:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
  46a3f0:	00000806 	br	46a414 <OS_MemClr+0x3c>
        *pdest++ = (INT8U)0;
  46a3f4:	e0bffe17 	ldw	r2,-8(fp)
  46a3f8:	10000005 	stb	zero,0(r2)
  46a3fc:	e0bffe17 	ldw	r2,-8(fp)
  46a400:	10800044 	addi	r2,r2,1
  46a404:	e0bffe15 	stw	r2,-8(fp)
        size--;
  46a408:	e0bfff0b 	ldhu	r2,-4(fp)
  46a40c:	10bfffc4 	addi	r2,r2,-1
  46a410:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
  46a414:	e0bfff0b 	ldhu	r2,-4(fp)
  46a418:	103ff61e 	bne	r2,zero,46a3f4 <OS_MemClr+0x1c>
        *pdest++ = (INT8U)0;
        size--;
    }
}
  46a41c:	e037883a 	mov	sp,fp
  46a420:	df000017 	ldw	fp,0(sp)
  46a424:	dec00104 	addi	sp,sp,4
  46a428:	f800283a 	ret

0046a42c <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
  46a42c:	defffc04 	addi	sp,sp,-16
  46a430:	df000315 	stw	fp,12(sp)
  46a434:	df000304 	addi	fp,sp,12
  46a438:	e13ffd15 	stw	r4,-12(fp)
  46a43c:	e17ffe15 	stw	r5,-8(fp)
  46a440:	3005883a 	mov	r2,r6
  46a444:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
  46a448:	00000d06 	br	46a480 <OS_MemCopy+0x54>
        *pdest++ = *psrc++;
  46a44c:	e0bffe17 	ldw	r2,-8(fp)
  46a450:	10c00003 	ldbu	r3,0(r2)
  46a454:	e0bffd17 	ldw	r2,-12(fp)
  46a458:	10c00005 	stb	r3,0(r2)
  46a45c:	e0bffd17 	ldw	r2,-12(fp)
  46a460:	10800044 	addi	r2,r2,1
  46a464:	e0bffd15 	stw	r2,-12(fp)
  46a468:	e0bffe17 	ldw	r2,-8(fp)
  46a46c:	10800044 	addi	r2,r2,1
  46a470:	e0bffe15 	stw	r2,-8(fp)
        size--;
  46a474:	e0bfff0b 	ldhu	r2,-4(fp)
  46a478:	10bfffc4 	addi	r2,r2,-1
  46a47c:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
  46a480:	e0bfff0b 	ldhu	r2,-4(fp)
  46a484:	103ff11e 	bne	r2,zero,46a44c <OS_MemCopy+0x20>
        *pdest++ = *psrc++;
        size--;
    }
}
  46a488:	e037883a 	mov	sp,fp
  46a48c:	df000017 	ldw	fp,0(sp)
  46a490:	dec00104 	addi	sp,sp,4
  46a494:	f800283a 	ret

0046a498 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
  46a498:	defffa04 	addi	sp,sp,-24
  46a49c:	dfc00515 	stw	ra,20(sp)
  46a4a0:	df000415 	stw	fp,16(sp)
  46a4a4:	df000404 	addi	fp,sp,16
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
  46a4a8:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46a4ac:	0005303a 	rdctl	r2,status
  46a4b0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46a4b4:	e0fffd17 	ldw	r3,-12(fp)
  46a4b8:	00bfff84 	movi	r2,-2
  46a4bc:	1884703a 	and	r2,r3,r2
  46a4c0:	1001703a 	wrctl	status,r2
  
  return context;
  46a4c4:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
  46a4c8:	e0bffc15 	stw	r2,-16(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
  46a4cc:	d0a71903 	ldbu	r2,-25500(gp)
  46a4d0:	10803fcc 	andi	r2,r2,255
  46a4d4:	10001a1e 	bne	r2,zero,46a540 <OS_Sched+0xa8>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
  46a4d8:	d0a70b03 	ldbu	r2,-25556(gp)
  46a4dc:	10803fcc 	andi	r2,r2,255
  46a4e0:	1000171e 	bne	r2,zero,46a540 <OS_Sched+0xa8>
            OS_SchedNew();
  46a4e4:	046a5900 	call	46a590 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
  46a4e8:	d0e70d03 	ldbu	r3,-25548(gp)
  46a4ec:	d0a70d43 	ldbu	r2,-25547(gp)
  46a4f0:	18c03fcc 	andi	r3,r3,255
  46a4f4:	10803fcc 	andi	r2,r2,255
  46a4f8:	18801126 	beq	r3,r2,46a540 <OS_Sched+0xa8>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
  46a4fc:	d0a70d03 	ldbu	r2,-25548(gp)
  46a500:	10803fcc 	andi	r2,r2,255
  46a504:	00c01234 	movhi	r3,72
  46a508:	18f31404 	addi	r3,r3,-13232
  46a50c:	1085883a 	add	r2,r2,r2
  46a510:	1085883a 	add	r2,r2,r2
  46a514:	1885883a 	add	r2,r3,r2
  46a518:	10800017 	ldw	r2,0(r2)
  46a51c:	d0a71515 	stw	r2,-25516(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
  46a520:	d0a71517 	ldw	r2,-25516(gp)
  46a524:	10c00e17 	ldw	r3,56(r2)
  46a528:	18c00044 	addi	r3,r3,1
  46a52c:	10c00e15 	stw	r3,56(r2)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
  46a530:	d0a71017 	ldw	r2,-25536(gp)
  46a534:	10800044 	addi	r2,r2,1
  46a538:	d0a71015 	stw	r2,-25536(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
  46a53c:	04741840 	call	474184 <OSCtxSw>
  46a540:	e0bffc17 	ldw	r2,-16(fp)
  46a544:	e0bffe15 	stw	r2,-8(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46a548:	0005303a 	rdctl	r2,status
  46a54c:	e0bfff15 	stw	r2,-4(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46a550:	e0ffff17 	ldw	r3,-4(fp)
  46a554:	00bfff84 	movi	r2,-2
  46a558:	1884703a 	and	r2,r3,r2
  46a55c:	e0bfff15 	stw	r2,-4(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46a560:	e0bffe17 	ldw	r2,-8(fp)
  46a564:	1080004c 	andi	r2,r2,1
  46a568:	e0ffff17 	ldw	r3,-4(fp)
  46a56c:	1884b03a 	or	r2,r3,r2
  46a570:	e0bfff15 	stw	r2,-4(fp)
  
  NIOS2_WRITE_STATUS (status);
  46a574:	e0bfff17 	ldw	r2,-4(fp)
  46a578:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
  46a57c:	e037883a 	mov	sp,fp
  46a580:	dfc00117 	ldw	ra,4(sp)
  46a584:	df000017 	ldw	fp,0(sp)
  46a588:	dec00204 	addi	sp,sp,8
  46a58c:	f800283a 	ret

0046a590 <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
  46a590:	defffe04 	addi	sp,sp,-8
  46a594:	df000115 	stw	fp,4(sp)
  46a598:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
  46a59c:	d0a71703 	ldbu	r2,-25508(gp)
  46a5a0:	10803fcc 	andi	r2,r2,255
  46a5a4:	00c011f4 	movhi	r3,71
  46a5a8:	18d80e04 	addi	r3,r3,24632
  46a5ac:	1885883a 	add	r2,r3,r2
  46a5b0:	10800003 	ldbu	r2,0(r2)
  46a5b4:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
  46a5b8:	e0bfff03 	ldbu	r2,-4(fp)
  46a5bc:	100490fa 	slli	r2,r2,3
  46a5c0:	1007883a 	mov	r3,r2
  46a5c4:	e13fff03 	ldbu	r4,-4(fp)
  46a5c8:	d0a71744 	addi	r2,gp,-25507
  46a5cc:	2085883a 	add	r2,r4,r2
  46a5d0:	10800003 	ldbu	r2,0(r2)
  46a5d4:	10803fcc 	andi	r2,r2,255
  46a5d8:	010011f4 	movhi	r4,71
  46a5dc:	21180e04 	addi	r4,r4,24632
  46a5e0:	2085883a 	add	r2,r4,r2
  46a5e4:	10800003 	ldbu	r2,0(r2)
  46a5e8:	1885883a 	add	r2,r3,r2
  46a5ec:	d0a70d05 	stb	r2,-25548(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
  46a5f0:	e037883a 	mov	sp,fp
  46a5f4:	df000017 	ldw	fp,0(sp)
  46a5f8:	dec00104 	addi	sp,sp,4
  46a5fc:	f800283a 	ret

0046a600 <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
  46a600:	defffc04 	addi	sp,sp,-16
  46a604:	df000315 	stw	fp,12(sp)
  46a608:	df000304 	addi	fp,sp,12
  46a60c:	e13ffe15 	stw	r4,-8(fp)
  46a610:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
  46a614:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
  46a618:	00000d06 	br	46a650 <OS_StrCopy+0x50>
        *pdest++ = *psrc++;
  46a61c:	e0bfff17 	ldw	r2,-4(fp)
  46a620:	10c00003 	ldbu	r3,0(r2)
  46a624:	e0bffe17 	ldw	r2,-8(fp)
  46a628:	10c00005 	stb	r3,0(r2)
  46a62c:	e0bffe17 	ldw	r2,-8(fp)
  46a630:	10800044 	addi	r2,r2,1
  46a634:	e0bffe15 	stw	r2,-8(fp)
  46a638:	e0bfff17 	ldw	r2,-4(fp)
  46a63c:	10800044 	addi	r2,r2,1
  46a640:	e0bfff15 	stw	r2,-4(fp)
        len++;
  46a644:	e0bffd03 	ldbu	r2,-12(fp)
  46a648:	10800044 	addi	r2,r2,1
  46a64c:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
  46a650:	e0bfff17 	ldw	r2,-4(fp)
  46a654:	10800003 	ldbu	r2,0(r2)
  46a658:	10803fcc 	andi	r2,r2,255
  46a65c:	103fef1e 	bne	r2,zero,46a61c <OS_StrCopy+0x1c>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
  46a660:	e0bffe17 	ldw	r2,-8(fp)
  46a664:	10000005 	stb	zero,0(r2)
    return (len);
  46a668:	e0bffd03 	ldbu	r2,-12(fp)
}
  46a66c:	e037883a 	mov	sp,fp
  46a670:	df000017 	ldw	fp,0(sp)
  46a674:	dec00104 	addi	sp,sp,4
  46a678:	f800283a 	ret

0046a67c <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
  46a67c:	defffd04 	addi	sp,sp,-12
  46a680:	df000215 	stw	fp,8(sp)
  46a684:	df000204 	addi	fp,sp,8
  46a688:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
  46a68c:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
  46a690:	00000606 	br	46a6ac <OS_StrLen+0x30>
        psrc++;
  46a694:	e0bfff17 	ldw	r2,-4(fp)
  46a698:	10800044 	addi	r2,r2,1
  46a69c:	e0bfff15 	stw	r2,-4(fp)
        len++;
  46a6a0:	e0bffe03 	ldbu	r2,-8(fp)
  46a6a4:	10800044 	addi	r2,r2,1
  46a6a8:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
  46a6ac:	e0bfff17 	ldw	r2,-4(fp)
  46a6b0:	10800003 	ldbu	r2,0(r2)
  46a6b4:	10803fcc 	andi	r2,r2,255
  46a6b8:	103ff61e 	bne	r2,zero,46a694 <OS_StrLen+0x18>
        psrc++;
        len++;
    }
    return (len);
  46a6bc:	e0bffe03 	ldbu	r2,-8(fp)
}
  46a6c0:	e037883a 	mov	sp,fp
  46a6c4:	df000017 	ldw	fp,0(sp)
  46a6c8:	dec00104 	addi	sp,sp,4
  46a6cc:	f800283a 	ret

0046a6d0 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
  46a6d0:	defff904 	addi	sp,sp,-28
  46a6d4:	dfc00615 	stw	ra,24(sp)
  46a6d8:	df000515 	stw	fp,20(sp)
  46a6dc:	df000504 	addi	fp,sp,20
  46a6e0:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
  46a6e4:	e03ffb15 	stw	zero,-20(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46a6e8:	0005303a 	rdctl	r2,status
  46a6ec:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46a6f0:	e0fffc17 	ldw	r3,-16(fp)
  46a6f4:	00bfff84 	movi	r2,-2
  46a6f8:	1884703a 	and	r2,r3,r2
  46a6fc:	1001703a 	wrctl	status,r2
  
  return context;
  46a700:	e0bffc17 	ldw	r2,-16(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
  46a704:	e0bffb15 	stw	r2,-20(fp)
        OSIdleCtr++;
  46a708:	d0a70c17 	ldw	r2,-25552(gp)
  46a70c:	10800044 	addi	r2,r2,1
  46a710:	d0a70c15 	stw	r2,-25552(gp)
  46a714:	e0bffb17 	ldw	r2,-20(fp)
  46a718:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46a71c:	0005303a 	rdctl	r2,status
  46a720:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46a724:	e0fffe17 	ldw	r3,-8(fp)
  46a728:	00bfff84 	movi	r2,-2
  46a72c:	1884703a 	and	r2,r3,r2
  46a730:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46a734:	e0bffd17 	ldw	r2,-12(fp)
  46a738:	1080004c 	andi	r2,r2,1
  46a73c:	e0fffe17 	ldw	r3,-8(fp)
  46a740:	1884b03a 	or	r2,r3,r2
  46a744:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
  46a748:	e0bffe17 	ldw	r2,-8(fp)
  46a74c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
  46a750:	04746140 	call	474614 <OSTaskIdleHook>
    }
  46a754:	003fe406 	br	46a6e8 <OS_TaskIdle+0x18>

0046a758 <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
  46a758:	defff904 	addi	sp,sp,-28
  46a75c:	dfc00615 	stw	ra,24(sp)
  46a760:	df000515 	stw	fp,20(sp)
  46a764:	df000504 	addi	fp,sp,20
  46a768:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
  46a76c:	e03ffb15 	stw	zero,-20(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
  46a770:	00000206 	br	46a77c <OS_TaskStat+0x24>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
  46a774:	01000504 	movi	r4,20
  46a778:	04719a00 	call	4719a0 <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
  46a77c:	d0a71d03 	ldbu	r2,-25484(gp)
  46a780:	10803fcc 	andi	r2,r2,255
  46a784:	103ffb26 	beq	r2,zero,46a774 <OS_TaskStat+0x1c>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
  46a788:	d0a71117 	ldw	r2,-25532(gp)
  46a78c:	1009883a 	mov	r4,r2
  46a790:	01401904 	movi	r5,100
  46a794:	04759340 	call	475934 <__udivsi3>
  46a798:	d0a71115 	stw	r2,-25532(gp)
    if (OSIdleCtrMax == 0L) {
  46a79c:	d0a71117 	ldw	r2,-25532(gp)
  46a7a0:	1000031e 	bne	r2,zero,46a7b0 <OS_TaskStat+0x58>
        OSCPUUsage = 0;
  46a7a4:	d0271305 	stb	zero,-25524(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
  46a7a8:	01003fc4 	movi	r4,255
  46a7ac:	04714ec0 	call	4714ec <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46a7b0:	0005303a 	rdctl	r2,status
  46a7b4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46a7b8:	e0fffc17 	ldw	r3,-16(fp)
  46a7bc:	00bfff84 	movi	r2,-2
  46a7c0:	1884703a 	and	r2,r3,r2
  46a7c4:	1001703a 	wrctl	status,r2
  
  return context;
  46a7c8:	e0bffc17 	ldw	r2,-16(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
  46a7cc:	e0bffb15 	stw	r2,-20(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
  46a7d0:	d0a70c17 	ldw	r2,-25552(gp)
  46a7d4:	d0a71e15 	stw	r2,-25480(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
  46a7d8:	d0270c15 	stw	zero,-25552(gp)
  46a7dc:	e0bffb17 	ldw	r2,-20(fp)
  46a7e0:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46a7e4:	0005303a 	rdctl	r2,status
  46a7e8:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46a7ec:	e0fffe17 	ldw	r3,-8(fp)
  46a7f0:	00bfff84 	movi	r2,-2
  46a7f4:	1884703a 	and	r2,r3,r2
  46a7f8:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46a7fc:	e0bffd17 	ldw	r2,-12(fp)
  46a800:	1080004c 	andi	r2,r2,1
  46a804:	e0fffe17 	ldw	r3,-8(fp)
  46a808:	1884b03a 	or	r2,r3,r2
  46a80c:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
  46a810:	e0bffe17 	ldw	r2,-8(fp)
  46a814:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
  46a818:	d0e71e17 	ldw	r3,-25480(gp)
  46a81c:	d0a71117 	ldw	r2,-25532(gp)
  46a820:	1809883a 	mov	r4,r3
  46a824:	100b883a 	mov	r5,r2
  46a828:	04759340 	call	475934 <__udivsi3>
  46a82c:	00c01904 	movi	r3,100
  46a830:	1885c83a 	sub	r2,r3,r2
  46a834:	d0a71305 	stb	r2,-25524(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
  46a838:	04745a40 	call	4745a4 <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
  46a83c:	046a84c0 	call	46a84c <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
  46a840:	01000284 	movi	r4,10
  46a844:	04719a00 	call	4719a0 <OSTimeDly>
    }
  46a848:	003fd906 	br	46a7b0 <OS_TaskStat+0x58>

0046a84c <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
  46a84c:	defffa04 	addi	sp,sp,-24
  46a850:	dfc00515 	stw	ra,20(sp)
  46a854:	df000415 	stw	fp,16(sp)
  46a858:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
  46a85c:	e03ffc05 	stb	zero,-16(fp)
  46a860:	00002406 	br	46a8f4 <OS_TaskStatStkChk+0xa8>
        err = OSTaskStkChk(prio, &stk_data);
  46a864:	e0fffc03 	ldbu	r3,-16(fp)
  46a868:	e0bffe04 	addi	r2,fp,-8
  46a86c:	1809883a 	mov	r4,r3
  46a870:	100b883a 	mov	r5,r2
  46a874:	04712680 	call	471268 <OSTaskStkChk>
  46a878:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
  46a87c:	e0bffc43 	ldbu	r2,-15(fp)
  46a880:	1000191e 	bne	r2,zero,46a8e8 <OS_TaskStatStkChk+0x9c>
            ptcb = OSTCBPrioTbl[prio];
  46a884:	e0bffc03 	ldbu	r2,-16(fp)
  46a888:	00c01234 	movhi	r3,72
  46a88c:	18f31404 	addi	r3,r3,-13232
  46a890:	1085883a 	add	r2,r2,r2
  46a894:	1085883a 	add	r2,r2,r2
  46a898:	1885883a 	add	r2,r3,r2
  46a89c:	10800017 	ldw	r2,0(r2)
  46a8a0:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
  46a8a4:	e0bffd17 	ldw	r2,-12(fp)
  46a8a8:	10000f26 	beq	r2,zero,46a8e8 <OS_TaskStatStkChk+0x9c>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
  46a8ac:	e0bffd17 	ldw	r2,-12(fp)
  46a8b0:	10800060 	cmpeqi	r2,r2,1
  46a8b4:	10000c1e 	bne	r2,zero,46a8e8 <OS_TaskStatStkChk+0x9c>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
  46a8b8:	e0bffd17 	ldw	r2,-12(fp)
  46a8bc:	10c00217 	ldw	r3,8(r2)
  46a8c0:	e0bffd17 	ldw	r2,-12(fp)
  46a8c4:	10800317 	ldw	r2,12(r2)
  46a8c8:	1085883a 	add	r2,r2,r2
  46a8cc:	1085883a 	add	r2,r2,r2
  46a8d0:	1887883a 	add	r3,r3,r2
  46a8d4:	e0bffd17 	ldw	r2,-12(fp)
  46a8d8:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
  46a8dc:	e0ffff17 	ldw	r3,-4(fp)
  46a8e0:	e0bffd17 	ldw	r2,-12(fp)
  46a8e4:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
  46a8e8:	e0bffc03 	ldbu	r2,-16(fp)
  46a8ec:	10800044 	addi	r2,r2,1
  46a8f0:	e0bffc05 	stb	r2,-16(fp)
  46a8f4:	e0bffc03 	ldbu	r2,-16(fp)
  46a8f8:	10800570 	cmpltui	r2,r2,21
  46a8fc:	103fd91e 	bne	r2,zero,46a864 <OS_TaskStatStkChk+0x18>
#endif
                }
            }
        }
    }
}
  46a900:	e037883a 	mov	sp,fp
  46a904:	dfc00117 	ldw	ra,4(sp)
  46a908:	df000017 	ldw	fp,0(sp)
  46a90c:	dec00204 	addi	sp,sp,8
  46a910:	f800283a 	ret

0046a914 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
  46a914:	deffef04 	addi	sp,sp,-68
  46a918:	dfc01015 	stw	ra,64(sp)
  46a91c:	df000f15 	stw	fp,60(sp)
  46a920:	df000f04 	addi	fp,sp,60
  46a924:	2007883a 	mov	r3,r4
  46a928:	e17ffc15 	stw	r5,-16(fp)
  46a92c:	e1bffd15 	stw	r6,-12(fp)
  46a930:	3805883a 	mov	r2,r7
  46a934:	e1000417 	ldw	r4,16(fp)
  46a938:	e0fffb05 	stb	r3,-20(fp)
  46a93c:	e0bffe0d 	sth	r2,-8(fp)
  46a940:	e13fff0d 	sth	r4,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
  46a944:	e03ff115 	stw	zero,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46a948:	0005303a 	rdctl	r2,status
  46a94c:	e0bff315 	stw	r2,-52(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46a950:	e0fff317 	ldw	r3,-52(fp)
  46a954:	00bfff84 	movi	r2,-2
  46a958:	1884703a 	and	r2,r3,r2
  46a95c:	1001703a 	wrctl	status,r2
  
  return context;
  46a960:	e0bff317 	ldw	r2,-52(fp)
#endif



    OS_ENTER_CRITICAL();
  46a964:	e0bff115 	stw	r2,-60(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
  46a968:	d0a71217 	ldw	r2,-25528(gp)
  46a96c:	e0bff215 	stw	r2,-56(fp)
    if (ptcb != (OS_TCB *)0) {
  46a970:	e0bff217 	ldw	r2,-56(fp)
  46a974:	1000a926 	beq	r2,zero,46ac1c <OS_TCBInit+0x308>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
  46a978:	e0bff217 	ldw	r2,-56(fp)
  46a97c:	10800517 	ldw	r2,20(r2)
  46a980:	d0a71215 	stw	r2,-25528(gp)
  46a984:	e0bff117 	ldw	r2,-60(fp)
  46a988:	e0bff415 	stw	r2,-48(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46a98c:	0005303a 	rdctl	r2,status
  46a990:	e0bff515 	stw	r2,-44(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46a994:	e0fff517 	ldw	r3,-44(fp)
  46a998:	00bfff84 	movi	r2,-2
  46a99c:	1884703a 	and	r2,r3,r2
  46a9a0:	e0bff515 	stw	r2,-44(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46a9a4:	e0bff417 	ldw	r2,-48(fp)
  46a9a8:	1080004c 	andi	r2,r2,1
  46a9ac:	e0fff517 	ldw	r3,-44(fp)
  46a9b0:	1884b03a 	or	r2,r3,r2
  46a9b4:	e0bff515 	stw	r2,-44(fp)
  
  NIOS2_WRITE_STATUS (status);
  46a9b8:	e0bff517 	ldw	r2,-44(fp)
  46a9bc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
  46a9c0:	e0bff217 	ldw	r2,-56(fp)
  46a9c4:	e0fffc17 	ldw	r3,-16(fp)
  46a9c8:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
  46a9cc:	e0bff217 	ldw	r2,-56(fp)
  46a9d0:	e0fffb03 	ldbu	r3,-20(fp)
  46a9d4:	10c00c85 	stb	r3,50(r2)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
  46a9d8:	e0bff217 	ldw	r2,-56(fp)
  46a9dc:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
  46a9e0:	e0bff217 	ldw	r2,-56(fp)
  46a9e4:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
  46a9e8:	e0bff217 	ldw	r2,-56(fp)
  46a9ec:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
  46a9f0:	e0bff217 	ldw	r2,-56(fp)
  46a9f4:	e0c00317 	ldw	r3,12(fp)
  46a9f8:	10c00115 	stw	r3,4(r2)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
  46a9fc:	e0bff217 	ldw	r2,-56(fp)
  46aa00:	e0c00217 	ldw	r3,8(fp)
  46aa04:	10c00315 	stw	r3,12(r2)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
  46aa08:	e0bff217 	ldw	r2,-56(fp)
  46aa0c:	e0fffd17 	ldw	r3,-12(fp)
  46aa10:	10c00215 	stw	r3,8(r2)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
  46aa14:	e0bff217 	ldw	r2,-56(fp)
  46aa18:	e0ffff0b 	ldhu	r3,-4(fp)
  46aa1c:	10c0040d 	sth	r3,16(r2)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
  46aa20:	e0bff217 	ldw	r2,-56(fp)
  46aa24:	e0fffe0b 	ldhu	r3,-8(fp)
  46aa28:	10c0048d 	sth	r3,18(r2)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
  46aa2c:	e0bff217 	ldw	r2,-56(fp)
  46aa30:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
  46aa34:	e0bffb03 	ldbu	r2,-20(fp)
  46aa38:	1004d0fa 	srli	r2,r2,3
  46aa3c:	1007883a 	mov	r3,r2
  46aa40:	e0bff217 	ldw	r2,-56(fp)
  46aa44:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
  46aa48:	e0bffb03 	ldbu	r2,-20(fp)
  46aa4c:	108001cc 	andi	r2,r2,7
  46aa50:	1007883a 	mov	r3,r2
  46aa54:	e0bff217 	ldw	r2,-56(fp)
  46aa58:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
  46aa5c:	e0bff217 	ldw	r2,-56(fp)
  46aa60:	10800d03 	ldbu	r2,52(r2)
  46aa64:	10803fcc 	andi	r2,r2,255
  46aa68:	00c00044 	movi	r3,1
  46aa6c:	1884983a 	sll	r2,r3,r2
  46aa70:	1007883a 	mov	r3,r2
  46aa74:	e0bff217 	ldw	r2,-56(fp)
  46aa78:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
  46aa7c:	e0bff217 	ldw	r2,-56(fp)
  46aa80:	10800cc3 	ldbu	r2,51(r2)
  46aa84:	10803fcc 	andi	r2,r2,255
  46aa88:	00c00044 	movi	r3,1
  46aa8c:	1884983a 	sll	r2,r3,r2
  46aa90:	1007883a 	mov	r3,r2
  46aa94:	e0bff217 	ldw	r2,-56(fp)
  46aa98:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
  46aa9c:	e0bff217 	ldw	r2,-56(fp)
  46aaa0:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
  46aaa4:	e0bff217 	ldw	r2,-56(fp)
  46aaa8:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
  46aaac:	e0bff217 	ldw	r2,-56(fp)
  46aab0:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
  46aab4:	e0bff217 	ldw	r2,-56(fp)
  46aab8:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
  46aabc:	e0bff217 	ldw	r2,-56(fp)
  46aac0:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
  46aac4:	e0bff217 	ldw	r2,-56(fp)
  46aac8:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
  46aacc:	e0bff217 	ldw	r2,-56(fp)
  46aad0:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
  46aad4:	e0bff217 	ldw	r2,-56(fp)
  46aad8:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
  46aadc:	e0bff217 	ldw	r2,-56(fp)
  46aae0:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
  46aae4:	e0bff217 	ldw	r2,-56(fp)
  46aae8:	00c00fc4 	movi	r3,63
  46aaec:	10c01305 	stb	r3,76(r2)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
  46aaf0:	e0bff217 	ldw	r2,-56(fp)
  46aaf4:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
  46aaf8:	e13ff217 	ldw	r4,-56(fp)
  46aafc:	04746300 	call	474630 <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
  46ab00:	e13ff217 	ldw	r4,-56(fp)
  46ab04:	04745480 	call	474548 <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46ab08:	0005303a 	rdctl	r2,status
  46ab0c:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46ab10:	e0fff617 	ldw	r3,-40(fp)
  46ab14:	00bfff84 	movi	r2,-2
  46ab18:	1884703a 	and	r2,r3,r2
  46ab1c:	1001703a 	wrctl	status,r2
  
  return context;
  46ab20:	e0bff617 	ldw	r2,-40(fp)

        OS_ENTER_CRITICAL();
  46ab24:	e0bff115 	stw	r2,-60(fp)
        OSTCBPrioTbl[prio] = ptcb;
  46ab28:	e0bffb03 	ldbu	r2,-20(fp)
  46ab2c:	00c01234 	movhi	r3,72
  46ab30:	18f31404 	addi	r3,r3,-13232
  46ab34:	1085883a 	add	r2,r2,r2
  46ab38:	1085883a 	add	r2,r2,r2
  46ab3c:	1885883a 	add	r2,r3,r2
  46ab40:	e0fff217 	ldw	r3,-56(fp)
  46ab44:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
  46ab48:	d0e70e17 	ldw	r3,-25544(gp)
  46ab4c:	e0bff217 	ldw	r2,-56(fp)
  46ab50:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
  46ab54:	e0bff217 	ldw	r2,-56(fp)
  46ab58:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
  46ab5c:	d0a70e17 	ldw	r2,-25544(gp)
  46ab60:	10000326 	beq	r2,zero,46ab70 <OS_TCBInit+0x25c>
            OSTCBList->OSTCBPrev = ptcb;
  46ab64:	d0a70e17 	ldw	r2,-25544(gp)
  46ab68:	e0fff217 	ldw	r3,-56(fp)
  46ab6c:	10c00615 	stw	r3,24(r2)
        }
        OSTCBList               = ptcb;
  46ab70:	e0bff217 	ldw	r2,-56(fp)
  46ab74:	d0a70e15 	stw	r2,-25544(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
  46ab78:	e0bff217 	ldw	r2,-56(fp)
  46ab7c:	10c00d83 	ldbu	r3,54(r2)
  46ab80:	d0a71703 	ldbu	r2,-25508(gp)
  46ab84:	1884b03a 	or	r2,r3,r2
  46ab88:	d0a71705 	stb	r2,-25508(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
  46ab8c:	e0bff217 	ldw	r2,-56(fp)
  46ab90:	10800d03 	ldbu	r2,52(r2)
  46ab94:	11003fcc 	andi	r4,r2,255
  46ab98:	e0bff217 	ldw	r2,-56(fp)
  46ab9c:	10800d03 	ldbu	r2,52(r2)
  46aba0:	10c03fcc 	andi	r3,r2,255
  46aba4:	d0a71744 	addi	r2,gp,-25507
  46aba8:	1885883a 	add	r2,r3,r2
  46abac:	10c00003 	ldbu	r3,0(r2)
  46abb0:	e0bff217 	ldw	r2,-56(fp)
  46abb4:	10800d43 	ldbu	r2,53(r2)
  46abb8:	1884b03a 	or	r2,r3,r2
  46abbc:	1007883a 	mov	r3,r2
  46abc0:	d0a71744 	addi	r2,gp,-25507
  46abc4:	2085883a 	add	r2,r4,r2
  46abc8:	10c00005 	stb	r3,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
  46abcc:	d0a71343 	ldbu	r2,-25523(gp)
  46abd0:	10800044 	addi	r2,r2,1
  46abd4:	d0a71345 	stb	r2,-25523(gp)
  46abd8:	e0bff117 	ldw	r2,-60(fp)
  46abdc:	e0bff715 	stw	r2,-36(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46abe0:	0005303a 	rdctl	r2,status
  46abe4:	e0bff815 	stw	r2,-32(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46abe8:	e0fff817 	ldw	r3,-32(fp)
  46abec:	00bfff84 	movi	r2,-2
  46abf0:	1884703a 	and	r2,r3,r2
  46abf4:	e0bff815 	stw	r2,-32(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46abf8:	e0bff717 	ldw	r2,-36(fp)
  46abfc:	1080004c 	andi	r2,r2,1
  46ac00:	e0fff817 	ldw	r3,-32(fp)
  46ac04:	1884b03a 	or	r2,r3,r2
  46ac08:	e0bff815 	stw	r2,-32(fp)
  
  NIOS2_WRITE_STATUS (status);
  46ac0c:	e0bff817 	ldw	r2,-32(fp)
  46ac10:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
  46ac14:	0005883a 	mov	r2,zero
  46ac18:	00001006 	br	46ac5c <OS_TCBInit+0x348>
  46ac1c:	e0bff117 	ldw	r2,-60(fp)
  46ac20:	e0bff915 	stw	r2,-28(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46ac24:	0005303a 	rdctl	r2,status
  46ac28:	e0bffa15 	stw	r2,-24(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46ac2c:	e0fffa17 	ldw	r3,-24(fp)
  46ac30:	00bfff84 	movi	r2,-2
  46ac34:	1884703a 	and	r2,r3,r2
  46ac38:	e0bffa15 	stw	r2,-24(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46ac3c:	e0bff917 	ldw	r2,-28(fp)
  46ac40:	1080004c 	andi	r2,r2,1
  46ac44:	e0fffa17 	ldw	r3,-24(fp)
  46ac48:	1884b03a 	or	r2,r3,r2
  46ac4c:	e0bffa15 	stw	r2,-24(fp)
  
  NIOS2_WRITE_STATUS (status);
  46ac50:	e0bffa17 	ldw	r2,-24(fp)
  46ac54:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
  46ac58:	00801084 	movi	r2,66
}
  46ac5c:	e037883a 	mov	sp,fp
  46ac60:	dfc00117 	ldw	ra,4(sp)
  46ac64:	df000017 	ldw	fp,0(sp)
  46ac68:	dec00204 	addi	sp,sp,8
  46ac6c:	f800283a 	ret

0046ac70 <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
  46ac70:	defffe04 	addi	sp,sp,-8
  46ac74:	df000115 	stw	fp,4(sp)
  46ac78:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
  46ac7c:	d0a01404 	addi	r2,gp,-32688
  46ac80:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
  46ac84:	d0a01504 	addi	r2,gp,-32684
  46ac88:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
  46ac8c:	d0a01684 	addi	r2,gp,-32678
  46ac90:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
  46ac94:	d0a01704 	addi	r2,gp,-32676
  46ac98:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
  46ac9c:	d0a01604 	addi	r2,gp,-32680
  46aca0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
  46aca4:	d0a01784 	addi	r2,gp,-32674
  46aca8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
  46acac:	d0a01804 	addi	r2,gp,-32672
  46acb0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
  46acb4:	d0a01884 	addi	r2,gp,-32670
  46acb8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
  46acbc:	d0a01904 	addi	r2,gp,-32668
  46acc0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
  46acc4:	d0a01984 	addi	r2,gp,-32666
  46acc8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
  46accc:	d0a01a04 	addi	r2,gp,-32664
  46acd0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
  46acd4:	d0a01a84 	addi	r2,gp,-32662
  46acd8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
  46acdc:	d0a01b04 	addi	r2,gp,-32660
  46ace0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
  46ace4:	d0a01b84 	addi	r2,gp,-32658
  46ace8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
  46acec:	d0a01c04 	addi	r2,gp,-32656
  46acf0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
  46acf4:	d0a01c84 	addi	r2,gp,-32654
  46acf8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
  46acfc:	d0a01d04 	addi	r2,gp,-32652
  46ad00:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
  46ad04:	d0a01d84 	addi	r2,gp,-32650
  46ad08:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
  46ad0c:	d0a01e04 	addi	r2,gp,-32648
  46ad10:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
  46ad14:	d0a01e84 	addi	r2,gp,-32646
  46ad18:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
  46ad1c:	d0a01f04 	addi	r2,gp,-32644
  46ad20:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
  46ad24:	d0a01f84 	addi	r2,gp,-32642
  46ad28:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
  46ad2c:	d0a02004 	addi	r2,gp,-32640
  46ad30:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
  46ad34:	d0a02084 	addi	r2,gp,-32638
  46ad38:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
  46ad3c:	d0a02104 	addi	r2,gp,-32636
  46ad40:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
  46ad44:	d0a02184 	addi	r2,gp,-32634
  46ad48:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
  46ad4c:	d0a02204 	addi	r2,gp,-32632
  46ad50:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
  46ad54:	d0a02284 	addi	r2,gp,-32630
  46ad58:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
  46ad5c:	d0a02304 	addi	r2,gp,-32628
  46ad60:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
  46ad64:	d0a02384 	addi	r2,gp,-32626
  46ad68:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
  46ad6c:	d0a02404 	addi	r2,gp,-32624
  46ad70:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
  46ad74:	d0a02484 	addi	r2,gp,-32622
  46ad78:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
  46ad7c:	d0a02504 	addi	r2,gp,-32620
  46ad80:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
  46ad84:	d0a02584 	addi	r2,gp,-32618
  46ad88:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
  46ad8c:	d0a02604 	addi	r2,gp,-32616
  46ad90:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
  46ad94:	d0a02684 	addi	r2,gp,-32614
  46ad98:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
  46ad9c:	d0a02704 	addi	r2,gp,-32612
  46ada0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
  46ada4:	d0a02784 	addi	r2,gp,-32610
  46ada8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
  46adac:	d0a02804 	addi	r2,gp,-32608
  46adb0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
  46adb4:	d0a02884 	addi	r2,gp,-32606
  46adb8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
  46adbc:	d0a02904 	addi	r2,gp,-32604
  46adc0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
  46adc4:	d0a02984 	addi	r2,gp,-32602
  46adc8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
  46adcc:	d0a02a04 	addi	r2,gp,-32600
  46add0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
  46add4:	d0a02a84 	addi	r2,gp,-32598
  46add8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
    ptemp = (void *)&OSTmrWheelTblSize;
#endif

    ptemp = (void *)&OSVersionNbr;
  46addc:	d0a02b04 	addi	r2,gp,-32596
  46ade0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
  46ade4:	d0a03004 	addi	r2,gp,-32576
  46ade8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
  46adec:	e037883a 	mov	sp,fp
  46adf0:	df000017 	ldw	fp,0(sp)
  46adf4:	dec00104 	addi	sp,sp,4
  46adf8:	f800283a 	ret

0046adfc <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
  46adfc:	deffed04 	addi	sp,sp,-76
  46ae00:	df001215 	stw	fp,72(sp)
  46ae04:	df001204 	addi	fp,sp,72
  46ae08:	e13ffc15 	stw	r4,-16(fp)
  46ae0c:	2807883a 	mov	r3,r5
  46ae10:	3005883a 	mov	r2,r6
  46ae14:	e1ffff15 	stw	r7,-4(fp)
  46ae18:	e0fffd0d 	sth	r3,-12(fp)
  46ae1c:	e0bffe05 	stb	r2,-8(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
  46ae20:	e03fef15 	stw	zero,-68(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
  46ae24:	e0bfff17 	ldw	r2,-4(fp)
  46ae28:	1000021e 	bne	r2,zero,46ae34 <OSFlagAccept+0x38>
        return ((OS_FLAGS)0);
  46ae2c:	0005883a 	mov	r2,zero
  46ae30:	0000e706 	br	46b1d0 <OSFlagAccept+0x3d4>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
  46ae34:	e0bffc17 	ldw	r2,-16(fp)
  46ae38:	1000051e 	bne	r2,zero,46ae50 <OSFlagAccept+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
  46ae3c:	e0bfff17 	ldw	r2,-4(fp)
  46ae40:	00c01b84 	movi	r3,110
  46ae44:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
  46ae48:	0005883a 	mov	r2,zero
  46ae4c:	0000e006 	br	46b1d0 <OSFlagAccept+0x3d4>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
  46ae50:	e0bffc17 	ldw	r2,-16(fp)
  46ae54:	10800003 	ldbu	r2,0(r2)
  46ae58:	10803fcc 	andi	r2,r2,255
  46ae5c:	10800160 	cmpeqi	r2,r2,5
  46ae60:	1000051e 	bne	r2,zero,46ae78 <OSFlagAccept+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
  46ae64:	e0bfff17 	ldw	r2,-4(fp)
  46ae68:	00c00044 	movi	r3,1
  46ae6c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
  46ae70:	0005883a 	mov	r2,zero
  46ae74:	0000d606 	br	46b1d0 <OSFlagAccept+0x3d4>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
  46ae78:	e0fffe03 	ldbu	r3,-8(fp)
  46ae7c:	00bfe004 	movi	r2,-128
  46ae80:	1884703a 	and	r2,r3,r2
  46ae84:	e0bff005 	stb	r2,-64(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
  46ae88:	e0bff003 	ldbu	r2,-64(fp)
  46ae8c:	10000626 	beq	r2,zero,46aea8 <OSFlagAccept+0xac>
        wait_type &= ~OS_FLAG_CONSUME;
  46ae90:	e0bffe03 	ldbu	r2,-8(fp)
  46ae94:	10801fcc 	andi	r2,r2,127
  46ae98:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
  46ae9c:	00800044 	movi	r2,1
  46aea0:	e0bfee85 	stb	r2,-70(fp)
  46aea4:	00000106 	br	46aeac <OSFlagAccept+0xb0>
    } else {
        consume    = OS_FALSE;
  46aea8:	e03fee85 	stb	zero,-70(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
  46aeac:	e0bfff17 	ldw	r2,-4(fp)
  46aeb0:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46aeb4:	0005303a 	rdctl	r2,status
  46aeb8:	e0bff115 	stw	r2,-60(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46aebc:	e0fff117 	ldw	r3,-60(fp)
  46aec0:	00bfff84 	movi	r2,-2
  46aec4:	1884703a 	and	r2,r3,r2
  46aec8:	1001703a 	wrctl	status,r2
  
  return context;
  46aecc:	e0bff117 	ldw	r2,-60(fp)
    OS_ENTER_CRITICAL();
  46aed0:	e0bfef15 	stw	r2,-68(fp)
    switch (wait_type) {
  46aed4:	e0bffe03 	ldbu	r2,-8(fp)
  46aed8:	10c00060 	cmpeqi	r3,r2,1
  46aedc:	1800801e 	bne	r3,zero,46b0e0 <OSFlagAccept+0x2e4>
  46aee0:	10c00088 	cmpgei	r3,r2,2
  46aee4:	1800021e 	bne	r3,zero,46aef0 <OSFlagAccept+0xf4>
  46aee8:	10005526 	beq	r2,zero,46b040 <OSFlagAccept+0x244>
  46aeec:	0000a306 	br	46b17c <OSFlagAccept+0x380>
  46aef0:	10c000a0 	cmpeqi	r3,r2,2
  46aef4:	1800031e 	bne	r3,zero,46af04 <OSFlagAccept+0x108>
  46aef8:	108000e0 	cmpeqi	r2,r2,3
  46aefc:	1000291e 	bne	r2,zero,46afa4 <OSFlagAccept+0x1a8>
  46af00:	00009e06 	br	46b17c <OSFlagAccept+0x380>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
  46af04:	e0bffc17 	ldw	r2,-16(fp)
  46af08:	10c0020b 	ldhu	r3,8(r2)
  46af0c:	e0bffd0b 	ldhu	r2,-12(fp)
  46af10:	1884703a 	and	r2,r3,r2
  46af14:	e0bfee0d 	sth	r2,-72(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
  46af18:	e0ffee0b 	ldhu	r3,-72(fp)
  46af1c:	e0bffd0b 	ldhu	r2,-12(fp)
  46af20:	18800d1e 	bne	r3,r2,46af58 <OSFlagAccept+0x15c>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
  46af24:	e0bfee83 	ldbu	r2,-70(fp)
  46af28:	10800058 	cmpnei	r2,r2,1
  46af2c:	10000d1e 	bne	r2,zero,46af64 <OSFlagAccept+0x168>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
  46af30:	e0bffc17 	ldw	r2,-16(fp)
  46af34:	1080020b 	ldhu	r2,8(r2)
  46af38:	1007883a 	mov	r3,r2
  46af3c:	e0bfee0b 	ldhu	r2,-72(fp)
  46af40:	0084303a 	nor	r2,zero,r2
  46af44:	1884703a 	and	r2,r3,r2
  46af48:	1007883a 	mov	r3,r2
  46af4c:	e0bffc17 	ldw	r2,-16(fp)
  46af50:	10c0020d 	sth	r3,8(r2)
  46af54:	00000306 	br	46af64 <OSFlagAccept+0x168>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
  46af58:	e0bfff17 	ldw	r2,-4(fp)
  46af5c:	00c01c04 	movi	r3,112
  46af60:	10c00005 	stb	r3,0(r2)
  46af64:	e0bfef17 	ldw	r2,-68(fp)
  46af68:	e0bff215 	stw	r2,-56(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46af6c:	0005303a 	rdctl	r2,status
  46af70:	e0bff315 	stw	r2,-52(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46af74:	e0fff317 	ldw	r3,-52(fp)
  46af78:	00bfff84 	movi	r2,-2
  46af7c:	1884703a 	and	r2,r3,r2
  46af80:	e0bff315 	stw	r2,-52(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46af84:	e0bff217 	ldw	r2,-56(fp)
  46af88:	1080004c 	andi	r2,r2,1
  46af8c:	e0fff317 	ldw	r3,-52(fp)
  46af90:	1884b03a 	or	r2,r3,r2
  46af94:	e0bff315 	stw	r2,-52(fp)
  
  NIOS2_WRITE_STATUS (status);
  46af98:	e0bff317 	ldw	r2,-52(fp)
  46af9c:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
  46afa0:	00008a06 	br	46b1cc <OSFlagAccept+0x3d0>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
  46afa4:	e0bffc17 	ldw	r2,-16(fp)
  46afa8:	10c0020b 	ldhu	r3,8(r2)
  46afac:	e0bffd0b 	ldhu	r2,-12(fp)
  46afb0:	1884703a 	and	r2,r3,r2
  46afb4:	e0bfee0d 	sth	r2,-72(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
  46afb8:	e0bfee0b 	ldhu	r2,-72(fp)
  46afbc:	10000d26 	beq	r2,zero,46aff4 <OSFlagAccept+0x1f8>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
  46afc0:	e0bfee83 	ldbu	r2,-70(fp)
  46afc4:	10800058 	cmpnei	r2,r2,1
  46afc8:	10000d1e 	bne	r2,zero,46b000 <OSFlagAccept+0x204>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
  46afcc:	e0bffc17 	ldw	r2,-16(fp)
  46afd0:	1080020b 	ldhu	r2,8(r2)
  46afd4:	1007883a 	mov	r3,r2
  46afd8:	e0bfee0b 	ldhu	r2,-72(fp)
  46afdc:	0084303a 	nor	r2,zero,r2
  46afe0:	1884703a 	and	r2,r3,r2
  46afe4:	1007883a 	mov	r3,r2
  46afe8:	e0bffc17 	ldw	r2,-16(fp)
  46afec:	10c0020d 	sth	r3,8(r2)
  46aff0:	00000306 	br	46b000 <OSFlagAccept+0x204>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
  46aff4:	e0bfff17 	ldw	r2,-4(fp)
  46aff8:	00c01c04 	movi	r3,112
  46affc:	10c00005 	stb	r3,0(r2)
  46b000:	e0bfef17 	ldw	r2,-68(fp)
  46b004:	e0bff415 	stw	r2,-48(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46b008:	0005303a 	rdctl	r2,status
  46b00c:	e0bff515 	stw	r2,-44(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46b010:	e0fff517 	ldw	r3,-44(fp)
  46b014:	00bfff84 	movi	r2,-2
  46b018:	1884703a 	and	r2,r3,r2
  46b01c:	e0bff515 	stw	r2,-44(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46b020:	e0bff417 	ldw	r2,-48(fp)
  46b024:	1080004c 	andi	r2,r2,1
  46b028:	e0fff517 	ldw	r3,-44(fp)
  46b02c:	1884b03a 	or	r2,r3,r2
  46b030:	e0bff515 	stw	r2,-44(fp)
  
  NIOS2_WRITE_STATUS (status);
  46b034:	e0bff517 	ldw	r2,-44(fp)
  46b038:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
  46b03c:	00006306 	br	46b1cc <OSFlagAccept+0x3d0>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
  46b040:	e0bffc17 	ldw	r2,-16(fp)
  46b044:	1080020b 	ldhu	r2,8(r2)
  46b048:	0084303a 	nor	r2,zero,r2
  46b04c:	1007883a 	mov	r3,r2
  46b050:	e0bffd0b 	ldhu	r2,-12(fp)
  46b054:	1884703a 	and	r2,r3,r2
  46b058:	e0bfee0d 	sth	r2,-72(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
  46b05c:	e0ffee0b 	ldhu	r3,-72(fp)
  46b060:	e0bffd0b 	ldhu	r2,-12(fp)
  46b064:	18800b1e 	bne	r3,r2,46b094 <OSFlagAccept+0x298>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
  46b068:	e0bfee83 	ldbu	r2,-70(fp)
  46b06c:	10800058 	cmpnei	r2,r2,1
  46b070:	10000b1e 	bne	r2,zero,46b0a0 <OSFlagAccept+0x2a4>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
  46b074:	e0bffc17 	ldw	r2,-16(fp)
  46b078:	10c0020b 	ldhu	r3,8(r2)
  46b07c:	e0bfee0b 	ldhu	r2,-72(fp)
  46b080:	1884b03a 	or	r2,r3,r2
  46b084:	1007883a 	mov	r3,r2
  46b088:	e0bffc17 	ldw	r2,-16(fp)
  46b08c:	10c0020d 	sth	r3,8(r2)
  46b090:	00000306 	br	46b0a0 <OSFlagAccept+0x2a4>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
  46b094:	e0bfff17 	ldw	r2,-4(fp)
  46b098:	00c01c04 	movi	r3,112
  46b09c:	10c00005 	stb	r3,0(r2)
  46b0a0:	e0bfef17 	ldw	r2,-68(fp)
  46b0a4:	e0bff615 	stw	r2,-40(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46b0a8:	0005303a 	rdctl	r2,status
  46b0ac:	e0bff715 	stw	r2,-36(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46b0b0:	e0fff717 	ldw	r3,-36(fp)
  46b0b4:	00bfff84 	movi	r2,-2
  46b0b8:	1884703a 	and	r2,r3,r2
  46b0bc:	e0bff715 	stw	r2,-36(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46b0c0:	e0bff617 	ldw	r2,-40(fp)
  46b0c4:	1080004c 	andi	r2,r2,1
  46b0c8:	e0fff717 	ldw	r3,-36(fp)
  46b0cc:	1884b03a 	or	r2,r3,r2
  46b0d0:	e0bff715 	stw	r2,-36(fp)
  
  NIOS2_WRITE_STATUS (status);
  46b0d4:	e0bff717 	ldw	r2,-36(fp)
  46b0d8:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
  46b0dc:	00003b06 	br	46b1cc <OSFlagAccept+0x3d0>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
  46b0e0:	e0bffc17 	ldw	r2,-16(fp)
  46b0e4:	1080020b 	ldhu	r2,8(r2)
  46b0e8:	0084303a 	nor	r2,zero,r2
  46b0ec:	1007883a 	mov	r3,r2
  46b0f0:	e0bffd0b 	ldhu	r2,-12(fp)
  46b0f4:	1884703a 	and	r2,r3,r2
  46b0f8:	e0bfee0d 	sth	r2,-72(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
  46b0fc:	e0bfee0b 	ldhu	r2,-72(fp)
  46b100:	10000b26 	beq	r2,zero,46b130 <OSFlagAccept+0x334>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
  46b104:	e0bfee83 	ldbu	r2,-70(fp)
  46b108:	10800058 	cmpnei	r2,r2,1
  46b10c:	10000b1e 	bne	r2,zero,46b13c <OSFlagAccept+0x340>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
  46b110:	e0bffc17 	ldw	r2,-16(fp)
  46b114:	10c0020b 	ldhu	r3,8(r2)
  46b118:	e0bfee0b 	ldhu	r2,-72(fp)
  46b11c:	1884b03a 	or	r2,r3,r2
  46b120:	1007883a 	mov	r3,r2
  46b124:	e0bffc17 	ldw	r2,-16(fp)
  46b128:	10c0020d 	sth	r3,8(r2)
  46b12c:	00000306 	br	46b13c <OSFlagAccept+0x340>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
  46b130:	e0bfff17 	ldw	r2,-4(fp)
  46b134:	00c01c04 	movi	r3,112
  46b138:	10c00005 	stb	r3,0(r2)
  46b13c:	e0bfef17 	ldw	r2,-68(fp)
  46b140:	e0bff815 	stw	r2,-32(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46b144:	0005303a 	rdctl	r2,status
  46b148:	e0bff915 	stw	r2,-28(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46b14c:	e0fff917 	ldw	r3,-28(fp)
  46b150:	00bfff84 	movi	r2,-2
  46b154:	1884703a 	and	r2,r3,r2
  46b158:	e0bff915 	stw	r2,-28(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46b15c:	e0bff817 	ldw	r2,-32(fp)
  46b160:	1080004c 	andi	r2,r2,1
  46b164:	e0fff917 	ldw	r3,-28(fp)
  46b168:	1884b03a 	or	r2,r3,r2
  46b16c:	e0bff915 	stw	r2,-28(fp)
  
  NIOS2_WRITE_STATUS (status);
  46b170:	e0bff917 	ldw	r2,-28(fp)
  46b174:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
  46b178:	00001406 	br	46b1cc <OSFlagAccept+0x3d0>
  46b17c:	e0bfef17 	ldw	r2,-68(fp)
  46b180:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46b184:	0005303a 	rdctl	r2,status
  46b188:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46b18c:	e0fffb17 	ldw	r3,-20(fp)
  46b190:	00bfff84 	movi	r2,-2
  46b194:	1884703a 	and	r2,r3,r2
  46b198:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46b19c:	e0bffa17 	ldw	r2,-24(fp)
  46b1a0:	1080004c 	andi	r2,r2,1
  46b1a4:	e0fffb17 	ldw	r3,-20(fp)
  46b1a8:	1884b03a 	or	r2,r3,r2
  46b1ac:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
  46b1b0:	e0bffb17 	ldw	r2,-20(fp)
  46b1b4:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
  46b1b8:	e03fee0d 	sth	zero,-72(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
  46b1bc:	e0bfff17 	ldw	r2,-4(fp)
  46b1c0:	00c01bc4 	movi	r3,111
  46b1c4:	10c00005 	stb	r3,0(r2)
             break;
  46b1c8:	0001883a 	nop
    }
    return (flags_rdy);
  46b1cc:	e0bfee0b 	ldhu	r2,-72(fp)
}
  46b1d0:	e037883a 	mov	sp,fp
  46b1d4:	df000017 	ldw	fp,0(sp)
  46b1d8:	dec00104 	addi	sp,sp,4
  46b1dc:	f800283a 	ret

0046b1e0 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
  46b1e0:	defff604 	addi	sp,sp,-40
  46b1e4:	df000915 	stw	fp,36(sp)
  46b1e8:	df000904 	addi	fp,sp,36
  46b1ec:	2005883a 	mov	r2,r4
  46b1f0:	e17fff15 	stw	r5,-4(fp)
  46b1f4:	e0bffe0d 	sth	r2,-8(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
  46b1f8:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
  46b1fc:	e0bfff17 	ldw	r2,-4(fp)
  46b200:	1000021e 	bne	r2,zero,46b20c <OSFlagCreate+0x2c>
        return ((OS_FLAG_GRP *)0);
  46b204:	0005883a 	mov	r2,zero
  46b208:	00005106 	br	46b350 <OSFlagCreate+0x170>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
  46b20c:	00801234 	movhi	r2,72
  46b210:	10a64c04 	addi	r2,r2,-26320
  46b214:	10800003 	ldbu	r2,0(r2)
  46b218:	10803fcc 	andi	r2,r2,255
  46b21c:	10000526 	beq	r2,zero,46b234 <OSFlagCreate+0x54>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
  46b220:	e0bfff17 	ldw	r2,-4(fp)
  46b224:	00c00404 	movi	r3,16
  46b228:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAG_GRP *)0);
  46b22c:	0005883a 	mov	r2,zero
  46b230:	00004706 	br	46b350 <OSFlagCreate+0x170>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46b234:	0005303a 	rdctl	r2,status
  46b238:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46b23c:	e0fff917 	ldw	r3,-28(fp)
  46b240:	00bfff84 	movi	r2,-2
  46b244:	1884703a 	and	r2,r3,r2
  46b248:	1001703a 	wrctl	status,r2
  
  return context;
  46b24c:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
  46b250:	e0bff715 	stw	r2,-36(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
  46b254:	00801234 	movhi	r2,72
  46b258:	10a64f04 	addi	r2,r2,-26308
  46b25c:	10800017 	ldw	r2,0(r2)
  46b260:	e0bff815 	stw	r2,-32(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
  46b264:	e0bff817 	ldw	r2,-32(fp)
  46b268:	10002626 	beq	r2,zero,46b304 <OSFlagCreate+0x124>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
  46b26c:	00801234 	movhi	r2,72
  46b270:	10a64f04 	addi	r2,r2,-26308
  46b274:	10800017 	ldw	r2,0(r2)
  46b278:	10c00117 	ldw	r3,4(r2)
  46b27c:	00801234 	movhi	r2,72
  46b280:	10a64f04 	addi	r2,r2,-26308
  46b284:	10c00015 	stw	r3,0(r2)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
  46b288:	e0bff817 	ldw	r2,-32(fp)
  46b28c:	00c00144 	movi	r3,5
  46b290:	10c00005 	stb	r3,0(r2)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
  46b294:	e0bff817 	ldw	r2,-32(fp)
  46b298:	e0fffe0b 	ldhu	r3,-8(fp)
  46b29c:	10c0020d 	sth	r3,8(r2)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
  46b2a0:	e0bff817 	ldw	r2,-32(fp)
  46b2a4:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
  46b2a8:	e0bff817 	ldw	r2,-32(fp)
  46b2ac:	00c00fc4 	movi	r3,63
  46b2b0:	10c00285 	stb	r3,10(r2)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
  46b2b4:	e0bff817 	ldw	r2,-32(fp)
  46b2b8:	100002c5 	stb	zero,11(r2)
  46b2bc:	e0bff717 	ldw	r2,-36(fp)
  46b2c0:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46b2c4:	0005303a 	rdctl	r2,status
  46b2c8:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46b2cc:	e0fffb17 	ldw	r3,-20(fp)
  46b2d0:	00bfff84 	movi	r2,-2
  46b2d4:	1884703a 	and	r2,r3,r2
  46b2d8:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46b2dc:	e0bffa17 	ldw	r2,-24(fp)
  46b2e0:	1080004c 	andi	r2,r2,1
  46b2e4:	e0fffb17 	ldw	r3,-20(fp)
  46b2e8:	1884b03a 	or	r2,r3,r2
  46b2ec:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
  46b2f0:	e0bffb17 	ldw	r2,-20(fp)
  46b2f4:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
  46b2f8:	e0bfff17 	ldw	r2,-4(fp)
  46b2fc:	10000005 	stb	zero,0(r2)
  46b300:	00001206 	br	46b34c <OSFlagCreate+0x16c>
  46b304:	e0bff717 	ldw	r2,-36(fp)
  46b308:	e0bffc15 	stw	r2,-16(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46b30c:	0005303a 	rdctl	r2,status
  46b310:	e0bffd15 	stw	r2,-12(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46b314:	e0fffd17 	ldw	r3,-12(fp)
  46b318:	00bfff84 	movi	r2,-2
  46b31c:	1884703a 	and	r2,r3,r2
  46b320:	e0bffd15 	stw	r2,-12(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46b324:	e0bffc17 	ldw	r2,-16(fp)
  46b328:	1080004c 	andi	r2,r2,1
  46b32c:	e0fffd17 	ldw	r3,-12(fp)
  46b330:	1884b03a 	or	r2,r3,r2
  46b334:	e0bffd15 	stw	r2,-12(fp)
  
  NIOS2_WRITE_STATUS (status);
  46b338:	e0bffd17 	ldw	r2,-12(fp)
  46b33c:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
  46b340:	e0bfff17 	ldw	r2,-4(fp)
  46b344:	00c01c84 	movi	r3,114
  46b348:	10c00005 	stb	r3,0(r2)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
  46b34c:	e0bff817 	ldw	r2,-32(fp)
}
  46b350:	e037883a 	mov	sp,fp
  46b354:	df000017 	ldw	fp,0(sp)
  46b358:	dec00104 	addi	sp,sp,4
  46b35c:	f800283a 	ret

0046b360 <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
  46b360:	deffee04 	addi	sp,sp,-72
  46b364:	dfc01115 	stw	ra,68(sp)
  46b368:	df001015 	stw	fp,64(sp)
  46b36c:	df001004 	addi	fp,sp,64
  46b370:	e13ffd15 	stw	r4,-12(fp)
  46b374:	2805883a 	mov	r2,r5
  46b378:	e1bfff15 	stw	r6,-4(fp)
  46b37c:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
  46b380:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
  46b384:	e0bfff17 	ldw	r2,-4(fp)
  46b388:	1000021e 	bne	r2,zero,46b394 <OSFlagDel+0x34>
        return (pgrp);
  46b38c:	e0bffd17 	ldw	r2,-12(fp)
  46b390:	0000b606 	br	46b66c <OSFlagDel+0x30c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
  46b394:	e0bffd17 	ldw	r2,-12(fp)
  46b398:	1000051e 	bne	r2,zero,46b3b0 <OSFlagDel+0x50>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
  46b39c:	e0bfff17 	ldw	r2,-4(fp)
  46b3a0:	00c01b84 	movi	r3,110
  46b3a4:	10c00005 	stb	r3,0(r2)
        return (pgrp);
  46b3a8:	e0bffd17 	ldw	r2,-12(fp)
  46b3ac:	0000af06 	br	46b66c <OSFlagDel+0x30c>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
  46b3b0:	00801234 	movhi	r2,72
  46b3b4:	10a64c04 	addi	r2,r2,-26320
  46b3b8:	10800003 	ldbu	r2,0(r2)
  46b3bc:	10803fcc 	andi	r2,r2,255
  46b3c0:	10000526 	beq	r2,zero,46b3d8 <OSFlagDel+0x78>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
  46b3c4:	e0bfff17 	ldw	r2,-4(fp)
  46b3c8:	00c003c4 	movi	r3,15
  46b3cc:	10c00005 	stb	r3,0(r2)
        return (pgrp);
  46b3d0:	e0bffd17 	ldw	r2,-12(fp)
  46b3d4:	0000a506 	br	46b66c <OSFlagDel+0x30c>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
  46b3d8:	e0bffd17 	ldw	r2,-12(fp)
  46b3dc:	10800003 	ldbu	r2,0(r2)
  46b3e0:	10803fcc 	andi	r2,r2,255
  46b3e4:	10800160 	cmpeqi	r2,r2,5
  46b3e8:	1000051e 	bne	r2,zero,46b400 <OSFlagDel+0xa0>
        *perr = OS_ERR_EVENT_TYPE;
  46b3ec:	e0bfff17 	ldw	r2,-4(fp)
  46b3f0:	00c00044 	movi	r3,1
  46b3f4:	10c00005 	stb	r3,0(r2)
        return (pgrp);
  46b3f8:	e0bffd17 	ldw	r2,-12(fp)
  46b3fc:	00009b06 	br	46b66c <OSFlagDel+0x30c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46b400:	0005303a 	rdctl	r2,status
  46b404:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46b408:	e0fff417 	ldw	r3,-48(fp)
  46b40c:	00bfff84 	movi	r2,-2
  46b410:	1884703a 	and	r2,r3,r2
  46b414:	1001703a 	wrctl	status,r2
  
  return context;
  46b418:	e0bff417 	ldw	r2,-48(fp)
    }
    OS_ENTER_CRITICAL();
  46b41c:	e0bff315 	stw	r2,-52(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
  46b420:	e0bffd17 	ldw	r2,-12(fp)
  46b424:	10800117 	ldw	r2,4(r2)
  46b428:	10000326 	beq	r2,zero,46b438 <OSFlagDel+0xd8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
  46b42c:	00800044 	movi	r2,1
  46b430:	e0bff005 	stb	r2,-64(fp)
  46b434:	00000106 	br	46b43c <OSFlagDel+0xdc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
  46b438:	e03ff005 	stb	zero,-64(fp)
    }
    switch (opt) {
  46b43c:	e0bffe03 	ldbu	r2,-8(fp)
  46b440:	10000326 	beq	r2,zero,46b450 <OSFlagDel+0xf0>
  46b444:	10800060 	cmpeqi	r2,r2,1
  46b448:	10003d1e 	bne	r2,zero,46b540 <OSFlagDel+0x1e0>
  46b44c:	00007106 	br	46b614 <OSFlagDel+0x2b4>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
  46b450:	e0bff003 	ldbu	r2,-64(fp)
  46b454:	1000251e 	bne	r2,zero,46b4ec <OSFlagDel+0x18c>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
  46b458:	e0bffd17 	ldw	r2,-12(fp)
  46b45c:	00c00fc4 	movi	r3,63
  46b460:	10c00285 	stb	r3,10(r2)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
  46b464:	e0bffd17 	ldw	r2,-12(fp)
  46b468:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
  46b46c:	e0bffd17 	ldw	r2,-12(fp)
  46b470:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
  46b474:	00801234 	movhi	r2,72
  46b478:	10a64f04 	addi	r2,r2,-26308
  46b47c:	10c00017 	ldw	r3,0(r2)
  46b480:	e0bffd17 	ldw	r2,-12(fp)
  46b484:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
  46b488:	e0bffd17 	ldw	r2,-12(fp)
  46b48c:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
  46b490:	00801234 	movhi	r2,72
  46b494:	10a64f04 	addi	r2,r2,-26308
  46b498:	e0fffd17 	ldw	r3,-12(fp)
  46b49c:	10c00015 	stw	r3,0(r2)
  46b4a0:	e0bff317 	ldw	r2,-52(fp)
  46b4a4:	e0bff515 	stw	r2,-44(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46b4a8:	0005303a 	rdctl	r2,status
  46b4ac:	e0bff615 	stw	r2,-40(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46b4b0:	e0fff617 	ldw	r3,-40(fp)
  46b4b4:	00bfff84 	movi	r2,-2
  46b4b8:	1884703a 	and	r2,r3,r2
  46b4bc:	e0bff615 	stw	r2,-40(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46b4c0:	e0bff517 	ldw	r2,-44(fp)
  46b4c4:	1080004c 	andi	r2,r2,1
  46b4c8:	e0fff617 	ldw	r3,-40(fp)
  46b4cc:	1884b03a 	or	r2,r3,r2
  46b4d0:	e0bff615 	stw	r2,-40(fp)
  
  NIOS2_WRITE_STATUS (status);
  46b4d4:	e0bff617 	ldw	r2,-40(fp)
  46b4d8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
  46b4dc:	e0bfff17 	ldw	r2,-4(fp)
  46b4e0:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
  46b4e4:	e03ff215 	stw	zero,-56(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
                 pgrp_return          = pgrp;
             }
             break;
  46b4e8:	00005f06 	br	46b668 <OSFlagDel+0x308>
  46b4ec:	e0bff317 	ldw	r2,-52(fp)
  46b4f0:	e0bff715 	stw	r2,-36(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46b4f4:	0005303a 	rdctl	r2,status
  46b4f8:	e0bff815 	stw	r2,-32(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46b4fc:	e0fff817 	ldw	r3,-32(fp)
  46b500:	00bfff84 	movi	r2,-2
  46b504:	1884703a 	and	r2,r3,r2
  46b508:	e0bff815 	stw	r2,-32(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46b50c:	e0bff717 	ldw	r2,-36(fp)
  46b510:	1080004c 	andi	r2,r2,1
  46b514:	e0fff817 	ldw	r3,-32(fp)
  46b518:	1884b03a 	or	r2,r3,r2
  46b51c:	e0bff815 	stw	r2,-32(fp)
  
  NIOS2_WRITE_STATUS (status);
  46b520:	e0bff817 	ldw	r2,-32(fp)
  46b524:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
  46b528:	e0bfff17 	ldw	r2,-4(fp)
  46b52c:	00c01244 	movi	r3,73
  46b530:	10c00005 	stb	r3,0(r2)
                 pgrp_return          = pgrp;
  46b534:	e0bffd17 	ldw	r2,-12(fp)
  46b538:	e0bff215 	stw	r2,-56(fp)
             }
             break;
  46b53c:	00004a06 	br	46b668 <OSFlagDel+0x308>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
  46b540:	e0bffd17 	ldw	r2,-12(fp)
  46b544:	10800117 	ldw	r2,4(r2)
  46b548:	e0bff115 	stw	r2,-60(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
  46b54c:	00000606 	br	46b568 <OSFlagDel+0x208>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
  46b550:	e13ff117 	ldw	r4,-60(fp)
  46b554:	000b883a 	mov	r5,zero
  46b558:	046ca5c0 	call	46ca5c <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
  46b55c:	e0bff117 	ldw	r2,-60(fp)
  46b560:	10800017 	ldw	r2,0(r2)
  46b564:	e0bff115 	stw	r2,-60(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
  46b568:	e0bff117 	ldw	r2,-60(fp)
  46b56c:	103ff81e 	bne	r2,zero,46b550 <OSFlagDel+0x1f0>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
  46b570:	e0bffd17 	ldw	r2,-12(fp)
  46b574:	00c00fc4 	movi	r3,63
  46b578:	10c00285 	stb	r3,10(r2)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
  46b57c:	e0bffd17 	ldw	r2,-12(fp)
  46b580:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
  46b584:	e0bffd17 	ldw	r2,-12(fp)
  46b588:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
  46b58c:	00801234 	movhi	r2,72
  46b590:	10a64f04 	addi	r2,r2,-26308
  46b594:	10c00017 	ldw	r3,0(r2)
  46b598:	e0bffd17 	ldw	r2,-12(fp)
  46b59c:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
  46b5a0:	e0bffd17 	ldw	r2,-12(fp)
  46b5a4:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
  46b5a8:	00801234 	movhi	r2,72
  46b5ac:	10a64f04 	addi	r2,r2,-26308
  46b5b0:	e0fffd17 	ldw	r3,-12(fp)
  46b5b4:	10c00015 	stw	r3,0(r2)
  46b5b8:	e0bff317 	ldw	r2,-52(fp)
  46b5bc:	e0bff915 	stw	r2,-28(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46b5c0:	0005303a 	rdctl	r2,status
  46b5c4:	e0bffa15 	stw	r2,-24(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46b5c8:	e0fffa17 	ldw	r3,-24(fp)
  46b5cc:	00bfff84 	movi	r2,-2
  46b5d0:	1884703a 	and	r2,r3,r2
  46b5d4:	e0bffa15 	stw	r2,-24(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46b5d8:	e0bff917 	ldw	r2,-28(fp)
  46b5dc:	1080004c 	andi	r2,r2,1
  46b5e0:	e0fffa17 	ldw	r3,-24(fp)
  46b5e4:	1884b03a 	or	r2,r3,r2
  46b5e8:	e0bffa15 	stw	r2,-24(fp)
  
  NIOS2_WRITE_STATUS (status);
  46b5ec:	e0bffa17 	ldw	r2,-24(fp)
  46b5f0:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
  46b5f4:	e0bff003 	ldbu	r2,-64(fp)
  46b5f8:	10800058 	cmpnei	r2,r2,1
  46b5fc:	1000011e 	bne	r2,zero,46b604 <OSFlagDel+0x2a4>
                 OS_Sched();                               /* Find highest priority task ready to run  */
  46b600:	046a4980 	call	46a498 <OS_Sched>
             }
             *perr = OS_ERR_NONE;
  46b604:	e0bfff17 	ldw	r2,-4(fp)
  46b608:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
  46b60c:	e03ff215 	stw	zero,-56(fp)
             break;
  46b610:	00001506 	br	46b668 <OSFlagDel+0x308>
  46b614:	e0bff317 	ldw	r2,-52(fp)
  46b618:	e0bffb15 	stw	r2,-20(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46b61c:	0005303a 	rdctl	r2,status
  46b620:	e0bffc15 	stw	r2,-16(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46b624:	e0fffc17 	ldw	r3,-16(fp)
  46b628:	00bfff84 	movi	r2,-2
  46b62c:	1884703a 	and	r2,r3,r2
  46b630:	e0bffc15 	stw	r2,-16(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46b634:	e0bffb17 	ldw	r2,-20(fp)
  46b638:	1080004c 	andi	r2,r2,1
  46b63c:	e0fffc17 	ldw	r3,-16(fp)
  46b640:	1884b03a 	or	r2,r3,r2
  46b644:	e0bffc15 	stw	r2,-16(fp)
  
  NIOS2_WRITE_STATUS (status);
  46b648:	e0bffc17 	ldw	r2,-16(fp)
  46b64c:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
  46b650:	e0bfff17 	ldw	r2,-4(fp)
  46b654:	00c001c4 	movi	r3,7
  46b658:	10c00005 	stb	r3,0(r2)
             pgrp_return          = pgrp;
  46b65c:	e0bffd17 	ldw	r2,-12(fp)
  46b660:	e0bff215 	stw	r2,-56(fp)
             break;
  46b664:	0001883a 	nop
    }
    return (pgrp_return);
  46b668:	e0bff217 	ldw	r2,-56(fp)
}
  46b66c:	e037883a 	mov	sp,fp
  46b670:	dfc00117 	ldw	ra,4(sp)
  46b674:	df000017 	ldw	fp,0(sp)
  46b678:	dec00204 	addi	sp,sp,8
  46b67c:	f800283a 	ret

0046b680 <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
  46b680:	defff404 	addi	sp,sp,-48
  46b684:	dfc00b15 	stw	ra,44(sp)
  46b688:	df000a15 	stw	fp,40(sp)
  46b68c:	df000a04 	addi	fp,sp,40
  46b690:	e13ffd15 	stw	r4,-12(fp)
  46b694:	e17ffe15 	stw	r5,-8(fp)
  46b698:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
  46b69c:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
  46b6a0:	e0bfff17 	ldw	r2,-4(fp)
  46b6a4:	1000021e 	bne	r2,zero,46b6b0 <OSFlagNameGet+0x30>
        return (0);
  46b6a8:	0005883a 	mov	r2,zero
  46b6ac:	00005106 	br	46b7f4 <OSFlagNameGet+0x174>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
  46b6b0:	e0bffd17 	ldw	r2,-12(fp)
  46b6b4:	1000051e 	bne	r2,zero,46b6cc <OSFlagNameGet+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
  46b6b8:	e0bfff17 	ldw	r2,-4(fp)
  46b6bc:	00c01b84 	movi	r3,110
  46b6c0:	10c00005 	stb	r3,0(r2)
        return (0);
  46b6c4:	0005883a 	mov	r2,zero
  46b6c8:	00004a06 	br	46b7f4 <OSFlagNameGet+0x174>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
  46b6cc:	e0bffe17 	ldw	r2,-8(fp)
  46b6d0:	1000051e 	bne	r2,zero,46b6e8 <OSFlagNameGet+0x68>
        *perr = OS_ERR_PNAME_NULL;
  46b6d4:	e0bfff17 	ldw	r2,-4(fp)
  46b6d8:	00c00304 	movi	r3,12
  46b6dc:	10c00005 	stb	r3,0(r2)
        return (0);
  46b6e0:	0005883a 	mov	r2,zero
  46b6e4:	00004306 	br	46b7f4 <OSFlagNameGet+0x174>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
  46b6e8:	00801234 	movhi	r2,72
  46b6ec:	10a64c04 	addi	r2,r2,-26320
  46b6f0:	10800003 	ldbu	r2,0(r2)
  46b6f4:	10803fcc 	andi	r2,r2,255
  46b6f8:	10000526 	beq	r2,zero,46b710 <OSFlagNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
  46b6fc:	e0bfff17 	ldw	r2,-4(fp)
  46b700:	00c00444 	movi	r3,17
  46b704:	10c00005 	stb	r3,0(r2)
        return (0);
  46b708:	0005883a 	mov	r2,zero
  46b70c:	00003906 	br	46b7f4 <OSFlagNameGet+0x174>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46b710:	0005303a 	rdctl	r2,status
  46b714:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46b718:	e0fff817 	ldw	r3,-32(fp)
  46b71c:	00bfff84 	movi	r2,-2
  46b720:	1884703a 	and	r2,r3,r2
  46b724:	1001703a 	wrctl	status,r2
  
  return context;
  46b728:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
  46b72c:	e0bff615 	stw	r2,-40(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
  46b730:	e0bffd17 	ldw	r2,-12(fp)
  46b734:	10800003 	ldbu	r2,0(r2)
  46b738:	10803fcc 	andi	r2,r2,255
  46b73c:	10800160 	cmpeqi	r2,r2,5
  46b740:	1000141e 	bne	r2,zero,46b794 <OSFlagNameGet+0x114>
  46b744:	e0bff617 	ldw	r2,-40(fp)
  46b748:	e0bff915 	stw	r2,-28(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46b74c:	0005303a 	rdctl	r2,status
  46b750:	e0bffa15 	stw	r2,-24(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46b754:	e0fffa17 	ldw	r3,-24(fp)
  46b758:	00bfff84 	movi	r2,-2
  46b75c:	1884703a 	and	r2,r3,r2
  46b760:	e0bffa15 	stw	r2,-24(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46b764:	e0bff917 	ldw	r2,-28(fp)
  46b768:	1080004c 	andi	r2,r2,1
  46b76c:	e0fffa17 	ldw	r3,-24(fp)
  46b770:	1884b03a 	or	r2,r3,r2
  46b774:	e0bffa15 	stw	r2,-24(fp)
  
  NIOS2_WRITE_STATUS (status);
  46b778:	e0bffa17 	ldw	r2,-24(fp)
  46b77c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
  46b780:	e0bfff17 	ldw	r2,-4(fp)
  46b784:	00c00044 	movi	r3,1
  46b788:	10c00005 	stb	r3,0(r2)
        return (0);
  46b78c:	0005883a 	mov	r2,zero
  46b790:	00001806 	br	46b7f4 <OSFlagNameGet+0x174>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
  46b794:	e0bffd17 	ldw	r2,-12(fp)
  46b798:	10800284 	addi	r2,r2,10
  46b79c:	e13ffe17 	ldw	r4,-8(fp)
  46b7a0:	100b883a 	mov	r5,r2
  46b7a4:	046a6000 	call	46a600 <OS_StrCopy>
  46b7a8:	e0bff705 	stb	r2,-36(fp)
  46b7ac:	e0bff617 	ldw	r2,-40(fp)
  46b7b0:	e0bffb15 	stw	r2,-20(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46b7b4:	0005303a 	rdctl	r2,status
  46b7b8:	e0bffc15 	stw	r2,-16(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46b7bc:	e0fffc17 	ldw	r3,-16(fp)
  46b7c0:	00bfff84 	movi	r2,-2
  46b7c4:	1884703a 	and	r2,r3,r2
  46b7c8:	e0bffc15 	stw	r2,-16(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46b7cc:	e0bffb17 	ldw	r2,-20(fp)
  46b7d0:	1080004c 	andi	r2,r2,1
  46b7d4:	e0fffc17 	ldw	r3,-16(fp)
  46b7d8:	1884b03a 	or	r2,r3,r2
  46b7dc:	e0bffc15 	stw	r2,-16(fp)
  
  NIOS2_WRITE_STATUS (status);
  46b7e0:	e0bffc17 	ldw	r2,-16(fp)
  46b7e4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
  46b7e8:	e0bfff17 	ldw	r2,-4(fp)
  46b7ec:	10000005 	stb	zero,0(r2)
    return (len);
  46b7f0:	e0bff703 	ldbu	r2,-36(fp)
}
  46b7f4:	e037883a 	mov	sp,fp
  46b7f8:	dfc00117 	ldw	ra,4(sp)
  46b7fc:	df000017 	ldw	fp,0(sp)
  46b800:	dec00204 	addi	sp,sp,8
  46b804:	f800283a 	ret

0046b808 <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
  46b808:	defff204 	addi	sp,sp,-56
  46b80c:	dfc00d15 	stw	ra,52(sp)
  46b810:	df000c15 	stw	fp,48(sp)
  46b814:	df000c04 	addi	fp,sp,48
  46b818:	e13ffd15 	stw	r4,-12(fp)
  46b81c:	e17ffe15 	stw	r5,-8(fp)
  46b820:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
  46b824:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
  46b828:	e0bfff17 	ldw	r2,-4(fp)
  46b82c:	10006626 	beq	r2,zero,46b9c8 <OSFlagNameSet+0x1c0>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
  46b830:	e0bffd17 	ldw	r2,-12(fp)
  46b834:	1000041e 	bne	r2,zero,46b848 <OSFlagNameSet+0x40>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
  46b838:	e0bfff17 	ldw	r2,-4(fp)
  46b83c:	00c01b84 	movi	r3,110
  46b840:	10c00005 	stb	r3,0(r2)
        return;
  46b844:	00006106 	br	46b9cc <OSFlagNameSet+0x1c4>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
  46b848:	e0bffe17 	ldw	r2,-8(fp)
  46b84c:	1000041e 	bne	r2,zero,46b860 <OSFlagNameSet+0x58>
        *perr = OS_ERR_PNAME_NULL;
  46b850:	e0bfff17 	ldw	r2,-4(fp)
  46b854:	00c00304 	movi	r3,12
  46b858:	10c00005 	stb	r3,0(r2)
        return;
  46b85c:	00005b06 	br	46b9cc <OSFlagNameSet+0x1c4>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
  46b860:	00801234 	movhi	r2,72
  46b864:	10a64c04 	addi	r2,r2,-26320
  46b868:	10800003 	ldbu	r2,0(r2)
  46b86c:	10803fcc 	andi	r2,r2,255
  46b870:	10000426 	beq	r2,zero,46b884 <OSFlagNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
  46b874:	e0bfff17 	ldw	r2,-4(fp)
  46b878:	00c00484 	movi	r3,18
  46b87c:	10c00005 	stb	r3,0(r2)
        return;
  46b880:	00005206 	br	46b9cc <OSFlagNameSet+0x1c4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46b884:	0005303a 	rdctl	r2,status
  46b888:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46b88c:	e0fff617 	ldw	r3,-40(fp)
  46b890:	00bfff84 	movi	r2,-2
  46b894:	1884703a 	and	r2,r3,r2
  46b898:	1001703a 	wrctl	status,r2
  
  return context;
  46b89c:	e0bff617 	ldw	r2,-40(fp)
    }
    OS_ENTER_CRITICAL();
  46b8a0:	e0bff415 	stw	r2,-48(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
  46b8a4:	e0bffd17 	ldw	r2,-12(fp)
  46b8a8:	10800003 	ldbu	r2,0(r2)
  46b8ac:	10803fcc 	andi	r2,r2,255
  46b8b0:	10800160 	cmpeqi	r2,r2,5
  46b8b4:	1000131e 	bne	r2,zero,46b904 <OSFlagNameSet+0xfc>
  46b8b8:	e0bff417 	ldw	r2,-48(fp)
  46b8bc:	e0bff715 	stw	r2,-36(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46b8c0:	0005303a 	rdctl	r2,status
  46b8c4:	e0bff815 	stw	r2,-32(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46b8c8:	e0fff817 	ldw	r3,-32(fp)
  46b8cc:	00bfff84 	movi	r2,-2
  46b8d0:	1884703a 	and	r2,r3,r2
  46b8d4:	e0bff815 	stw	r2,-32(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46b8d8:	e0bff717 	ldw	r2,-36(fp)
  46b8dc:	1080004c 	andi	r2,r2,1
  46b8e0:	e0fff817 	ldw	r3,-32(fp)
  46b8e4:	1884b03a 	or	r2,r3,r2
  46b8e8:	e0bff815 	stw	r2,-32(fp)
  
  NIOS2_WRITE_STATUS (status);
  46b8ec:	e0bff817 	ldw	r2,-32(fp)
  46b8f0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
  46b8f4:	e0bfff17 	ldw	r2,-4(fp)
  46b8f8:	00c00044 	movi	r3,1
  46b8fc:	10c00005 	stb	r3,0(r2)
        return;
  46b900:	00003206 	br	46b9cc <OSFlagNameSet+0x1c4>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
  46b904:	e13ffe17 	ldw	r4,-8(fp)
  46b908:	046a67c0 	call	46a67c <OS_StrLen>
  46b90c:	e0bff505 	stb	r2,-44(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
  46b910:	e0bff503 	ldbu	r2,-44(fp)
  46b914:	10800830 	cmpltui	r2,r2,32
  46b918:	1000131e 	bne	r2,zero,46b968 <OSFlagNameSet+0x160>
  46b91c:	e0bff417 	ldw	r2,-48(fp)
  46b920:	e0bff915 	stw	r2,-28(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46b924:	0005303a 	rdctl	r2,status
  46b928:	e0bffa15 	stw	r2,-24(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46b92c:	e0fffa17 	ldw	r3,-24(fp)
  46b930:	00bfff84 	movi	r2,-2
  46b934:	1884703a 	and	r2,r3,r2
  46b938:	e0bffa15 	stw	r2,-24(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46b93c:	e0bff917 	ldw	r2,-28(fp)
  46b940:	1080004c 	andi	r2,r2,1
  46b944:	e0fffa17 	ldw	r3,-24(fp)
  46b948:	1884b03a 	or	r2,r3,r2
  46b94c:	e0bffa15 	stw	r2,-24(fp)
  
  NIOS2_WRITE_STATUS (status);
  46b950:	e0bffa17 	ldw	r2,-24(fp)
  46b954:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
  46b958:	e0bfff17 	ldw	r2,-4(fp)
  46b95c:	00c01cc4 	movi	r3,115
  46b960:	10c00005 	stb	r3,0(r2)
        return;
  46b964:	00001906 	br	46b9cc <OSFlagNameSet+0x1c4>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
  46b968:	e0bffd17 	ldw	r2,-12(fp)
  46b96c:	10800284 	addi	r2,r2,10
  46b970:	1009883a 	mov	r4,r2
  46b974:	e17ffe17 	ldw	r5,-8(fp)
  46b978:	046a6000 	call	46a600 <OS_StrCopy>
  46b97c:	e0bff417 	ldw	r2,-48(fp)
  46b980:	e0bffb15 	stw	r2,-20(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46b984:	0005303a 	rdctl	r2,status
  46b988:	e0bffc15 	stw	r2,-16(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46b98c:	e0fffc17 	ldw	r3,-16(fp)
  46b990:	00bfff84 	movi	r2,-2
  46b994:	1884703a 	and	r2,r3,r2
  46b998:	e0bffc15 	stw	r2,-16(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46b99c:	e0bffb17 	ldw	r2,-20(fp)
  46b9a0:	1080004c 	andi	r2,r2,1
  46b9a4:	e0fffc17 	ldw	r3,-16(fp)
  46b9a8:	1884b03a 	or	r2,r3,r2
  46b9ac:	e0bffc15 	stw	r2,-16(fp)
  
  NIOS2_WRITE_STATUS (status);
  46b9b0:	e0bffc17 	ldw	r2,-16(fp)
  46b9b4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
  46b9b8:	e0bfff17 	ldw	r2,-4(fp)
  46b9bc:	10000005 	stb	zero,0(r2)
    return;
  46b9c0:	0001883a 	nop
  46b9c4:	00000106 	br	46b9cc <OSFlagNameSet+0x1c4>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
  46b9c8:	0001883a 	nop
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return;
}
  46b9cc:	e037883a 	mov	sp,fp
  46b9d0:	dfc00117 	ldw	ra,4(sp)
  46b9d4:	df000017 	ldw	fp,0(sp)
  46b9d8:	dec00204 	addi	sp,sp,8
  46b9dc:	f800283a 	ret

0046b9e0 <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
  46b9e0:	deffd604 	addi	sp,sp,-168
  46b9e4:	dfc02915 	stw	ra,164(sp)
  46b9e8:	df002815 	stw	fp,160(sp)
  46b9ec:	df002804 	addi	fp,sp,160
  46b9f0:	e13ffc15 	stw	r4,-16(fp)
  46b9f4:	2809883a 	mov	r4,r5
  46b9f8:	3007883a 	mov	r3,r6
  46b9fc:	3805883a 	mov	r2,r7
  46ba00:	e13ffd0d 	sth	r4,-12(fp)
  46ba04:	e0fffe05 	stb	r3,-8(fp)
  46ba08:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
  46ba0c:	e03fda15 	stw	zero,-152(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
  46ba10:	e0800217 	ldw	r2,8(fp)
  46ba14:	1000021e 	bne	r2,zero,46ba20 <OSFlagPend+0x40>
        return ((OS_FLAGS)0);
  46ba18:	0005883a 	mov	r2,zero
  46ba1c:	0001ef06 	br	46c1dc <OSFlagPend+0x7fc>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
  46ba20:	e0bffc17 	ldw	r2,-16(fp)
  46ba24:	1000051e 	bne	r2,zero,46ba3c <OSFlagPend+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
  46ba28:	e0800217 	ldw	r2,8(fp)
  46ba2c:	00c01b84 	movi	r3,110
  46ba30:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
  46ba34:	0005883a 	mov	r2,zero
  46ba38:	0001e806 	br	46c1dc <OSFlagPend+0x7fc>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
  46ba3c:	00801234 	movhi	r2,72
  46ba40:	10a64c04 	addi	r2,r2,-26320
  46ba44:	10800003 	ldbu	r2,0(r2)
  46ba48:	10803fcc 	andi	r2,r2,255
  46ba4c:	10000526 	beq	r2,zero,46ba64 <OSFlagPend+0x84>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
  46ba50:	e0800217 	ldw	r2,8(fp)
  46ba54:	00c00084 	movi	r3,2
  46ba58:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
  46ba5c:	0005883a 	mov	r2,zero
  46ba60:	0001de06 	br	46c1dc <OSFlagPend+0x7fc>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
  46ba64:	00801234 	movhi	r2,72
  46ba68:	10a63e04 	addi	r2,r2,-26376
  46ba6c:	10800003 	ldbu	r2,0(r2)
  46ba70:	10803fcc 	andi	r2,r2,255
  46ba74:	10000526 	beq	r2,zero,46ba8c <OSFlagPend+0xac>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
  46ba78:	e0800217 	ldw	r2,8(fp)
  46ba7c:	00c00344 	movi	r3,13
  46ba80:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
  46ba84:	0005883a 	mov	r2,zero
  46ba88:	0001d406 	br	46c1dc <OSFlagPend+0x7fc>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
  46ba8c:	e0bffc17 	ldw	r2,-16(fp)
  46ba90:	10800003 	ldbu	r2,0(r2)
  46ba94:	10803fcc 	andi	r2,r2,255
  46ba98:	10800160 	cmpeqi	r2,r2,5
  46ba9c:	1000051e 	bne	r2,zero,46bab4 <OSFlagPend+0xd4>
        *perr = OS_ERR_EVENT_TYPE;
  46baa0:	e0800217 	ldw	r2,8(fp)
  46baa4:	00c00044 	movi	r3,1
  46baa8:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
  46baac:	0005883a 	mov	r2,zero
  46bab0:	0001ca06 	br	46c1dc <OSFlagPend+0x7fc>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
  46bab4:	e0fffe03 	ldbu	r3,-8(fp)
  46bab8:	00bfe004 	movi	r2,-128
  46babc:	1884703a 	and	r2,r3,r2
  46bac0:	e0bfdb05 	stb	r2,-148(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
  46bac4:	e0bfdb03 	ldbu	r2,-148(fp)
  46bac8:	10000626 	beq	r2,zero,46bae4 <OSFlagPend+0x104>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
  46bacc:	e0bffe03 	ldbu	r2,-8(fp)
  46bad0:	10801fcc 	andi	r2,r2,127
  46bad4:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
  46bad8:	00800044 	movi	r2,1
  46badc:	e0bfd905 	stb	r2,-156(fp)
  46bae0:	00000106 	br	46bae8 <OSFlagPend+0x108>
    } else {
        consume    = OS_FALSE;
  46bae4:	e03fd905 	stb	zero,-156(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46bae8:	0005303a 	rdctl	r2,status
  46baec:	e0bfdd15 	stw	r2,-140(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46baf0:	e0ffdd17 	ldw	r3,-140(fp)
  46baf4:	00bfff84 	movi	r2,-2
  46baf8:	1884703a 	and	r2,r3,r2
  46bafc:	1001703a 	wrctl	status,r2
  
  return context;
  46bb00:	e0bfdd17 	ldw	r2,-140(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
  46bb04:	e0bfda15 	stw	r2,-152(fp)
    switch (wait_type) {
  46bb08:	e0bffe03 	ldbu	r2,-8(fp)
  46bb0c:	10c00060 	cmpeqi	r3,r2,1
  46bb10:	1800d71e 	bne	r3,zero,46be70 <OSFlagPend+0x490>
  46bb14:	10c00088 	cmpgei	r3,r2,2
  46bb18:	1800021e 	bne	r3,zero,46bb24 <OSFlagPend+0x144>
  46bb1c:	10008f26 	beq	r2,zero,46bd5c <OSFlagPend+0x37c>
  46bb20:	00011706 	br	46bf80 <OSFlagPend+0x5a0>
  46bb24:	10c000a0 	cmpeqi	r3,r2,2
  46bb28:	1800031e 	bne	r3,zero,46bb38 <OSFlagPend+0x158>
  46bb2c:	108000e0 	cmpeqi	r2,r2,3
  46bb30:	1000461e 	bne	r2,zero,46bc4c <OSFlagPend+0x26c>
  46bb34:	00011206 	br	46bf80 <OSFlagPend+0x5a0>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
  46bb38:	e0bffc17 	ldw	r2,-16(fp)
  46bb3c:	10c0020b 	ldhu	r3,8(r2)
  46bb40:	e0bffd0b 	ldhu	r2,-12(fp)
  46bb44:	1884703a 	and	r2,r3,r2
  46bb48:	e0bfdb8d 	sth	r2,-146(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
  46bb4c:	e0ffdb8b 	ldhu	r3,-146(fp)
  46bb50:	e0bffd0b 	ldhu	r2,-12(fp)
  46bb54:	1880241e 	bne	r3,r2,46bbe8 <OSFlagPend+0x208>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
  46bb58:	e0bfd903 	ldbu	r2,-156(fp)
  46bb5c:	10800058 	cmpnei	r2,r2,1
  46bb60:	1000091e 	bne	r2,zero,46bb88 <OSFlagPend+0x1a8>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
  46bb64:	e0bffc17 	ldw	r2,-16(fp)
  46bb68:	1080020b 	ldhu	r2,8(r2)
  46bb6c:	1007883a 	mov	r3,r2
  46bb70:	e0bfdb8b 	ldhu	r2,-146(fp)
  46bb74:	0084303a 	nor	r2,zero,r2
  46bb78:	1884703a 	and	r2,r3,r2
  46bb7c:	1007883a 	mov	r3,r2
  46bb80:	e0bffc17 	ldw	r2,-16(fp)
  46bb84:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
  46bb88:	00801234 	movhi	r2,72
  46bb8c:	10a64d04 	addi	r2,r2,-26316
  46bb90:	10800017 	ldw	r2,0(r2)
  46bb94:	e0ffdb8b 	ldhu	r3,-146(fp)
  46bb98:	10c00b0d 	sth	r3,44(r2)
  46bb9c:	e0bfda17 	ldw	r2,-152(fp)
  46bba0:	e0bfde15 	stw	r2,-136(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46bba4:	0005303a 	rdctl	r2,status
  46bba8:	e0bfdf15 	stw	r2,-132(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46bbac:	e0ffdf17 	ldw	r3,-132(fp)
  46bbb0:	00bfff84 	movi	r2,-2
  46bbb4:	1884703a 	and	r2,r3,r2
  46bbb8:	e0bfdf15 	stw	r2,-132(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46bbbc:	e0bfde17 	ldw	r2,-136(fp)
  46bbc0:	1080004c 	andi	r2,r2,1
  46bbc4:	e0ffdf17 	ldw	r3,-132(fp)
  46bbc8:	1884b03a 	or	r2,r3,r2
  46bbcc:	e0bfdf15 	stw	r2,-132(fp)
  
  NIOS2_WRITE_STATUS (status);
  46bbd0:	e0bfdf17 	ldw	r2,-132(fp)
  46bbd4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
  46bbd8:	e0800217 	ldw	r2,8(fp)
  46bbdc:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
  46bbe0:	e0bfdb8b 	ldhu	r2,-146(fp)
  46bbe4:	00017d06 	br	46c1dc <OSFlagPend+0x7fc>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
  46bbe8:	e0fffd0b 	ldhu	r3,-12(fp)
  46bbec:	e0bffe03 	ldbu	r2,-8(fp)
  46bbf0:	e13fff0b 	ldhu	r4,-4(fp)
  46bbf4:	e17ff704 	addi	r5,fp,-36
  46bbf8:	d9000015 	stw	r4,0(sp)
  46bbfc:	e13ffc17 	ldw	r4,-16(fp)
  46bc00:	180d883a 	mov	r6,r3
  46bc04:	100f883a 	mov	r7,r2
  46bc08:	046c7b80 	call	46c7b8 <OS_FlagBlock>
  46bc0c:	e0bfda17 	ldw	r2,-152(fp)
  46bc10:	e0bfe015 	stw	r2,-128(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46bc14:	0005303a 	rdctl	r2,status
  46bc18:	e0bfe115 	stw	r2,-124(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46bc1c:	e0ffe117 	ldw	r3,-124(fp)
  46bc20:	00bfff84 	movi	r2,-2
  46bc24:	1884703a 	and	r2,r3,r2
  46bc28:	e0bfe115 	stw	r2,-124(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46bc2c:	e0bfe017 	ldw	r2,-128(fp)
  46bc30:	1080004c 	andi	r2,r2,1
  46bc34:	e0ffe117 	ldw	r3,-124(fp)
  46bc38:	1884b03a 	or	r2,r3,r2
  46bc3c:	e0bfe115 	stw	r2,-124(fp)
  
  NIOS2_WRITE_STATUS (status);
  46bc40:	e0bfe117 	ldw	r2,-124(fp)
  46bc44:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
  46bc48:	0000e206 	br	46bfd4 <OSFlagPend+0x5f4>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
  46bc4c:	e0bffc17 	ldw	r2,-16(fp)
  46bc50:	10c0020b 	ldhu	r3,8(r2)
  46bc54:	e0bffd0b 	ldhu	r2,-12(fp)
  46bc58:	1884703a 	and	r2,r3,r2
  46bc5c:	e0bfdb8d 	sth	r2,-146(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
  46bc60:	e0bfdb8b 	ldhu	r2,-146(fp)
  46bc64:	10002426 	beq	r2,zero,46bcf8 <OSFlagPend+0x318>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
  46bc68:	e0bfd903 	ldbu	r2,-156(fp)
  46bc6c:	10800058 	cmpnei	r2,r2,1
  46bc70:	1000091e 	bne	r2,zero,46bc98 <OSFlagPend+0x2b8>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
  46bc74:	e0bffc17 	ldw	r2,-16(fp)
  46bc78:	1080020b 	ldhu	r2,8(r2)
  46bc7c:	1007883a 	mov	r3,r2
  46bc80:	e0bfdb8b 	ldhu	r2,-146(fp)
  46bc84:	0084303a 	nor	r2,zero,r2
  46bc88:	1884703a 	and	r2,r3,r2
  46bc8c:	1007883a 	mov	r3,r2
  46bc90:	e0bffc17 	ldw	r2,-16(fp)
  46bc94:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
  46bc98:	00801234 	movhi	r2,72
  46bc9c:	10a64d04 	addi	r2,r2,-26316
  46bca0:	10800017 	ldw	r2,0(r2)
  46bca4:	e0ffdb8b 	ldhu	r3,-146(fp)
  46bca8:	10c00b0d 	sth	r3,44(r2)
  46bcac:	e0bfda17 	ldw	r2,-152(fp)
  46bcb0:	e0bfe215 	stw	r2,-120(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46bcb4:	0005303a 	rdctl	r2,status
  46bcb8:	e0bfe315 	stw	r2,-116(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46bcbc:	e0ffe317 	ldw	r3,-116(fp)
  46bcc0:	00bfff84 	movi	r2,-2
  46bcc4:	1884703a 	and	r2,r3,r2
  46bcc8:	e0bfe315 	stw	r2,-116(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46bccc:	e0bfe217 	ldw	r2,-120(fp)
  46bcd0:	1080004c 	andi	r2,r2,1
  46bcd4:	e0ffe317 	ldw	r3,-116(fp)
  46bcd8:	1884b03a 	or	r2,r3,r2
  46bcdc:	e0bfe315 	stw	r2,-116(fp)
  
  NIOS2_WRITE_STATUS (status);
  46bce0:	e0bfe317 	ldw	r2,-116(fp)
  46bce4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
  46bce8:	e0800217 	ldw	r2,8(fp)
  46bcec:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
  46bcf0:	e0bfdb8b 	ldhu	r2,-146(fp)
  46bcf4:	00013906 	br	46c1dc <OSFlagPend+0x7fc>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
  46bcf8:	e0fffd0b 	ldhu	r3,-12(fp)
  46bcfc:	e0bffe03 	ldbu	r2,-8(fp)
  46bd00:	e13fff0b 	ldhu	r4,-4(fp)
  46bd04:	e17ff704 	addi	r5,fp,-36
  46bd08:	d9000015 	stw	r4,0(sp)
  46bd0c:	e13ffc17 	ldw	r4,-16(fp)
  46bd10:	180d883a 	mov	r6,r3
  46bd14:	100f883a 	mov	r7,r2
  46bd18:	046c7b80 	call	46c7b8 <OS_FlagBlock>
  46bd1c:	e0bfda17 	ldw	r2,-152(fp)
  46bd20:	e0bfe415 	stw	r2,-112(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46bd24:	0005303a 	rdctl	r2,status
  46bd28:	e0bfe515 	stw	r2,-108(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46bd2c:	e0ffe517 	ldw	r3,-108(fp)
  46bd30:	00bfff84 	movi	r2,-2
  46bd34:	1884703a 	and	r2,r3,r2
  46bd38:	e0bfe515 	stw	r2,-108(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46bd3c:	e0bfe417 	ldw	r2,-112(fp)
  46bd40:	1080004c 	andi	r2,r2,1
  46bd44:	e0ffe517 	ldw	r3,-108(fp)
  46bd48:	1884b03a 	or	r2,r3,r2
  46bd4c:	e0bfe515 	stw	r2,-108(fp)
  
  NIOS2_WRITE_STATUS (status);
  46bd50:	e0bfe517 	ldw	r2,-108(fp)
  46bd54:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
  46bd58:	00009e06 	br	46bfd4 <OSFlagPend+0x5f4>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
  46bd5c:	e0bffc17 	ldw	r2,-16(fp)
  46bd60:	1080020b 	ldhu	r2,8(r2)
  46bd64:	0084303a 	nor	r2,zero,r2
  46bd68:	1007883a 	mov	r3,r2
  46bd6c:	e0bffd0b 	ldhu	r2,-12(fp)
  46bd70:	1884703a 	and	r2,r3,r2
  46bd74:	e0bfdb8d 	sth	r2,-146(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
  46bd78:	e0ffdb8b 	ldhu	r3,-146(fp)
  46bd7c:	e0bffd0b 	ldhu	r2,-12(fp)
  46bd80:	1880221e 	bne	r3,r2,46be0c <OSFlagPend+0x42c>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
  46bd84:	e0bfd903 	ldbu	r2,-156(fp)
  46bd88:	10800058 	cmpnei	r2,r2,1
  46bd8c:	1000071e 	bne	r2,zero,46bdac <OSFlagPend+0x3cc>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
  46bd90:	e0bffc17 	ldw	r2,-16(fp)
  46bd94:	10c0020b 	ldhu	r3,8(r2)
  46bd98:	e0bfdb8b 	ldhu	r2,-146(fp)
  46bd9c:	1884b03a 	or	r2,r3,r2
  46bda0:	1007883a 	mov	r3,r2
  46bda4:	e0bffc17 	ldw	r2,-16(fp)
  46bda8:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
  46bdac:	00801234 	movhi	r2,72
  46bdb0:	10a64d04 	addi	r2,r2,-26316
  46bdb4:	10800017 	ldw	r2,0(r2)
  46bdb8:	e0ffdb8b 	ldhu	r3,-146(fp)
  46bdbc:	10c00b0d 	sth	r3,44(r2)
  46bdc0:	e0bfda17 	ldw	r2,-152(fp)
  46bdc4:	e0bfe615 	stw	r2,-104(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46bdc8:	0005303a 	rdctl	r2,status
  46bdcc:	e0bfe715 	stw	r2,-100(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46bdd0:	e0ffe717 	ldw	r3,-100(fp)
  46bdd4:	00bfff84 	movi	r2,-2
  46bdd8:	1884703a 	and	r2,r3,r2
  46bddc:	e0bfe715 	stw	r2,-100(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46bde0:	e0bfe617 	ldw	r2,-104(fp)
  46bde4:	1080004c 	andi	r2,r2,1
  46bde8:	e0ffe717 	ldw	r3,-100(fp)
  46bdec:	1884b03a 	or	r2,r3,r2
  46bdf0:	e0bfe715 	stw	r2,-100(fp)
  
  NIOS2_WRITE_STATUS (status);
  46bdf4:	e0bfe717 	ldw	r2,-100(fp)
  46bdf8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
  46bdfc:	e0800217 	ldw	r2,8(fp)
  46be00:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
  46be04:	e0bfdb8b 	ldhu	r2,-146(fp)
  46be08:	0000f406 	br	46c1dc <OSFlagPend+0x7fc>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
  46be0c:	e0fffd0b 	ldhu	r3,-12(fp)
  46be10:	e0bffe03 	ldbu	r2,-8(fp)
  46be14:	e13fff0b 	ldhu	r4,-4(fp)
  46be18:	e17ff704 	addi	r5,fp,-36
  46be1c:	d9000015 	stw	r4,0(sp)
  46be20:	e13ffc17 	ldw	r4,-16(fp)
  46be24:	180d883a 	mov	r6,r3
  46be28:	100f883a 	mov	r7,r2
  46be2c:	046c7b80 	call	46c7b8 <OS_FlagBlock>
  46be30:	e0bfda17 	ldw	r2,-152(fp)
  46be34:	e0bfe815 	stw	r2,-96(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46be38:	0005303a 	rdctl	r2,status
  46be3c:	e0bfe915 	stw	r2,-92(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46be40:	e0ffe917 	ldw	r3,-92(fp)
  46be44:	00bfff84 	movi	r2,-2
  46be48:	1884703a 	and	r2,r3,r2
  46be4c:	e0bfe915 	stw	r2,-92(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46be50:	e0bfe817 	ldw	r2,-96(fp)
  46be54:	1080004c 	andi	r2,r2,1
  46be58:	e0ffe917 	ldw	r3,-92(fp)
  46be5c:	1884b03a 	or	r2,r3,r2
  46be60:	e0bfe915 	stw	r2,-92(fp)
  
  NIOS2_WRITE_STATUS (status);
  46be64:	e0bfe917 	ldw	r2,-92(fp)
  46be68:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
  46be6c:	00005906 	br	46bfd4 <OSFlagPend+0x5f4>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
  46be70:	e0bffc17 	ldw	r2,-16(fp)
  46be74:	1080020b 	ldhu	r2,8(r2)
  46be78:	0084303a 	nor	r2,zero,r2
  46be7c:	1007883a 	mov	r3,r2
  46be80:	e0bffd0b 	ldhu	r2,-12(fp)
  46be84:	1884703a 	and	r2,r3,r2
  46be88:	e0bfdb8d 	sth	r2,-146(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
  46be8c:	e0bfdb8b 	ldhu	r2,-146(fp)
  46be90:	10002226 	beq	r2,zero,46bf1c <OSFlagPend+0x53c>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
  46be94:	e0bfd903 	ldbu	r2,-156(fp)
  46be98:	10800058 	cmpnei	r2,r2,1
  46be9c:	1000071e 	bne	r2,zero,46bebc <OSFlagPend+0x4dc>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
  46bea0:	e0bffc17 	ldw	r2,-16(fp)
  46bea4:	10c0020b 	ldhu	r3,8(r2)
  46bea8:	e0bfdb8b 	ldhu	r2,-146(fp)
  46beac:	1884b03a 	or	r2,r3,r2
  46beb0:	1007883a 	mov	r3,r2
  46beb4:	e0bffc17 	ldw	r2,-16(fp)
  46beb8:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
  46bebc:	00801234 	movhi	r2,72
  46bec0:	10a64d04 	addi	r2,r2,-26316
  46bec4:	10800017 	ldw	r2,0(r2)
  46bec8:	e0ffdb8b 	ldhu	r3,-146(fp)
  46becc:	10c00b0d 	sth	r3,44(r2)
  46bed0:	e0bfda17 	ldw	r2,-152(fp)
  46bed4:	e0bfea15 	stw	r2,-88(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46bed8:	0005303a 	rdctl	r2,status
  46bedc:	e0bfeb15 	stw	r2,-84(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46bee0:	e0ffeb17 	ldw	r3,-84(fp)
  46bee4:	00bfff84 	movi	r2,-2
  46bee8:	1884703a 	and	r2,r3,r2
  46beec:	e0bfeb15 	stw	r2,-84(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46bef0:	e0bfea17 	ldw	r2,-88(fp)
  46bef4:	1080004c 	andi	r2,r2,1
  46bef8:	e0ffeb17 	ldw	r3,-84(fp)
  46befc:	1884b03a 	or	r2,r3,r2
  46bf00:	e0bfeb15 	stw	r2,-84(fp)
  
  NIOS2_WRITE_STATUS (status);
  46bf04:	e0bfeb17 	ldw	r2,-84(fp)
  46bf08:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
  46bf0c:	e0800217 	ldw	r2,8(fp)
  46bf10:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
  46bf14:	e0bfdb8b 	ldhu	r2,-146(fp)
  46bf18:	0000b006 	br	46c1dc <OSFlagPend+0x7fc>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
  46bf1c:	e0fffd0b 	ldhu	r3,-12(fp)
  46bf20:	e0bffe03 	ldbu	r2,-8(fp)
  46bf24:	e13fff0b 	ldhu	r4,-4(fp)
  46bf28:	e17ff704 	addi	r5,fp,-36
  46bf2c:	d9000015 	stw	r4,0(sp)
  46bf30:	e13ffc17 	ldw	r4,-16(fp)
  46bf34:	180d883a 	mov	r6,r3
  46bf38:	100f883a 	mov	r7,r2
  46bf3c:	046c7b80 	call	46c7b8 <OS_FlagBlock>
  46bf40:	e0bfda17 	ldw	r2,-152(fp)
  46bf44:	e0bfec15 	stw	r2,-80(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46bf48:	0005303a 	rdctl	r2,status
  46bf4c:	e0bfed15 	stw	r2,-76(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46bf50:	e0ffed17 	ldw	r3,-76(fp)
  46bf54:	00bfff84 	movi	r2,-2
  46bf58:	1884703a 	and	r2,r3,r2
  46bf5c:	e0bfed15 	stw	r2,-76(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46bf60:	e0bfec17 	ldw	r2,-80(fp)
  46bf64:	1080004c 	andi	r2,r2,1
  46bf68:	e0ffed17 	ldw	r3,-76(fp)
  46bf6c:	1884b03a 	or	r2,r3,r2
  46bf70:	e0bfed15 	stw	r2,-76(fp)
  
  NIOS2_WRITE_STATUS (status);
  46bf74:	e0bfed17 	ldw	r2,-76(fp)
  46bf78:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
  46bf7c:	00001506 	br	46bfd4 <OSFlagPend+0x5f4>
  46bf80:	e0bfda17 	ldw	r2,-152(fp)
  46bf84:	e0bfee15 	stw	r2,-72(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46bf88:	0005303a 	rdctl	r2,status
  46bf8c:	e0bfef15 	stw	r2,-68(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46bf90:	e0ffef17 	ldw	r3,-68(fp)
  46bf94:	00bfff84 	movi	r2,-2
  46bf98:	1884703a 	and	r2,r3,r2
  46bf9c:	e0bfef15 	stw	r2,-68(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46bfa0:	e0bfee17 	ldw	r2,-72(fp)
  46bfa4:	1080004c 	andi	r2,r2,1
  46bfa8:	e0ffef17 	ldw	r3,-68(fp)
  46bfac:	1884b03a 	or	r2,r3,r2
  46bfb0:	e0bfef15 	stw	r2,-68(fp)
  
  NIOS2_WRITE_STATUS (status);
  46bfb4:	e0bfef17 	ldw	r2,-68(fp)
  46bfb8:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
  46bfbc:	e03fdb8d 	sth	zero,-146(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
  46bfc0:	e0800217 	ldw	r2,8(fp)
  46bfc4:	00c01bc4 	movi	r3,111
  46bfc8:	10c00005 	stb	r3,0(r2)
             return (flags_rdy);
  46bfcc:	e0bfdb8b 	ldhu	r2,-146(fp)
  46bfd0:	00008206 	br	46c1dc <OSFlagPend+0x7fc>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
  46bfd4:	046a4980 	call	46a498 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46bfd8:	0005303a 	rdctl	r2,status
  46bfdc:	e0bff015 	stw	r2,-64(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46bfe0:	e0fff017 	ldw	r3,-64(fp)
  46bfe4:	00bfff84 	movi	r2,-2
  46bfe8:	1884703a 	and	r2,r3,r2
  46bfec:	1001703a 	wrctl	status,r2
  
  return context;
  46bff0:	e0bff017 	ldw	r2,-64(fp)
    OS_ENTER_CRITICAL();
  46bff4:	e0bfda15 	stw	r2,-152(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
  46bff8:	00801234 	movhi	r2,72
  46bffc:	10a64d04 	addi	r2,r2,-26316
  46c000:	10800017 	ldw	r2,0(r2)
  46c004:	10800c43 	ldbu	r2,49(r2)
  46c008:	10803fcc 	andi	r2,r2,255
  46c00c:	10002d26 	beq	r2,zero,46c0c4 <OSFlagPend+0x6e4>
        pend_stat                = OSTCBCur->OSTCBStatPend;
  46c010:	00801234 	movhi	r2,72
  46c014:	10a64d04 	addi	r2,r2,-26316
  46c018:	10800017 	ldw	r2,0(r2)
  46c01c:	10800c43 	ldbu	r2,49(r2)
  46c020:	e0bfdc05 	stb	r2,-144(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
  46c024:	00801234 	movhi	r2,72
  46c028:	10a64d04 	addi	r2,r2,-26316
  46c02c:	10800017 	ldw	r2,0(r2)
  46c030:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
  46c034:	e0bff704 	addi	r2,fp,-36
  46c038:	1009883a 	mov	r4,r2
  46c03c:	046cb680 	call	46cb68 <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
  46c040:	00801234 	movhi	r2,72
  46c044:	10a64d04 	addi	r2,r2,-26316
  46c048:	10800017 	ldw	r2,0(r2)
  46c04c:	10000c05 	stb	zero,48(r2)
  46c050:	e0bfda17 	ldw	r2,-152(fp)
  46c054:	e0bff115 	stw	r2,-60(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46c058:	0005303a 	rdctl	r2,status
  46c05c:	e0bff215 	stw	r2,-56(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46c060:	e0fff217 	ldw	r3,-56(fp)
  46c064:	00bfff84 	movi	r2,-2
  46c068:	1884703a 	and	r2,r3,r2
  46c06c:	e0bff215 	stw	r2,-56(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46c070:	e0bff117 	ldw	r2,-60(fp)
  46c074:	1080004c 	andi	r2,r2,1
  46c078:	e0fff217 	ldw	r3,-56(fp)
  46c07c:	1884b03a 	or	r2,r3,r2
  46c080:	e0bff215 	stw	r2,-56(fp)
  
  NIOS2_WRITE_STATUS (status);
  46c084:	e0bff217 	ldw	r2,-56(fp)
  46c088:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
  46c08c:	e03fdb8d 	sth	zero,-146(fp)
        switch (pend_stat) {
  46c090:	e0bfdc03 	ldbu	r2,-144(fp)
  46c094:	108000a0 	cmpeqi	r2,r2,2
  46c098:	10000426 	beq	r2,zero,46c0ac <OSFlagPend+0x6cc>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
  46c09c:	e0800217 	ldw	r2,8(fp)
  46c0a0:	00c00384 	movi	r3,14
  46c0a4:	10c00005 	stb	r3,0(r2)
                 break;
  46c0a8:	00000406 	br	46c0bc <OSFlagPend+0x6dc>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
  46c0ac:	e0800217 	ldw	r2,8(fp)
  46c0b0:	00c00284 	movi	r3,10
  46c0b4:	10c00005 	stb	r3,0(r2)
                 break;
  46c0b8:	0001883a 	nop
        }
        return (flags_rdy);
  46c0bc:	e0bfdb8b 	ldhu	r2,-146(fp)
  46c0c0:	00004606 	br	46c1dc <OSFlagPend+0x7fc>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
  46c0c4:	00801234 	movhi	r2,72
  46c0c8:	10a64d04 	addi	r2,r2,-26316
  46c0cc:	10800017 	ldw	r2,0(r2)
  46c0d0:	10800b0b 	ldhu	r2,44(r2)
  46c0d4:	e0bfdb8d 	sth	r2,-146(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
  46c0d8:	e0bfd903 	ldbu	r2,-156(fp)
  46c0dc:	10800058 	cmpnei	r2,r2,1
  46c0e0:	10002c1e 	bne	r2,zero,46c194 <OSFlagPend+0x7b4>
        switch (wait_type) {
  46c0e4:	e0bffe03 	ldbu	r2,-8(fp)
  46c0e8:	10001616 	blt	r2,zero,46c144 <OSFlagPend+0x764>
  46c0ec:	10c00090 	cmplti	r3,r2,2
  46c0f0:	18000c1e 	bne	r3,zero,46c124 <OSFlagPend+0x744>
  46c0f4:	10800108 	cmpgei	r2,r2,4
  46c0f8:	1000121e 	bne	r2,zero,46c144 <OSFlagPend+0x764>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
  46c0fc:	e0bffc17 	ldw	r2,-16(fp)
  46c100:	1080020b 	ldhu	r2,8(r2)
  46c104:	1007883a 	mov	r3,r2
  46c108:	e0bfdb8b 	ldhu	r2,-146(fp)
  46c10c:	0084303a 	nor	r2,zero,r2
  46c110:	1884703a 	and	r2,r3,r2
  46c114:	1007883a 	mov	r3,r2
  46c118:	e0bffc17 	ldw	r2,-16(fp)
  46c11c:	10c0020d 	sth	r3,8(r2)
                 break;
  46c120:	00001c06 	br	46c194 <OSFlagPend+0x7b4>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
  46c124:	e0bffc17 	ldw	r2,-16(fp)
  46c128:	10c0020b 	ldhu	r3,8(r2)
  46c12c:	e0bfdb8b 	ldhu	r2,-146(fp)
  46c130:	1884b03a 	or	r2,r3,r2
  46c134:	1007883a 	mov	r3,r2
  46c138:	e0bffc17 	ldw	r2,-16(fp)
  46c13c:	10c0020d 	sth	r3,8(r2)
                 break;
  46c140:	00001406 	br	46c194 <OSFlagPend+0x7b4>
  46c144:	e0bfda17 	ldw	r2,-152(fp)
  46c148:	e0bff315 	stw	r2,-52(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46c14c:	0005303a 	rdctl	r2,status
  46c150:	e0bff415 	stw	r2,-48(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46c154:	e0fff417 	ldw	r3,-48(fp)
  46c158:	00bfff84 	movi	r2,-2
  46c15c:	1884703a 	and	r2,r3,r2
  46c160:	e0bff415 	stw	r2,-48(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46c164:	e0bff317 	ldw	r2,-52(fp)
  46c168:	1080004c 	andi	r2,r2,1
  46c16c:	e0fff417 	ldw	r3,-48(fp)
  46c170:	1884b03a 	or	r2,r3,r2
  46c174:	e0bff415 	stw	r2,-48(fp)
  
  NIOS2_WRITE_STATUS (status);
  46c178:	e0bff417 	ldw	r2,-48(fp)
  46c17c:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
  46c180:	e0800217 	ldw	r2,8(fp)
  46c184:	00c01bc4 	movi	r3,111
  46c188:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
  46c18c:	0005883a 	mov	r2,zero
  46c190:	00001206 	br	46c1dc <OSFlagPend+0x7fc>
  46c194:	e0bfda17 	ldw	r2,-152(fp)
  46c198:	e0bff515 	stw	r2,-44(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46c19c:	0005303a 	rdctl	r2,status
  46c1a0:	e0bff615 	stw	r2,-40(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46c1a4:	e0fff617 	ldw	r3,-40(fp)
  46c1a8:	00bfff84 	movi	r2,-2
  46c1ac:	1884703a 	and	r2,r3,r2
  46c1b0:	e0bff615 	stw	r2,-40(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46c1b4:	e0bff517 	ldw	r2,-44(fp)
  46c1b8:	1080004c 	andi	r2,r2,1
  46c1bc:	e0fff617 	ldw	r3,-40(fp)
  46c1c0:	1884b03a 	or	r2,r3,r2
  46c1c4:	e0bff615 	stw	r2,-40(fp)
  
  NIOS2_WRITE_STATUS (status);
  46c1c8:	e0bff617 	ldw	r2,-40(fp)
  46c1cc:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
  46c1d0:	e0800217 	ldw	r2,8(fp)
  46c1d4:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
  46c1d8:	e0bfdb8b 	ldhu	r2,-146(fp)
}
  46c1dc:	e037883a 	mov	sp,fp
  46c1e0:	dfc00117 	ldw	ra,4(sp)
  46c1e4:	df000017 	ldw	fp,0(sp)
  46c1e8:	dec00204 	addi	sp,sp,8
  46c1ec:	f800283a 	ret

0046c1f0 <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
  46c1f0:	defffa04 	addi	sp,sp,-24
  46c1f4:	df000515 	stw	fp,20(sp)
  46c1f8:	df000504 	addi	fp,sp,20
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
  46c1fc:	e03ffb15 	stw	zero,-20(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46c200:	0005303a 	rdctl	r2,status
  46c204:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46c208:	e0fffd17 	ldw	r3,-12(fp)
  46c20c:	00bfff84 	movi	r2,-2
  46c210:	1884703a 	and	r2,r3,r2
  46c214:	1001703a 	wrctl	status,r2
  
  return context;
  46c218:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
  46c21c:	e0bffb15 	stw	r2,-20(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
  46c220:	00801234 	movhi	r2,72
  46c224:	10a64d04 	addi	r2,r2,-26316
  46c228:	10800017 	ldw	r2,0(r2)
  46c22c:	10800b0b 	ldhu	r2,44(r2)
  46c230:	e0bffc0d 	sth	r2,-16(fp)
  46c234:	e0bffb17 	ldw	r2,-20(fp)
  46c238:	e0bffe15 	stw	r2,-8(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46c23c:	0005303a 	rdctl	r2,status
  46c240:	e0bfff15 	stw	r2,-4(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46c244:	e0ffff17 	ldw	r3,-4(fp)
  46c248:	00bfff84 	movi	r2,-2
  46c24c:	1884703a 	and	r2,r3,r2
  46c250:	e0bfff15 	stw	r2,-4(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46c254:	e0bffe17 	ldw	r2,-8(fp)
  46c258:	1080004c 	andi	r2,r2,1
  46c25c:	e0ffff17 	ldw	r3,-4(fp)
  46c260:	1884b03a 	or	r2,r3,r2
  46c264:	e0bfff15 	stw	r2,-4(fp)
  
  NIOS2_WRITE_STATUS (status);
  46c268:	e0bfff17 	ldw	r2,-4(fp)
  46c26c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
  46c270:	e0bffc0b 	ldhu	r2,-16(fp)
}
  46c274:	e037883a 	mov	sp,fp
  46c278:	df000017 	ldw	fp,0(sp)
  46c27c:	dec00104 	addi	sp,sp,4
  46c280:	f800283a 	ret

0046c284 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
  46c284:	deffeb04 	addi	sp,sp,-84
  46c288:	dfc01415 	stw	ra,80(sp)
  46c28c:	df001315 	stw	fp,76(sp)
  46c290:	df001304 	addi	fp,sp,76
  46c294:	e13ffc15 	stw	r4,-16(fp)
  46c298:	2807883a 	mov	r3,r5
  46c29c:	3005883a 	mov	r2,r6
  46c2a0:	e1ffff15 	stw	r7,-4(fp)
  46c2a4:	e0fffd0d 	sth	r3,-12(fp)
  46c2a8:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
  46c2ac:	e03fef15 	stw	zero,-68(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
  46c2b0:	e0bfff17 	ldw	r2,-4(fp)
  46c2b4:	1000021e 	bne	r2,zero,46c2c0 <OSFlagPost+0x3c>
        return ((OS_FLAGS)0);
  46c2b8:	0005883a 	mov	r2,zero
  46c2bc:	0000fd06 	br	46c6b4 <OSFlagPost+0x430>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
  46c2c0:	e0bffc17 	ldw	r2,-16(fp)
  46c2c4:	1000051e 	bne	r2,zero,46c2dc <OSFlagPost+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
  46c2c8:	e0bfff17 	ldw	r2,-4(fp)
  46c2cc:	00c01b84 	movi	r3,110
  46c2d0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
  46c2d4:	0005883a 	mov	r2,zero
  46c2d8:	0000f606 	br	46c6b4 <OSFlagPost+0x430>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
  46c2dc:	e0bffc17 	ldw	r2,-16(fp)
  46c2e0:	10800003 	ldbu	r2,0(r2)
  46c2e4:	10803fcc 	andi	r2,r2,255
  46c2e8:	10800160 	cmpeqi	r2,r2,5
  46c2ec:	1000051e 	bne	r2,zero,46c304 <OSFlagPost+0x80>
        *perr = OS_ERR_EVENT_TYPE;
  46c2f0:	e0bfff17 	ldw	r2,-4(fp)
  46c2f4:	00c00044 	movi	r3,1
  46c2f8:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
  46c2fc:	0005883a 	mov	r2,zero
  46c300:	0000ec06 	br	46c6b4 <OSFlagPost+0x430>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46c304:	0005303a 	rdctl	r2,status
  46c308:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46c30c:	e0fff217 	ldw	r3,-56(fp)
  46c310:	00bfff84 	movi	r2,-2
  46c314:	1884703a 	and	r2,r3,r2
  46c318:	1001703a 	wrctl	status,r2
  
  return context;
  46c31c:	e0bff217 	ldw	r2,-56(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
  46c320:	e0bfef15 	stw	r2,-68(fp)
    switch (opt) {
  46c324:	e0bffe03 	ldbu	r2,-8(fp)
  46c328:	10000326 	beq	r2,zero,46c338 <OSFlagPost+0xb4>
  46c32c:	10800060 	cmpeqi	r2,r2,1
  46c330:	10000b1e 	bne	r2,zero,46c360 <OSFlagPost+0xdc>
  46c334:	00001206 	br	46c380 <OSFlagPost+0xfc>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
  46c338:	e0bffc17 	ldw	r2,-16(fp)
  46c33c:	1080020b 	ldhu	r2,8(r2)
  46c340:	1007883a 	mov	r3,r2
  46c344:	e0bffd0b 	ldhu	r2,-12(fp)
  46c348:	0084303a 	nor	r2,zero,r2
  46c34c:	1884703a 	and	r2,r3,r2
  46c350:	1007883a 	mov	r3,r2
  46c354:	e0bffc17 	ldw	r2,-16(fp)
  46c358:	10c0020d 	sth	r3,8(r2)
             break;
  46c35c:	00001c06 	br	46c3d0 <OSFlagPost+0x14c>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
  46c360:	e0bffc17 	ldw	r2,-16(fp)
  46c364:	10c0020b 	ldhu	r3,8(r2)
  46c368:	e0bffd0b 	ldhu	r2,-12(fp)
  46c36c:	1884b03a 	or	r2,r3,r2
  46c370:	1007883a 	mov	r3,r2
  46c374:	e0bffc17 	ldw	r2,-16(fp)
  46c378:	10c0020d 	sth	r3,8(r2)
             break;
  46c37c:	00001406 	br	46c3d0 <OSFlagPost+0x14c>
  46c380:	e0bfef17 	ldw	r2,-68(fp)
  46c384:	e0bff315 	stw	r2,-52(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46c388:	0005303a 	rdctl	r2,status
  46c38c:	e0bff415 	stw	r2,-48(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46c390:	e0fff417 	ldw	r3,-48(fp)
  46c394:	00bfff84 	movi	r2,-2
  46c398:	1884703a 	and	r2,r3,r2
  46c39c:	e0bff415 	stw	r2,-48(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46c3a0:	e0bff317 	ldw	r2,-52(fp)
  46c3a4:	1080004c 	andi	r2,r2,1
  46c3a8:	e0fff417 	ldw	r3,-48(fp)
  46c3ac:	1884b03a 	or	r2,r3,r2
  46c3b0:	e0bff415 	stw	r2,-48(fp)
  
  NIOS2_WRITE_STATUS (status);
  46c3b4:	e0bff417 	ldw	r2,-48(fp)
  46c3b8:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
  46c3bc:	e0bfff17 	ldw	r2,-4(fp)
  46c3c0:	00c01c44 	movi	r3,113
  46c3c4:	10c00005 	stb	r3,0(r2)
             return ((OS_FLAGS)0);
  46c3c8:	0005883a 	mov	r2,zero
  46c3cc:	0000b906 	br	46c6b4 <OSFlagPost+0x430>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
  46c3d0:	e03fee05 	stb	zero,-72(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
  46c3d4:	e0bffc17 	ldw	r2,-16(fp)
  46c3d8:	10800117 	ldw	r2,4(r2)
  46c3dc:	e0bfed15 	stw	r2,-76(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
  46c3e0:	00008206 	br	46c5ec <OSFlagPost+0x368>
        switch (pnode->OSFlagNodeWaitType) {
  46c3e4:	e0bfed17 	ldw	r2,-76(fp)
  46c3e8:	10800483 	ldbu	r2,18(r2)
  46c3ec:	10803fcc 	andi	r2,r2,255
  46c3f0:	10c00060 	cmpeqi	r3,r2,1
  46c3f4:	18004a1e 	bne	r3,zero,46c520 <OSFlagPost+0x29c>
  46c3f8:	10c00088 	cmpgei	r3,r2,2
  46c3fc:	1800021e 	bne	r3,zero,46c408 <OSFlagPost+0x184>
  46c400:	10002f26 	beq	r2,zero,46c4c0 <OSFlagPost+0x23c>
  46c404:	00005b06 	br	46c574 <OSFlagPost+0x2f0>
  46c408:	10c000a0 	cmpeqi	r3,r2,2
  46c40c:	1800031e 	bne	r3,zero,46c41c <OSFlagPost+0x198>
  46c410:	108000e0 	cmpeqi	r2,r2,3
  46c414:	1000171e 	bne	r2,zero,46c474 <OSFlagPost+0x1f0>
  46c418:	00005606 	br	46c574 <OSFlagPost+0x2f0>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
  46c41c:	e0bffc17 	ldw	r2,-16(fp)
  46c420:	10c0020b 	ldhu	r3,8(r2)
  46c424:	e0bfed17 	ldw	r2,-76(fp)
  46c428:	1080040b 	ldhu	r2,16(r2)
  46c42c:	1884703a 	and	r2,r3,r2
  46c430:	e0bff00d 	sth	r2,-64(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
  46c434:	e0bfed17 	ldw	r2,-76(fp)
  46c438:	1080040b 	ldhu	r2,16(r2)
  46c43c:	10ffffcc 	andi	r3,r2,65535
  46c440:	e0bff00b 	ldhu	r2,-64(fp)
  46c444:	18805f1e 	bne	r3,r2,46c5c4 <OSFlagPost+0x340>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
  46c448:	e0bff00b 	ldhu	r2,-64(fp)
  46c44c:	e13fed17 	ldw	r4,-76(fp)
  46c450:	100b883a 	mov	r5,r2
  46c454:	046ca5c0 	call	46ca5c <OS_FlagTaskRdy>
  46c458:	e0bff085 	stb	r2,-62(fp)
                     if (rdy == OS_TRUE) {
  46c45c:	e0bff083 	ldbu	r2,-62(fp)
  46c460:	10800058 	cmpnei	r2,r2,1
  46c464:	1000571e 	bne	r2,zero,46c5c4 <OSFlagPost+0x340>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
  46c468:	00800044 	movi	r2,1
  46c46c:	e0bfee05 	stb	r2,-72(fp)
                     }
                 }
                 break;
  46c470:	00005406 	br	46c5c4 <OSFlagPost+0x340>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
  46c474:	e0bffc17 	ldw	r2,-16(fp)
  46c478:	10c0020b 	ldhu	r3,8(r2)
  46c47c:	e0bfed17 	ldw	r2,-76(fp)
  46c480:	1080040b 	ldhu	r2,16(r2)
  46c484:	1884703a 	and	r2,r3,r2
  46c488:	e0bff00d 	sth	r2,-64(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
  46c48c:	e0bff00b 	ldhu	r2,-64(fp)
  46c490:	10004e26 	beq	r2,zero,46c5cc <OSFlagPost+0x348>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
  46c494:	e0bff00b 	ldhu	r2,-64(fp)
  46c498:	e13fed17 	ldw	r4,-76(fp)
  46c49c:	100b883a 	mov	r5,r2
  46c4a0:	046ca5c0 	call	46ca5c <OS_FlagTaskRdy>
  46c4a4:	e0bff085 	stb	r2,-62(fp)
                     if (rdy == OS_TRUE) {
  46c4a8:	e0bff083 	ldbu	r2,-62(fp)
  46c4ac:	10800058 	cmpnei	r2,r2,1
  46c4b0:	1000461e 	bne	r2,zero,46c5cc <OSFlagPost+0x348>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
  46c4b4:	00800044 	movi	r2,1
  46c4b8:	e0bfee05 	stb	r2,-72(fp)
                     }
                 }
                 break;
  46c4bc:	00004306 	br	46c5cc <OSFlagPost+0x348>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
  46c4c0:	e0bffc17 	ldw	r2,-16(fp)
  46c4c4:	1080020b 	ldhu	r2,8(r2)
  46c4c8:	0084303a 	nor	r2,zero,r2
  46c4cc:	1007883a 	mov	r3,r2
  46c4d0:	e0bfed17 	ldw	r2,-76(fp)
  46c4d4:	1080040b 	ldhu	r2,16(r2)
  46c4d8:	1884703a 	and	r2,r3,r2
  46c4dc:	e0bff00d 	sth	r2,-64(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
  46c4e0:	e0bfed17 	ldw	r2,-76(fp)
  46c4e4:	1080040b 	ldhu	r2,16(r2)
  46c4e8:	10ffffcc 	andi	r3,r2,65535
  46c4ec:	e0bff00b 	ldhu	r2,-64(fp)
  46c4f0:	1880381e 	bne	r3,r2,46c5d4 <OSFlagPost+0x350>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
  46c4f4:	e0bff00b 	ldhu	r2,-64(fp)
  46c4f8:	e13fed17 	ldw	r4,-76(fp)
  46c4fc:	100b883a 	mov	r5,r2
  46c500:	046ca5c0 	call	46ca5c <OS_FlagTaskRdy>
  46c504:	e0bff085 	stb	r2,-62(fp)
                     if (rdy == OS_TRUE) {
  46c508:	e0bff083 	ldbu	r2,-62(fp)
  46c50c:	10800058 	cmpnei	r2,r2,1
  46c510:	1000301e 	bne	r2,zero,46c5d4 <OSFlagPost+0x350>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
  46c514:	00800044 	movi	r2,1
  46c518:	e0bfee05 	stb	r2,-72(fp)
                     }
                 }
                 break;
  46c51c:	00002d06 	br	46c5d4 <OSFlagPost+0x350>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
  46c520:	e0bffc17 	ldw	r2,-16(fp)
  46c524:	1080020b 	ldhu	r2,8(r2)
  46c528:	0084303a 	nor	r2,zero,r2
  46c52c:	1007883a 	mov	r3,r2
  46c530:	e0bfed17 	ldw	r2,-76(fp)
  46c534:	1080040b 	ldhu	r2,16(r2)
  46c538:	1884703a 	and	r2,r3,r2
  46c53c:	e0bff00d 	sth	r2,-64(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
  46c540:	e0bff00b 	ldhu	r2,-64(fp)
  46c544:	10002526 	beq	r2,zero,46c5dc <OSFlagPost+0x358>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
  46c548:	e0bff00b 	ldhu	r2,-64(fp)
  46c54c:	e13fed17 	ldw	r4,-76(fp)
  46c550:	100b883a 	mov	r5,r2
  46c554:	046ca5c0 	call	46ca5c <OS_FlagTaskRdy>
  46c558:	e0bff085 	stb	r2,-62(fp)
                     if (rdy == OS_TRUE) {
  46c55c:	e0bff083 	ldbu	r2,-62(fp)
  46c560:	10800058 	cmpnei	r2,r2,1
  46c564:	10001d1e 	bne	r2,zero,46c5dc <OSFlagPost+0x358>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
  46c568:	00800044 	movi	r2,1
  46c56c:	e0bfee05 	stb	r2,-72(fp)
                     }
                 }
                 break;
  46c570:	00001a06 	br	46c5dc <OSFlagPost+0x358>
  46c574:	e0bfef17 	ldw	r2,-68(fp)
  46c578:	e0bff515 	stw	r2,-44(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46c57c:	0005303a 	rdctl	r2,status
  46c580:	e0bff615 	stw	r2,-40(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46c584:	e0fff617 	ldw	r3,-40(fp)
  46c588:	00bfff84 	movi	r2,-2
  46c58c:	1884703a 	and	r2,r3,r2
  46c590:	e0bff615 	stw	r2,-40(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46c594:	e0bff517 	ldw	r2,-44(fp)
  46c598:	1080004c 	andi	r2,r2,1
  46c59c:	e0fff617 	ldw	r3,-40(fp)
  46c5a0:	1884b03a 	or	r2,r3,r2
  46c5a4:	e0bff615 	stw	r2,-40(fp)
  
  NIOS2_WRITE_STATUS (status);
  46c5a8:	e0bff617 	ldw	r2,-40(fp)
  46c5ac:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
  46c5b0:	e0bfff17 	ldw	r2,-4(fp)
  46c5b4:	00c01bc4 	movi	r3,111
  46c5b8:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
  46c5bc:	0005883a 	mov	r2,zero
  46c5c0:	00003c06 	br	46c6b4 <OSFlagPost+0x430>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
  46c5c4:	0001883a 	nop
  46c5c8:	00000506 	br	46c5e0 <OSFlagPost+0x35c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
  46c5cc:	0001883a 	nop
  46c5d0:	00000306 	br	46c5e0 <OSFlagPost+0x35c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
  46c5d4:	0001883a 	nop
  46c5d8:	00000106 	br	46c5e0 <OSFlagPost+0x35c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
  46c5dc:	0001883a 	nop
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
  46c5e0:	e0bfed17 	ldw	r2,-76(fp)
  46c5e4:	10800017 	ldw	r2,0(r2)
  46c5e8:	e0bfed15 	stw	r2,-76(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
  46c5ec:	e0bfed17 	ldw	r2,-76(fp)
  46c5f0:	103f7c1e 	bne	r2,zero,46c3e4 <OSFlagPost+0x160>
  46c5f4:	e0bfef17 	ldw	r2,-68(fp)
  46c5f8:	e0bff715 	stw	r2,-36(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46c5fc:	0005303a 	rdctl	r2,status
  46c600:	e0bff815 	stw	r2,-32(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46c604:	e0fff817 	ldw	r3,-32(fp)
  46c608:	00bfff84 	movi	r2,-2
  46c60c:	1884703a 	and	r2,r3,r2
  46c610:	e0bff815 	stw	r2,-32(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46c614:	e0bff717 	ldw	r2,-36(fp)
  46c618:	1080004c 	andi	r2,r2,1
  46c61c:	e0fff817 	ldw	r3,-32(fp)
  46c620:	1884b03a 	or	r2,r3,r2
  46c624:	e0bff815 	stw	r2,-32(fp)
  
  NIOS2_WRITE_STATUS (status);
  46c628:	e0bff817 	ldw	r2,-32(fp)
  46c62c:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
  46c630:	e0bfee03 	ldbu	r2,-72(fp)
  46c634:	10800058 	cmpnei	r2,r2,1
  46c638:	1000011e 	bne	r2,zero,46c640 <OSFlagPost+0x3bc>
        OS_Sched();
  46c63c:	046a4980 	call	46a498 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46c640:	0005303a 	rdctl	r2,status
  46c644:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46c648:	e0fff917 	ldw	r3,-28(fp)
  46c64c:	00bfff84 	movi	r2,-2
  46c650:	1884703a 	and	r2,r3,r2
  46c654:	1001703a 	wrctl	status,r2
  
  return context;
  46c658:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
  46c65c:	e0bfef15 	stw	r2,-68(fp)
    flags_cur = pgrp->OSFlagFlags;
  46c660:	e0bffc17 	ldw	r2,-16(fp)
  46c664:	1080020b 	ldhu	r2,8(r2)
  46c668:	e0bff10d 	sth	r2,-60(fp)
  46c66c:	e0bfef17 	ldw	r2,-68(fp)
  46c670:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46c674:	0005303a 	rdctl	r2,status
  46c678:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46c67c:	e0fffb17 	ldw	r3,-20(fp)
  46c680:	00bfff84 	movi	r2,-2
  46c684:	1884703a 	and	r2,r3,r2
  46c688:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46c68c:	e0bffa17 	ldw	r2,-24(fp)
  46c690:	1080004c 	andi	r2,r2,1
  46c694:	e0fffb17 	ldw	r3,-20(fp)
  46c698:	1884b03a 	or	r2,r3,r2
  46c69c:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
  46c6a0:	e0bffb17 	ldw	r2,-20(fp)
  46c6a4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
  46c6a8:	e0bfff17 	ldw	r2,-4(fp)
  46c6ac:	10000005 	stb	zero,0(r2)
    return (flags_cur);
  46c6b0:	e0bff10b 	ldhu	r2,-60(fp)
}
  46c6b4:	e037883a 	mov	sp,fp
  46c6b8:	dfc00117 	ldw	ra,4(sp)
  46c6bc:	df000017 	ldw	fp,0(sp)
  46c6c0:	dec00204 	addi	sp,sp,8
  46c6c4:	f800283a 	ret

0046c6c8 <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
  46c6c8:	defff804 	addi	sp,sp,-32
  46c6cc:	df000715 	stw	fp,28(sp)
  46c6d0:	df000704 	addi	fp,sp,28
  46c6d4:	e13ffe15 	stw	r4,-8(fp)
  46c6d8:	e17fff15 	stw	r5,-4(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
  46c6dc:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
  46c6e0:	e0bfff17 	ldw	r2,-4(fp)
  46c6e4:	1000021e 	bne	r2,zero,46c6f0 <OSFlagQuery+0x28>
        return ((OS_FLAGS)0);
  46c6e8:	0005883a 	mov	r2,zero
  46c6ec:	00002e06 	br	46c7a8 <OSFlagQuery+0xe0>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
  46c6f0:	e0bffe17 	ldw	r2,-8(fp)
  46c6f4:	1000051e 	bne	r2,zero,46c70c <OSFlagQuery+0x44>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
  46c6f8:	e0bfff17 	ldw	r2,-4(fp)
  46c6fc:	00c01b84 	movi	r3,110
  46c700:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
  46c704:	0005883a 	mov	r2,zero
  46c708:	00002706 	br	46c7a8 <OSFlagQuery+0xe0>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
  46c70c:	e0bffe17 	ldw	r2,-8(fp)
  46c710:	10800003 	ldbu	r2,0(r2)
  46c714:	10803fcc 	andi	r2,r2,255
  46c718:	10800160 	cmpeqi	r2,r2,5
  46c71c:	1000051e 	bne	r2,zero,46c734 <OSFlagQuery+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
  46c720:	e0bfff17 	ldw	r2,-4(fp)
  46c724:	00c00044 	movi	r3,1
  46c728:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
  46c72c:	0005883a 	mov	r2,zero
  46c730:	00001d06 	br	46c7a8 <OSFlagQuery+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46c734:	0005303a 	rdctl	r2,status
  46c738:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46c73c:	e0fffb17 	ldw	r3,-20(fp)
  46c740:	00bfff84 	movi	r2,-2
  46c744:	1884703a 	and	r2,r3,r2
  46c748:	1001703a 	wrctl	status,r2
  
  return context;
  46c74c:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
  46c750:	e0bff915 	stw	r2,-28(fp)
    flags = pgrp->OSFlagFlags;
  46c754:	e0bffe17 	ldw	r2,-8(fp)
  46c758:	1080020b 	ldhu	r2,8(r2)
  46c75c:	e0bffa0d 	sth	r2,-24(fp)
  46c760:	e0bff917 	ldw	r2,-28(fp)
  46c764:	e0bffc15 	stw	r2,-16(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46c768:	0005303a 	rdctl	r2,status
  46c76c:	e0bffd15 	stw	r2,-12(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46c770:	e0fffd17 	ldw	r3,-12(fp)
  46c774:	00bfff84 	movi	r2,-2
  46c778:	1884703a 	and	r2,r3,r2
  46c77c:	e0bffd15 	stw	r2,-12(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46c780:	e0bffc17 	ldw	r2,-16(fp)
  46c784:	1080004c 	andi	r2,r2,1
  46c788:	e0fffd17 	ldw	r3,-12(fp)
  46c78c:	1884b03a 	or	r2,r3,r2
  46c790:	e0bffd15 	stw	r2,-12(fp)
  
  NIOS2_WRITE_STATUS (status);
  46c794:	e0bffd17 	ldw	r2,-12(fp)
  46c798:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
  46c79c:	e0bfff17 	ldw	r2,-4(fp)
  46c7a0:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
  46c7a4:	e0bffa0b 	ldhu	r2,-24(fp)
}
  46c7a8:	e037883a 	mov	sp,fp
  46c7ac:	df000017 	ldw	fp,0(sp)
  46c7b0:	dec00104 	addi	sp,sp,4
  46c7b4:	f800283a 	ret

0046c7b8 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
  46c7b8:	defff804 	addi	sp,sp,-32
  46c7bc:	df000715 	stw	fp,28(sp)
  46c7c0:	df000704 	addi	fp,sp,28
  46c7c4:	e13ffb15 	stw	r4,-20(fp)
  46c7c8:	e17ffc15 	stw	r5,-16(fp)
  46c7cc:	3007883a 	mov	r3,r6
  46c7d0:	3805883a 	mov	r2,r7
  46c7d4:	e1000117 	ldw	r4,4(fp)
  46c7d8:	e0fffd0d 	sth	r3,-12(fp)
  46c7dc:	e0bffe05 	stb	r2,-8(fp)
  46c7e0:	e13fff0d 	sth	r4,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
  46c7e4:	00801234 	movhi	r2,72
  46c7e8:	10a64d04 	addi	r2,r2,-26316
  46c7ec:	10800017 	ldw	r2,0(r2)
  46c7f0:	00c01234 	movhi	r3,72
  46c7f4:	18e64d04 	addi	r3,r3,-26316
  46c7f8:	18c00017 	ldw	r3,0(r3)
  46c7fc:	18c00c03 	ldbu	r3,48(r3)
  46c800:	18c00814 	ori	r3,r3,32
  46c804:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
  46c808:	00801234 	movhi	r2,72
  46c80c:	10a64d04 	addi	r2,r2,-26316
  46c810:	10800017 	ldw	r2,0(r2)
  46c814:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
  46c818:	00801234 	movhi	r2,72
  46c81c:	10a64d04 	addi	r2,r2,-26316
  46c820:	10800017 	ldw	r2,0(r2)
  46c824:	e0ffff0b 	ldhu	r3,-4(fp)
  46c828:	10c00b8d 	sth	r3,46(r2)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
  46c82c:	00801234 	movhi	r2,72
  46c830:	10a64d04 	addi	r2,r2,-26316
  46c834:	10800017 	ldw	r2,0(r2)
  46c838:	e0fffc17 	ldw	r3,-16(fp)
  46c83c:	10c00a15 	stw	r3,40(r2)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
  46c840:	e0bffc17 	ldw	r2,-16(fp)
  46c844:	e0fffd0b 	ldhu	r3,-12(fp)
  46c848:	10c0040d 	sth	r3,16(r2)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
  46c84c:	e0bffc17 	ldw	r2,-16(fp)
  46c850:	e0fffe03 	ldbu	r3,-8(fp)
  46c854:	10c00485 	stb	r3,18(r2)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
  46c858:	00801234 	movhi	r2,72
  46c85c:	10a64d04 	addi	r2,r2,-26316
  46c860:	10c00017 	ldw	r3,0(r2)
  46c864:	e0bffc17 	ldw	r2,-16(fp)
  46c868:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
  46c86c:	e0bffb17 	ldw	r2,-20(fp)
  46c870:	10c00117 	ldw	r3,4(r2)
  46c874:	e0bffc17 	ldw	r2,-16(fp)
  46c878:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
  46c87c:	e0bffc17 	ldw	r2,-16(fp)
  46c880:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
  46c884:	e0bffc17 	ldw	r2,-16(fp)
  46c888:	e0fffb17 	ldw	r3,-20(fp)
  46c88c:	10c00315 	stw	r3,12(r2)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
  46c890:	e0bffb17 	ldw	r2,-20(fp)
  46c894:	10800117 	ldw	r2,4(r2)
  46c898:	e0bff915 	stw	r2,-28(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
  46c89c:	e0bff917 	ldw	r2,-28(fp)
  46c8a0:	10000326 	beq	r2,zero,46c8b0 <OS_FlagBlock+0xf8>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
  46c8a4:	e0bff917 	ldw	r2,-28(fp)
  46c8a8:	e0fffc17 	ldw	r3,-16(fp)
  46c8ac:	10c00115 	stw	r3,4(r2)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
  46c8b0:	e0bffb17 	ldw	r2,-20(fp)
  46c8b4:	e0fffc17 	ldw	r3,-16(fp)
  46c8b8:	10c00115 	stw	r3,4(r2)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
  46c8bc:	00801234 	movhi	r2,72
  46c8c0:	10a64d04 	addi	r2,r2,-26316
  46c8c4:	10800017 	ldw	r2,0(r2)
  46c8c8:	10800d03 	ldbu	r2,52(r2)
  46c8cc:	e0bffa05 	stb	r2,-24(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
  46c8d0:	e0bffa03 	ldbu	r2,-24(fp)
  46c8d4:	e0fffa03 	ldbu	r3,-24(fp)
  46c8d8:	01001234 	movhi	r4,72
  46c8dc:	21264a44 	addi	r4,r4,-26327
  46c8e0:	20c7883a 	add	r3,r4,r3
  46c8e4:	18c00003 	ldbu	r3,0(r3)
  46c8e8:	1809883a 	mov	r4,r3
  46c8ec:	00c01234 	movhi	r3,72
  46c8f0:	18e64d04 	addi	r3,r3,-26316
  46c8f4:	18c00017 	ldw	r3,0(r3)
  46c8f8:	18c00d43 	ldbu	r3,53(r3)
  46c8fc:	00c6303a 	nor	r3,zero,r3
  46c900:	20c6703a 	and	r3,r4,r3
  46c904:	01001234 	movhi	r4,72
  46c908:	21264a44 	addi	r4,r4,-26327
  46c90c:	2085883a 	add	r2,r4,r2
  46c910:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0x00) {
  46c914:	e0bffa03 	ldbu	r2,-24(fp)
  46c918:	00c01234 	movhi	r3,72
  46c91c:	18e64a44 	addi	r3,r3,-26327
  46c920:	1885883a 	add	r2,r3,r2
  46c924:	10800003 	ldbu	r2,0(r2)
  46c928:	10803fcc 	andi	r2,r2,255
  46c92c:	10000e1e 	bne	r2,zero,46c968 <OS_FlagBlock+0x1b0>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
  46c930:	00801234 	movhi	r2,72
  46c934:	10a64d04 	addi	r2,r2,-26316
  46c938:	10800017 	ldw	r2,0(r2)
  46c93c:	10800d83 	ldbu	r2,54(r2)
  46c940:	0084303a 	nor	r2,zero,r2
  46c944:	1007883a 	mov	r3,r2
  46c948:	00801234 	movhi	r2,72
  46c94c:	10a64a04 	addi	r2,r2,-26328
  46c950:	10800003 	ldbu	r2,0(r2)
  46c954:	1884703a 	and	r2,r3,r2
  46c958:	1007883a 	mov	r3,r2
  46c95c:	00801234 	movhi	r2,72
  46c960:	10a64a04 	addi	r2,r2,-26328
  46c964:	10c00005 	stb	r3,0(r2)
    }
}
  46c968:	e037883a 	mov	sp,fp
  46c96c:	df000017 	ldw	fp,0(sp)
  46c970:	dec00104 	addi	sp,sp,4
  46c974:	f800283a 	ret

0046c978 <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
  46c978:	defffb04 	addi	sp,sp,-20
  46c97c:	dfc00415 	stw	ra,16(sp)
  46c980:	df000315 	stw	fp,12(sp)
  46c984:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
  46c988:	01001234 	movhi	r4,72
  46c98c:	2126a004 	addi	r4,r4,-25984
  46c990:	0140dc04 	movi	r5,880
  46c994:	046a3d80 	call	46a3d8 <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
  46c998:	00801234 	movhi	r2,72
  46c99c:	10a6a004 	addi	r2,r2,-25984
  46c9a0:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
  46c9a4:	00801234 	movhi	r2,72
  46c9a8:	10a6ab04 	addi	r2,r2,-25940
  46c9ac:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
  46c9b0:	e03ffd0d 	sth	zero,-12(fp)
  46c9b4:	00001306 	br	46ca04 <OS_FlagInit+0x8c>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
  46c9b8:	e0bffe17 	ldw	r2,-8(fp)
  46c9bc:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
  46c9c0:	e0bffe17 	ldw	r2,-8(fp)
  46c9c4:	e0ffff17 	ldw	r3,-4(fp)
  46c9c8:	10c00115 	stw	r3,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
  46c9cc:	e0bffe17 	ldw	r2,-8(fp)
  46c9d0:	00c00fc4 	movi	r3,63
  46c9d4:	10c00285 	stb	r3,10(r2)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
  46c9d8:	e0bffe17 	ldw	r2,-8(fp)
  46c9dc:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
  46c9e0:	e0bffe17 	ldw	r2,-8(fp)
  46c9e4:	10800b04 	addi	r2,r2,44
  46c9e8:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
  46c9ec:	e0bfff17 	ldw	r2,-4(fp)
  46c9f0:	10800b04 	addi	r2,r2,44
  46c9f4:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
  46c9f8:	e0bffd0b 	ldhu	r2,-12(fp)
  46c9fc:	10800044 	addi	r2,r2,1
  46ca00:	e0bffd0d 	sth	r2,-12(fp)
  46ca04:	e0bffd0b 	ldhu	r2,-12(fp)
  46ca08:	108004f0 	cmpltui	r2,r2,19
  46ca0c:	103fea1e 	bne	r2,zero,46c9b8 <OS_FlagInit+0x40>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
  46ca10:	e0bffe17 	ldw	r2,-8(fp)
  46ca14:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
  46ca18:	e0bffe17 	ldw	r2,-8(fp)
  46ca1c:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
  46ca20:	e0bffe17 	ldw	r2,-8(fp)
  46ca24:	00c00fc4 	movi	r3,63
  46ca28:	10c00285 	stb	r3,10(r2)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
  46ca2c:	e0bffe17 	ldw	r2,-8(fp)
  46ca30:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
  46ca34:	00801234 	movhi	r2,72
  46ca38:	10a64f04 	addi	r2,r2,-26308
  46ca3c:	00c01234 	movhi	r3,72
  46ca40:	18e6a004 	addi	r3,r3,-25984
  46ca44:	10c00015 	stw	r3,0(r2)
#endif
}
  46ca48:	e037883a 	mov	sp,fp
  46ca4c:	dfc00117 	ldw	ra,4(sp)
  46ca50:	df000017 	ldw	fp,0(sp)
  46ca54:	dec00204 	addi	sp,sp,8
  46ca58:	f800283a 	ret

0046ca5c <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
  46ca5c:	defffa04 	addi	sp,sp,-24
  46ca60:	dfc00515 	stw	ra,20(sp)
  46ca64:	df000415 	stw	fp,16(sp)
  46ca68:	df000404 	addi	fp,sp,16
  46ca6c:	e13ffe15 	stw	r4,-8(fp)
  46ca70:	2805883a 	mov	r2,r5
  46ca74:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
  46ca78:	e0bffe17 	ldw	r2,-8(fp)
  46ca7c:	10800217 	ldw	r2,8(r2)
  46ca80:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
  46ca84:	e0bffd17 	ldw	r2,-12(fp)
  46ca88:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
  46ca8c:	e0bffd17 	ldw	r2,-12(fp)
  46ca90:	e0ffff0b 	ldhu	r3,-4(fp)
  46ca94:	10c00b0d 	sth	r3,44(r2)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
  46ca98:	e0bffd17 	ldw	r2,-12(fp)
  46ca9c:	10c00c03 	ldbu	r3,48(r2)
  46caa0:	00bff7c4 	movi	r2,-33
  46caa4:	1884703a 	and	r2,r3,r2
  46caa8:	1007883a 	mov	r3,r2
  46caac:	e0bffd17 	ldw	r2,-12(fp)
  46cab0:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
  46cab4:	e0bffd17 	ldw	r2,-12(fp)
  46cab8:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
  46cabc:	e0bffd17 	ldw	r2,-12(fp)
  46cac0:	10800c03 	ldbu	r2,48(r2)
  46cac4:	10803fcc 	andi	r2,r2,255
  46cac8:	10001e1e 	bne	r2,zero,46cb44 <OS_FlagTaskRdy+0xe8>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
  46cacc:	e0bffd17 	ldw	r2,-12(fp)
  46cad0:	10c00d83 	ldbu	r3,54(r2)
  46cad4:	00801234 	movhi	r2,72
  46cad8:	10a64a04 	addi	r2,r2,-26328
  46cadc:	10800003 	ldbu	r2,0(r2)
  46cae0:	1884b03a 	or	r2,r3,r2
  46cae4:	1007883a 	mov	r3,r2
  46cae8:	00801234 	movhi	r2,72
  46caec:	10a64a04 	addi	r2,r2,-26328
  46caf0:	10c00005 	stb	r3,0(r2)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
  46caf4:	e0bffd17 	ldw	r2,-12(fp)
  46caf8:	10800d03 	ldbu	r2,52(r2)
  46cafc:	10803fcc 	andi	r2,r2,255
  46cb00:	e0fffd17 	ldw	r3,-12(fp)
  46cb04:	18c00d03 	ldbu	r3,52(r3)
  46cb08:	18c03fcc 	andi	r3,r3,255
  46cb0c:	01001234 	movhi	r4,72
  46cb10:	21264a44 	addi	r4,r4,-26327
  46cb14:	20c7883a 	add	r3,r4,r3
  46cb18:	19000003 	ldbu	r4,0(r3)
  46cb1c:	e0fffd17 	ldw	r3,-12(fp)
  46cb20:	18c00d43 	ldbu	r3,53(r3)
  46cb24:	20c6b03a 	or	r3,r4,r3
  46cb28:	01001234 	movhi	r4,72
  46cb2c:	21264a44 	addi	r4,r4,-26327
  46cb30:	2085883a 	add	r2,r4,r2
  46cb34:	10c00005 	stb	r3,0(r2)
        sched                   = OS_TRUE;
  46cb38:	00800044 	movi	r2,1
  46cb3c:	e0bffc05 	stb	r2,-16(fp)
  46cb40:	00000106 	br	46cb48 <OS_FlagTaskRdy+0xec>
    } else {
        sched                   = OS_FALSE;
  46cb44:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
  46cb48:	e13ffe17 	ldw	r4,-8(fp)
  46cb4c:	046cb680 	call	46cb68 <OS_FlagUnlink>
    return (sched);
  46cb50:	e0bffc03 	ldbu	r2,-16(fp)
}
  46cb54:	e037883a 	mov	sp,fp
  46cb58:	dfc00117 	ldw	ra,4(sp)
  46cb5c:	df000017 	ldw	fp,0(sp)
  46cb60:	dec00204 	addi	sp,sp,8
  46cb64:	f800283a 	ret

0046cb68 <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
  46cb68:	defffa04 	addi	sp,sp,-24
  46cb6c:	df000515 	stw	fp,20(sp)
  46cb70:	df000504 	addi	fp,sp,20
  46cb74:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
  46cb78:	e0bfff17 	ldw	r2,-4(fp)
  46cb7c:	10800117 	ldw	r2,4(r2)
  46cb80:	e0bffb15 	stw	r2,-20(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
  46cb84:	e0bfff17 	ldw	r2,-4(fp)
  46cb88:	10800017 	ldw	r2,0(r2)
  46cb8c:	e0bffc15 	stw	r2,-16(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
  46cb90:	e0bffb17 	ldw	r2,-20(fp)
  46cb94:	10000b1e 	bne	r2,zero,46cbc4 <OS_FlagUnlink+0x5c>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
  46cb98:	e0bfff17 	ldw	r2,-4(fp)
  46cb9c:	10800317 	ldw	r2,12(r2)
  46cba0:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
  46cba4:	e0bffd17 	ldw	r2,-12(fp)
  46cba8:	e0fffc17 	ldw	r3,-16(fp)
  46cbac:	10c00115 	stw	r3,4(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {
  46cbb0:	e0bffc17 	ldw	r2,-16(fp)
  46cbb4:	10000b26 	beq	r2,zero,46cbe4 <OS_FlagUnlink+0x7c>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
  46cbb8:	e0bffc17 	ldw	r2,-16(fp)
  46cbbc:	10000115 	stw	zero,4(r2)
  46cbc0:	00000806 	br	46cbe4 <OS_FlagUnlink+0x7c>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
  46cbc4:	e0bffb17 	ldw	r2,-20(fp)
  46cbc8:	e0fffc17 	ldw	r3,-16(fp)
  46cbcc:	10c00015 	stw	r3,0(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
  46cbd0:	e0bffc17 	ldw	r2,-16(fp)
  46cbd4:	10000326 	beq	r2,zero,46cbe4 <OS_FlagUnlink+0x7c>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
  46cbd8:	e0bffc17 	ldw	r2,-16(fp)
  46cbdc:	e0fffb17 	ldw	r3,-20(fp)
  46cbe0:	10c00115 	stw	r3,4(r2)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
  46cbe4:	e0bfff17 	ldw	r2,-4(fp)
  46cbe8:	10800217 	ldw	r2,8(r2)
  46cbec:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
  46cbf0:	e0bffe17 	ldw	r2,-8(fp)
  46cbf4:	10000a15 	stw	zero,40(r2)
#endif
}
  46cbf8:	e037883a 	mov	sp,fp
  46cbfc:	df000017 	ldw	fp,0(sp)
  46cc00:	dec00104 	addi	sp,sp,4
  46cc04:	f800283a 	ret

0046cc08 <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
  46cc08:	defff304 	addi	sp,sp,-52
  46cc0c:	df000c15 	stw	fp,48(sp)
  46cc10:	df000c04 	addi	fp,sp,48
  46cc14:	e13ffc15 	stw	r4,-16(fp)
  46cc18:	e17ffd15 	stw	r5,-12(fp)
  46cc1c:	e1bffe15 	stw	r6,-8(fp)
  46cc20:	e1ffff15 	stw	r7,-4(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
  46cc24:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
  46cc28:	e0bfff17 	ldw	r2,-4(fp)
  46cc2c:	1000021e 	bne	r2,zero,46cc38 <OSMemCreate+0x30>
        return ((OS_MEM *)0);
  46cc30:	0005883a 	mov	r2,zero
  46cc34:	00007806 	br	46ce18 <OSMemCreate+0x210>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
  46cc38:	e0bffc17 	ldw	r2,-16(fp)
  46cc3c:	1000051e 	bne	r2,zero,46cc54 <OSMemCreate+0x4c>
        *perr = OS_ERR_MEM_INVALID_ADDR;
  46cc40:	e0bfff17 	ldw	r2,-4(fp)
  46cc44:	00c01884 	movi	r3,98
  46cc48:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
  46cc4c:	0005883a 	mov	r2,zero
  46cc50:	00007106 	br	46ce18 <OSMemCreate+0x210>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
  46cc54:	e0bffc17 	ldw	r2,-16(fp)
  46cc58:	108000cc 	andi	r2,r2,3
  46cc5c:	10000526 	beq	r2,zero,46cc74 <OSMemCreate+0x6c>
        *perr = OS_ERR_MEM_INVALID_ADDR;
  46cc60:	e0bfff17 	ldw	r2,-4(fp)
  46cc64:	00c01884 	movi	r3,98
  46cc68:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
  46cc6c:	0005883a 	mov	r2,zero
  46cc70:	00006906 	br	46ce18 <OSMemCreate+0x210>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
  46cc74:	e0bffd17 	ldw	r2,-12(fp)
  46cc78:	108000a8 	cmpgeui	r2,r2,2
  46cc7c:	1000051e 	bne	r2,zero,46cc94 <OSMemCreate+0x8c>
        *perr = OS_ERR_MEM_INVALID_BLKS;
  46cc80:	e0bfff17 	ldw	r2,-4(fp)
  46cc84:	00c016c4 	movi	r3,91
  46cc88:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
  46cc8c:	0005883a 	mov	r2,zero
  46cc90:	00006106 	br	46ce18 <OSMemCreate+0x210>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
  46cc94:	e0bffe17 	ldw	r2,-8(fp)
  46cc98:	10800128 	cmpgeui	r2,r2,4
  46cc9c:	1000051e 	bne	r2,zero,46ccb4 <OSMemCreate+0xac>
        *perr = OS_ERR_MEM_INVALID_SIZE;
  46cca0:	e0bfff17 	ldw	r2,-4(fp)
  46cca4:	00c01704 	movi	r3,92
  46cca8:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
  46ccac:	0005883a 	mov	r2,zero
  46ccb0:	00005906 	br	46ce18 <OSMemCreate+0x210>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46ccb4:	0005303a 	rdctl	r2,status
  46ccb8:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46ccbc:	e0fff917 	ldw	r3,-28(fp)
  46ccc0:	00bfff84 	movi	r2,-2
  46ccc4:	1884703a 	and	r2,r3,r2
  46ccc8:	1001703a 	wrctl	status,r2
  
  return context;
  46cccc:	e0bff917 	ldw	r2,-28(fp)
    }
#endif
    OS_ENTER_CRITICAL();
  46ccd0:	e0bff715 	stw	r2,-36(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
  46ccd4:	00801234 	movhi	r2,72
  46ccd8:	10a64704 	addi	r2,r2,-26340
  46ccdc:	10800017 	ldw	r2,0(r2)
  46cce0:	e0bff815 	stw	r2,-32(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
  46cce4:	00801234 	movhi	r2,72
  46cce8:	10a64704 	addi	r2,r2,-26340
  46ccec:	10800017 	ldw	r2,0(r2)
  46ccf0:	10000726 	beq	r2,zero,46cd10 <OSMemCreate+0x108>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
  46ccf4:	00801234 	movhi	r2,72
  46ccf8:	10a64704 	addi	r2,r2,-26340
  46ccfc:	10800017 	ldw	r2,0(r2)
  46cd00:	10c00117 	ldw	r3,4(r2)
  46cd04:	00801234 	movhi	r2,72
  46cd08:	10a64704 	addi	r2,r2,-26340
  46cd0c:	10c00015 	stw	r3,0(r2)
  46cd10:	e0bff717 	ldw	r2,-36(fp)
  46cd14:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46cd18:	0005303a 	rdctl	r2,status
  46cd1c:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46cd20:	e0fffb17 	ldw	r3,-20(fp)
  46cd24:	00bfff84 	movi	r2,-2
  46cd28:	1884703a 	and	r2,r3,r2
  46cd2c:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46cd30:	e0bffa17 	ldw	r2,-24(fp)
  46cd34:	1080004c 	andi	r2,r2,1
  46cd38:	e0fffb17 	ldw	r3,-20(fp)
  46cd3c:	1884b03a 	or	r2,r3,r2
  46cd40:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
  46cd44:	e0bffb17 	ldw	r2,-20(fp)
  46cd48:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
  46cd4c:	e0bff817 	ldw	r2,-32(fp)
  46cd50:	1000051e 	bne	r2,zero,46cd68 <OSMemCreate+0x160>
        *perr = OS_ERR_MEM_INVALID_PART;
  46cd54:	e0bfff17 	ldw	r2,-4(fp)
  46cd58:	00c01684 	movi	r3,90
  46cd5c:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
  46cd60:	0005883a 	mov	r2,zero
  46cd64:	00002c06 	br	46ce18 <OSMemCreate+0x210>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
  46cd68:	e0bffc17 	ldw	r2,-16(fp)
  46cd6c:	e0bff515 	stw	r2,-44(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
  46cd70:	e0fffc17 	ldw	r3,-16(fp)
  46cd74:	e0bffe17 	ldw	r2,-8(fp)
  46cd78:	1885883a 	add	r2,r3,r2
  46cd7c:	e0bff415 	stw	r2,-48(fp)
    for (i = 0; i < (nblks - 1); i++) {
  46cd80:	e03ff615 	stw	zero,-40(fp)
  46cd84:	00000c06 	br	46cdb8 <OSMemCreate+0x1b0>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
  46cd88:	e0bff517 	ldw	r2,-44(fp)
  46cd8c:	e0fff417 	ldw	r3,-48(fp)
  46cd90:	10c00015 	stw	r3,0(r2)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
  46cd94:	e0bff417 	ldw	r2,-48(fp)
  46cd98:	e0bff515 	stw	r2,-44(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
  46cd9c:	e0fff417 	ldw	r3,-48(fp)
  46cda0:	e0bffe17 	ldw	r2,-8(fp)
  46cda4:	1885883a 	add	r2,r3,r2
  46cda8:	e0bff415 	stw	r2,-48(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
  46cdac:	e0bff617 	ldw	r2,-40(fp)
  46cdb0:	10800044 	addi	r2,r2,1
  46cdb4:	e0bff615 	stw	r2,-40(fp)
  46cdb8:	e0bffd17 	ldw	r2,-12(fp)
  46cdbc:	10bfffc4 	addi	r2,r2,-1
  46cdc0:	e0fff617 	ldw	r3,-40(fp)
  46cdc4:	18bff036 	bltu	r3,r2,46cd88 <OSMemCreate+0x180>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
  46cdc8:	e0bff517 	ldw	r2,-44(fp)
  46cdcc:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
  46cdd0:	e0bff817 	ldw	r2,-32(fp)
  46cdd4:	e0fffc17 	ldw	r3,-16(fp)
  46cdd8:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
  46cddc:	e0bff817 	ldw	r2,-32(fp)
  46cde0:	e0fffc17 	ldw	r3,-16(fp)
  46cde4:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
  46cde8:	e0bff817 	ldw	r2,-32(fp)
  46cdec:	e0fffd17 	ldw	r3,-12(fp)
  46cdf0:	10c00415 	stw	r3,16(r2)
    pmem->OSMemNBlks    = nblks;
  46cdf4:	e0bff817 	ldw	r2,-32(fp)
  46cdf8:	e0fffd17 	ldw	r3,-12(fp)
  46cdfc:	10c00315 	stw	r3,12(r2)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
  46ce00:	e0bff817 	ldw	r2,-32(fp)
  46ce04:	e0fffe17 	ldw	r3,-8(fp)
  46ce08:	10c00215 	stw	r3,8(r2)
    *perr               = OS_ERR_NONE;
  46ce0c:	e0bfff17 	ldw	r2,-4(fp)
  46ce10:	10000005 	stb	zero,0(r2)
    return (pmem);
  46ce14:	e0bff817 	ldw	r2,-32(fp)
}
  46ce18:	e037883a 	mov	sp,fp
  46ce1c:	df000017 	ldw	fp,0(sp)
  46ce20:	dec00104 	addi	sp,sp,4
  46ce24:	f800283a 	ret

0046ce28 <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
  46ce28:	defff604 	addi	sp,sp,-40
  46ce2c:	df000915 	stw	fp,36(sp)
  46ce30:	df000904 	addi	fp,sp,36
  46ce34:	e13ffe15 	stw	r4,-8(fp)
  46ce38:	e17fff15 	stw	r5,-4(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
  46ce3c:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
  46ce40:	e0bfff17 	ldw	r2,-4(fp)
  46ce44:	1000021e 	bne	r2,zero,46ce50 <OSMemGet+0x28>
        return ((void *)0);
  46ce48:	0005883a 	mov	r2,zero
  46ce4c:	00004406 	br	46cf60 <OSMemGet+0x138>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
  46ce50:	e0bffe17 	ldw	r2,-8(fp)
  46ce54:	1000051e 	bne	r2,zero,46ce6c <OSMemGet+0x44>
        *perr = OS_ERR_MEM_INVALID_PMEM;
  46ce58:	e0bfff17 	ldw	r2,-4(fp)
  46ce5c:	00c01804 	movi	r3,96
  46ce60:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
  46ce64:	0005883a 	mov	r2,zero
  46ce68:	00003d06 	br	46cf60 <OSMemGet+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46ce6c:	0005303a 	rdctl	r2,status
  46ce70:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46ce74:	e0fff917 	ldw	r3,-28(fp)
  46ce78:	00bfff84 	movi	r2,-2
  46ce7c:	1884703a 	and	r2,r3,r2
  46ce80:	1001703a 	wrctl	status,r2
  
  return context;
  46ce84:	e0bff917 	ldw	r2,-28(fp)
    }
#endif
    OS_ENTER_CRITICAL();
  46ce88:	e0bff715 	stw	r2,-36(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
  46ce8c:	e0bffe17 	ldw	r2,-8(fp)
  46ce90:	10800417 	ldw	r2,16(r2)
  46ce94:	10001f26 	beq	r2,zero,46cf14 <OSMemGet+0xec>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
  46ce98:	e0bffe17 	ldw	r2,-8(fp)
  46ce9c:	10800117 	ldw	r2,4(r2)
  46cea0:	e0bff815 	stw	r2,-32(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
  46cea4:	e0bff817 	ldw	r2,-32(fp)
  46cea8:	10c00017 	ldw	r3,0(r2)
  46ceac:	e0bffe17 	ldw	r2,-8(fp)
  46ceb0:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
  46ceb4:	e0bffe17 	ldw	r2,-8(fp)
  46ceb8:	10800417 	ldw	r2,16(r2)
  46cebc:	10ffffc4 	addi	r3,r2,-1
  46cec0:	e0bffe17 	ldw	r2,-8(fp)
  46cec4:	10c00415 	stw	r3,16(r2)
  46cec8:	e0bff717 	ldw	r2,-36(fp)
  46cecc:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46ced0:	0005303a 	rdctl	r2,status
  46ced4:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46ced8:	e0fffb17 	ldw	r3,-20(fp)
  46cedc:	00bfff84 	movi	r2,-2
  46cee0:	1884703a 	and	r2,r3,r2
  46cee4:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46cee8:	e0bffa17 	ldw	r2,-24(fp)
  46ceec:	1080004c 	andi	r2,r2,1
  46cef0:	e0fffb17 	ldw	r3,-20(fp)
  46cef4:	1884b03a 	or	r2,r3,r2
  46cef8:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
  46cefc:	e0bffb17 	ldw	r2,-20(fp)
  46cf00:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
  46cf04:	e0bfff17 	ldw	r2,-4(fp)
  46cf08:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
  46cf0c:	e0bff817 	ldw	r2,-32(fp)
  46cf10:	00001306 	br	46cf60 <OSMemGet+0x138>
  46cf14:	e0bff717 	ldw	r2,-36(fp)
  46cf18:	e0bffc15 	stw	r2,-16(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46cf1c:	0005303a 	rdctl	r2,status
  46cf20:	e0bffd15 	stw	r2,-12(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46cf24:	e0fffd17 	ldw	r3,-12(fp)
  46cf28:	00bfff84 	movi	r2,-2
  46cf2c:	1884703a 	and	r2,r3,r2
  46cf30:	e0bffd15 	stw	r2,-12(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46cf34:	e0bffc17 	ldw	r2,-16(fp)
  46cf38:	1080004c 	andi	r2,r2,1
  46cf3c:	e0fffd17 	ldw	r3,-12(fp)
  46cf40:	1884b03a 	or	r2,r3,r2
  46cf44:	e0bffd15 	stw	r2,-12(fp)
  
  NIOS2_WRITE_STATUS (status);
  46cf48:	e0bffd17 	ldw	r2,-12(fp)
  46cf4c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
  46cf50:	e0bfff17 	ldw	r2,-4(fp)
  46cf54:	00c01744 	movi	r3,93
  46cf58:	10c00005 	stb	r3,0(r2)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
  46cf5c:	0005883a 	mov	r2,zero
}
  46cf60:	e037883a 	mov	sp,fp
  46cf64:	df000017 	ldw	fp,0(sp)
  46cf68:	dec00104 	addi	sp,sp,4
  46cf6c:	f800283a 	ret

0046cf70 <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
  46cf70:	defff604 	addi	sp,sp,-40
  46cf74:	dfc00915 	stw	ra,36(sp)
  46cf78:	df000815 	stw	fp,32(sp)
  46cf7c:	df000804 	addi	fp,sp,32
  46cf80:	e13ffd15 	stw	r4,-12(fp)
  46cf84:	e17ffe15 	stw	r5,-8(fp)
  46cf88:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
  46cf8c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
  46cf90:	e0bfff17 	ldw	r2,-4(fp)
  46cf94:	1000021e 	bne	r2,zero,46cfa0 <OSMemNameGet+0x30>
        return (0);
  46cf98:	0005883a 	mov	r2,zero
  46cf9c:	00003806 	br	46d080 <OSMemNameGet+0x110>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
  46cfa0:	e0bffd17 	ldw	r2,-12(fp)
  46cfa4:	1000051e 	bne	r2,zero,46cfbc <OSMemNameGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
  46cfa8:	e0bfff17 	ldw	r2,-4(fp)
  46cfac:	00c01804 	movi	r3,96
  46cfb0:	10c00005 	stb	r3,0(r2)
        return (0);
  46cfb4:	0005883a 	mov	r2,zero
  46cfb8:	00003106 	br	46d080 <OSMemNameGet+0x110>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
  46cfbc:	e0bffe17 	ldw	r2,-8(fp)
  46cfc0:	1000051e 	bne	r2,zero,46cfd8 <OSMemNameGet+0x68>
        *perr = OS_ERR_PNAME_NULL;
  46cfc4:	e0bfff17 	ldw	r2,-4(fp)
  46cfc8:	00c00304 	movi	r3,12
  46cfcc:	10c00005 	stb	r3,0(r2)
        return (0);
  46cfd0:	0005883a 	mov	r2,zero
  46cfd4:	00002a06 	br	46d080 <OSMemNameGet+0x110>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
  46cfd8:	00801234 	movhi	r2,72
  46cfdc:	10a64c04 	addi	r2,r2,-26320
  46cfe0:	10800003 	ldbu	r2,0(r2)
  46cfe4:	10803fcc 	andi	r2,r2,255
  46cfe8:	10000526 	beq	r2,zero,46d000 <OSMemNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
  46cfec:	e0bfff17 	ldw	r2,-4(fp)
  46cff0:	00c00444 	movi	r3,17
  46cff4:	10c00005 	stb	r3,0(r2)
        return (0);
  46cff8:	0005883a 	mov	r2,zero
  46cffc:	00002006 	br	46d080 <OSMemNameGet+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46d000:	0005303a 	rdctl	r2,status
  46d004:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46d008:	e0fffa17 	ldw	r3,-24(fp)
  46d00c:	00bfff84 	movi	r2,-2
  46d010:	1884703a 	and	r2,r3,r2
  46d014:	1001703a 	wrctl	status,r2
  
  return context;
  46d018:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
  46d01c:	e0bff815 	stw	r2,-32(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
  46d020:	e0bffd17 	ldw	r2,-12(fp)
  46d024:	10800504 	addi	r2,r2,20
  46d028:	e13ffe17 	ldw	r4,-8(fp)
  46d02c:	100b883a 	mov	r5,r2
  46d030:	046a6000 	call	46a600 <OS_StrCopy>
  46d034:	e0bff905 	stb	r2,-28(fp)
  46d038:	e0bff817 	ldw	r2,-32(fp)
  46d03c:	e0bffb15 	stw	r2,-20(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46d040:	0005303a 	rdctl	r2,status
  46d044:	e0bffc15 	stw	r2,-16(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46d048:	e0fffc17 	ldw	r3,-16(fp)
  46d04c:	00bfff84 	movi	r2,-2
  46d050:	1884703a 	and	r2,r3,r2
  46d054:	e0bffc15 	stw	r2,-16(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46d058:	e0bffb17 	ldw	r2,-20(fp)
  46d05c:	1080004c 	andi	r2,r2,1
  46d060:	e0fffc17 	ldw	r3,-16(fp)
  46d064:	1884b03a 	or	r2,r3,r2
  46d068:	e0bffc15 	stw	r2,-16(fp)
  
  NIOS2_WRITE_STATUS (status);
  46d06c:	e0bffc17 	ldw	r2,-16(fp)
  46d070:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
  46d074:	e0bfff17 	ldw	r2,-4(fp)
  46d078:	10000005 	stb	zero,0(r2)
    return (len);
  46d07c:	e0bff903 	ldbu	r2,-28(fp)
}
  46d080:	e037883a 	mov	sp,fp
  46d084:	dfc00117 	ldw	ra,4(sp)
  46d088:	df000017 	ldw	fp,0(sp)
  46d08c:	dec00204 	addi	sp,sp,8
  46d090:	f800283a 	ret

0046d094 <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
  46d094:	defff404 	addi	sp,sp,-48
  46d098:	dfc00b15 	stw	ra,44(sp)
  46d09c:	df000a15 	stw	fp,40(sp)
  46d0a0:	df000a04 	addi	fp,sp,40
  46d0a4:	e13ffd15 	stw	r4,-12(fp)
  46d0a8:	e17ffe15 	stw	r5,-8(fp)
  46d0ac:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
  46d0b0:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
  46d0b4:	e0bfff17 	ldw	r2,-4(fp)
  46d0b8:	10004d26 	beq	r2,zero,46d1f0 <OSMemNameSet+0x15c>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
  46d0bc:	e0bffd17 	ldw	r2,-12(fp)
  46d0c0:	1000041e 	bne	r2,zero,46d0d4 <OSMemNameSet+0x40>
        *perr = OS_ERR_MEM_INVALID_PMEM;
  46d0c4:	e0bfff17 	ldw	r2,-4(fp)
  46d0c8:	00c01804 	movi	r3,96
  46d0cc:	10c00005 	stb	r3,0(r2)
        return;
  46d0d0:	00004806 	br	46d1f4 <OSMemNameSet+0x160>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
  46d0d4:	e0bffe17 	ldw	r2,-8(fp)
  46d0d8:	1000041e 	bne	r2,zero,46d0ec <OSMemNameSet+0x58>
        *perr = OS_ERR_PNAME_NULL;
  46d0dc:	e0bfff17 	ldw	r2,-4(fp)
  46d0e0:	00c00304 	movi	r3,12
  46d0e4:	10c00005 	stb	r3,0(r2)
        return;
  46d0e8:	00004206 	br	46d1f4 <OSMemNameSet+0x160>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
  46d0ec:	00801234 	movhi	r2,72
  46d0f0:	10a64c04 	addi	r2,r2,-26320
  46d0f4:	10800003 	ldbu	r2,0(r2)
  46d0f8:	10803fcc 	andi	r2,r2,255
  46d0fc:	10000426 	beq	r2,zero,46d110 <OSMemNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
  46d100:	e0bfff17 	ldw	r2,-4(fp)
  46d104:	00c00484 	movi	r3,18
  46d108:	10c00005 	stb	r3,0(r2)
        return;
  46d10c:	00003906 	br	46d1f4 <OSMemNameSet+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46d110:	0005303a 	rdctl	r2,status
  46d114:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46d118:	e0fff817 	ldw	r3,-32(fp)
  46d11c:	00bfff84 	movi	r2,-2
  46d120:	1884703a 	and	r2,r3,r2
  46d124:	1001703a 	wrctl	status,r2
  
  return context;
  46d128:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
  46d12c:	e0bff615 	stw	r2,-40(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
  46d130:	e13ffe17 	ldw	r4,-8(fp)
  46d134:	046a67c0 	call	46a67c <OS_StrLen>
  46d138:	e0bff705 	stb	r2,-36(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
  46d13c:	e0bff703 	ldbu	r2,-36(fp)
  46d140:	10800830 	cmpltui	r2,r2,32
  46d144:	1000131e 	bne	r2,zero,46d194 <OSMemNameSet+0x100>
  46d148:	e0bff617 	ldw	r2,-40(fp)
  46d14c:	e0bff915 	stw	r2,-28(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46d150:	0005303a 	rdctl	r2,status
  46d154:	e0bffa15 	stw	r2,-24(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46d158:	e0fffa17 	ldw	r3,-24(fp)
  46d15c:	00bfff84 	movi	r2,-2
  46d160:	1884703a 	and	r2,r3,r2
  46d164:	e0bffa15 	stw	r2,-24(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46d168:	e0bff917 	ldw	r2,-28(fp)
  46d16c:	1080004c 	andi	r2,r2,1
  46d170:	e0fffa17 	ldw	r3,-24(fp)
  46d174:	1884b03a 	or	r2,r3,r2
  46d178:	e0bffa15 	stw	r2,-24(fp)
  
  NIOS2_WRITE_STATUS (status);
  46d17c:	e0bffa17 	ldw	r2,-24(fp)
  46d180:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
  46d184:	e0bfff17 	ldw	r2,-4(fp)
  46d188:	00c018c4 	movi	r3,99
  46d18c:	10c00005 	stb	r3,0(r2)
        return;
  46d190:	00001806 	br	46d1f4 <OSMemNameSet+0x160>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
  46d194:	e0bffd17 	ldw	r2,-12(fp)
  46d198:	10800504 	addi	r2,r2,20
  46d19c:	1009883a 	mov	r4,r2
  46d1a0:	e17ffe17 	ldw	r5,-8(fp)
  46d1a4:	046a6000 	call	46a600 <OS_StrCopy>
  46d1a8:	e0bff617 	ldw	r2,-40(fp)
  46d1ac:	e0bffb15 	stw	r2,-20(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46d1b0:	0005303a 	rdctl	r2,status
  46d1b4:	e0bffc15 	stw	r2,-16(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46d1b8:	e0fffc17 	ldw	r3,-16(fp)
  46d1bc:	00bfff84 	movi	r2,-2
  46d1c0:	1884703a 	and	r2,r3,r2
  46d1c4:	e0bffc15 	stw	r2,-16(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46d1c8:	e0bffb17 	ldw	r2,-20(fp)
  46d1cc:	1080004c 	andi	r2,r2,1
  46d1d0:	e0fffc17 	ldw	r3,-16(fp)
  46d1d4:	1884b03a 	or	r2,r3,r2
  46d1d8:	e0bffc15 	stw	r2,-16(fp)
  
  NIOS2_WRITE_STATUS (status);
  46d1dc:	e0bffc17 	ldw	r2,-16(fp)
  46d1e0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
  46d1e4:	e0bfff17 	ldw	r2,-4(fp)
  46d1e8:	10000005 	stb	zero,0(r2)
  46d1ec:	00000106 	br	46d1f4 <OSMemNameSet+0x160>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
  46d1f0:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
  46d1f4:	e037883a 	mov	sp,fp
  46d1f8:	dfc00117 	ldw	ra,4(sp)
  46d1fc:	df000017 	ldw	fp,0(sp)
  46d200:	dec00204 	addi	sp,sp,8
  46d204:	f800283a 	ret

0046d208 <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
  46d208:	defff704 	addi	sp,sp,-36
  46d20c:	df000815 	stw	fp,32(sp)
  46d210:	df000804 	addi	fp,sp,32
  46d214:	e13ffe15 	stw	r4,-8(fp)
  46d218:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
  46d21c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
  46d220:	e0bffe17 	ldw	r2,-8(fp)
  46d224:	1000021e 	bne	r2,zero,46d230 <OSMemPut+0x28>
        return (OS_ERR_MEM_INVALID_PMEM);
  46d228:	00801804 	movi	r2,96
  46d22c:	00003e06 	br	46d328 <OSMemPut+0x120>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
  46d230:	e0bfff17 	ldw	r2,-4(fp)
  46d234:	1000021e 	bne	r2,zero,46d240 <OSMemPut+0x38>
        return (OS_ERR_MEM_INVALID_PBLK);
  46d238:	008017c4 	movi	r2,95
  46d23c:	00003a06 	br	46d328 <OSMemPut+0x120>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46d240:	0005303a 	rdctl	r2,status
  46d244:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46d248:	e0fff917 	ldw	r3,-28(fp)
  46d24c:	00bfff84 	movi	r2,-2
  46d250:	1884703a 	and	r2,r3,r2
  46d254:	1001703a 	wrctl	status,r2
  
  return context;
  46d258:	e0bff917 	ldw	r2,-28(fp)
    }
#endif
    OS_ENTER_CRITICAL();
  46d25c:	e0bff815 	stw	r2,-32(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
  46d260:	e0bffe17 	ldw	r2,-8(fp)
  46d264:	10c00417 	ldw	r3,16(r2)
  46d268:	e0bffe17 	ldw	r2,-8(fp)
  46d26c:	10800317 	ldw	r2,12(r2)
  46d270:	18801136 	bltu	r3,r2,46d2b8 <OSMemPut+0xb0>
  46d274:	e0bff817 	ldw	r2,-32(fp)
  46d278:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46d27c:	0005303a 	rdctl	r2,status
  46d280:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46d284:	e0fffb17 	ldw	r3,-20(fp)
  46d288:	00bfff84 	movi	r2,-2
  46d28c:	1884703a 	and	r2,r3,r2
  46d290:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46d294:	e0bffa17 	ldw	r2,-24(fp)
  46d298:	1080004c 	andi	r2,r2,1
  46d29c:	e0fffb17 	ldw	r3,-20(fp)
  46d2a0:	1884b03a 	or	r2,r3,r2
  46d2a4:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
  46d2a8:	e0bffb17 	ldw	r2,-20(fp)
  46d2ac:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
  46d2b0:	00801784 	movi	r2,94
  46d2b4:	00001c06 	br	46d328 <OSMemPut+0x120>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
  46d2b8:	e0bffe17 	ldw	r2,-8(fp)
  46d2bc:	10c00117 	ldw	r3,4(r2)
  46d2c0:	e0bfff17 	ldw	r2,-4(fp)
  46d2c4:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = pblk;
  46d2c8:	e0bffe17 	ldw	r2,-8(fp)
  46d2cc:	e0ffff17 	ldw	r3,-4(fp)
  46d2d0:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
  46d2d4:	e0bffe17 	ldw	r2,-8(fp)
  46d2d8:	10800417 	ldw	r2,16(r2)
  46d2dc:	10c00044 	addi	r3,r2,1
  46d2e0:	e0bffe17 	ldw	r2,-8(fp)
  46d2e4:	10c00415 	stw	r3,16(r2)
  46d2e8:	e0bff817 	ldw	r2,-32(fp)
  46d2ec:	e0bffc15 	stw	r2,-16(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46d2f0:	0005303a 	rdctl	r2,status
  46d2f4:	e0bffd15 	stw	r2,-12(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46d2f8:	e0fffd17 	ldw	r3,-12(fp)
  46d2fc:	00bfff84 	movi	r2,-2
  46d300:	1884703a 	and	r2,r3,r2
  46d304:	e0bffd15 	stw	r2,-12(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46d308:	e0bffc17 	ldw	r2,-16(fp)
  46d30c:	1080004c 	andi	r2,r2,1
  46d310:	e0fffd17 	ldw	r3,-12(fp)
  46d314:	1884b03a 	or	r2,r3,r2
  46d318:	e0bffd15 	stw	r2,-12(fp)
  
  NIOS2_WRITE_STATUS (status);
  46d31c:	e0bffd17 	ldw	r2,-12(fp)
  46d320:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
  46d324:	0005883a 	mov	r2,zero
}
  46d328:	e037883a 	mov	sp,fp
  46d32c:	df000017 	ldw	fp,0(sp)
  46d330:	dec00104 	addi	sp,sp,4
  46d334:	f800283a 	ret

0046d338 <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
  46d338:	defff904 	addi	sp,sp,-28
  46d33c:	df000615 	stw	fp,24(sp)
  46d340:	df000604 	addi	fp,sp,24
  46d344:	e13ffe15 	stw	r4,-8(fp)
  46d348:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
  46d34c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
  46d350:	e0bffe17 	ldw	r2,-8(fp)
  46d354:	1000021e 	bne	r2,zero,46d360 <OSMemQuery+0x28>
        return (OS_ERR_MEM_INVALID_PMEM);
  46d358:	00801804 	movi	r2,96
  46d35c:	00003706 	br	46d43c <OSMemQuery+0x104>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
  46d360:	e0bfff17 	ldw	r2,-4(fp)
  46d364:	1000021e 	bne	r2,zero,46d370 <OSMemQuery+0x38>
        return (OS_ERR_MEM_INVALID_PDATA);
  46d368:	00801844 	movi	r2,97
  46d36c:	00003306 	br	46d43c <OSMemQuery+0x104>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46d370:	0005303a 	rdctl	r2,status
  46d374:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46d378:	e0fffb17 	ldw	r3,-20(fp)
  46d37c:	00bfff84 	movi	r2,-2
  46d380:	1884703a 	and	r2,r3,r2
  46d384:	1001703a 	wrctl	status,r2
  
  return context;
  46d388:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
  46d38c:	e0bffa15 	stw	r2,-24(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
  46d390:	e0bffe17 	ldw	r2,-8(fp)
  46d394:	10c00017 	ldw	r3,0(r2)
  46d398:	e0bfff17 	ldw	r2,-4(fp)
  46d39c:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
  46d3a0:	e0bffe17 	ldw	r2,-8(fp)
  46d3a4:	10c00117 	ldw	r3,4(r2)
  46d3a8:	e0bfff17 	ldw	r2,-4(fp)
  46d3ac:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
  46d3b0:	e0bffe17 	ldw	r2,-8(fp)
  46d3b4:	10c00217 	ldw	r3,8(r2)
  46d3b8:	e0bfff17 	ldw	r2,-4(fp)
  46d3bc:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
  46d3c0:	e0bffe17 	ldw	r2,-8(fp)
  46d3c4:	10c00317 	ldw	r3,12(r2)
  46d3c8:	e0bfff17 	ldw	r2,-4(fp)
  46d3cc:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
  46d3d0:	e0bffe17 	ldw	r2,-8(fp)
  46d3d4:	10c00417 	ldw	r3,16(r2)
  46d3d8:	e0bfff17 	ldw	r2,-4(fp)
  46d3dc:	10c00415 	stw	r3,16(r2)
  46d3e0:	e0bffa17 	ldw	r2,-24(fp)
  46d3e4:	e0bffc15 	stw	r2,-16(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46d3e8:	0005303a 	rdctl	r2,status
  46d3ec:	e0bffd15 	stw	r2,-12(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46d3f0:	e0fffd17 	ldw	r3,-12(fp)
  46d3f4:	00bfff84 	movi	r2,-2
  46d3f8:	1884703a 	and	r2,r3,r2
  46d3fc:	e0bffd15 	stw	r2,-12(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46d400:	e0bffc17 	ldw	r2,-16(fp)
  46d404:	1080004c 	andi	r2,r2,1
  46d408:	e0fffd17 	ldw	r3,-12(fp)
  46d40c:	1884b03a 	or	r2,r3,r2
  46d410:	e0bffd15 	stw	r2,-12(fp)
  
  NIOS2_WRITE_STATUS (status);
  46d414:	e0bffd17 	ldw	r2,-12(fp)
  46d418:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
  46d41c:	e0bfff17 	ldw	r2,-4(fp)
  46d420:	10c00317 	ldw	r3,12(r2)
  46d424:	e0bfff17 	ldw	r2,-4(fp)
  46d428:	10800417 	ldw	r2,16(r2)
  46d42c:	1887c83a 	sub	r3,r3,r2
  46d430:	e0bfff17 	ldw	r2,-4(fp)
  46d434:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
  46d438:	0005883a 	mov	r2,zero
}
  46d43c:	e037883a 	mov	sp,fp
  46d440:	df000017 	ldw	fp,0(sp)
  46d444:	dec00104 	addi	sp,sp,4
  46d448:	f800283a 	ret

0046d44c <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
  46d44c:	defffc04 	addi	sp,sp,-16
  46d450:	dfc00315 	stw	ra,12(sp)
  46d454:	df000215 	stw	fp,8(sp)
  46d458:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
  46d45c:	01001234 	movhi	r4,72
  46d460:	21277c04 	addi	r4,r4,-25104
  46d464:	01430c04 	movi	r5,3120
  46d468:	046a3d80 	call	46a3d8 <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
  46d46c:	00801234 	movhi	r2,72
  46d470:	10a77c04 	addi	r2,r2,-25104
  46d474:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
  46d478:	e03fff0d 	sth	zero,-4(fp)
  46d47c:	00001506 	br	46d4d4 <OS_MemInit+0x88>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
  46d480:	e0bfff0b 	ldhu	r2,-4(fp)
  46d484:	10800044 	addi	r2,r2,1
  46d488:	1009883a 	mov	r4,r2
  46d48c:	01400d04 	movi	r5,52
  46d490:	04675f00 	call	4675f0 <__mulsi3>
  46d494:	00c01234 	movhi	r3,72
  46d498:	18e77c04 	addi	r3,r3,-25104
  46d49c:	10c7883a 	add	r3,r2,r3
  46d4a0:	e0bffe17 	ldw	r2,-8(fp)
  46d4a4:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
  46d4a8:	e0bffe17 	ldw	r2,-8(fp)
  46d4ac:	00c00fc4 	movi	r3,63
  46d4b0:	10c00505 	stb	r3,20(r2)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
  46d4b4:	e0bffe17 	ldw	r2,-8(fp)
  46d4b8:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
  46d4bc:	e0bffe17 	ldw	r2,-8(fp)
  46d4c0:	10800d04 	addi	r2,r2,52
  46d4c4:	e0bffe15 	stw	r2,-8(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
  46d4c8:	e0bfff0b 	ldhu	r2,-4(fp)
  46d4cc:	10800044 	addi	r2,r2,1
  46d4d0:	e0bfff0d 	sth	r2,-4(fp)
  46d4d4:	e0bfff0b 	ldhu	r2,-4(fp)
  46d4d8:	10800ef0 	cmpltui	r2,r2,59
  46d4dc:	103fe81e 	bne	r2,zero,46d480 <OS_MemInit+0x34>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
  46d4e0:	e0bffe17 	ldw	r2,-8(fp)
  46d4e4:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
  46d4e8:	e0bffe17 	ldw	r2,-8(fp)
  46d4ec:	00c00fc4 	movi	r3,63
  46d4f0:	10c00505 	stb	r3,20(r2)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
  46d4f4:	e0bffe17 	ldw	r2,-8(fp)
  46d4f8:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
  46d4fc:	00801234 	movhi	r2,72
  46d500:	10a64704 	addi	r2,r2,-26340
  46d504:	00c01234 	movhi	r3,72
  46d508:	18e77c04 	addi	r3,r3,-25104
  46d50c:	10c00015 	stw	r3,0(r2)
#endif
}
  46d510:	e037883a 	mov	sp,fp
  46d514:	dfc00117 	ldw	ra,4(sp)
  46d518:	df000017 	ldw	fp,0(sp)
  46d51c:	dec00204 	addi	sp,sp,8
  46d520:	f800283a 	ret

0046d524 <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
  46d524:	defff704 	addi	sp,sp,-36
  46d528:	df000815 	stw	fp,32(sp)
  46d52c:	df000804 	addi	fp,sp,32
  46d530:	e13ffe15 	stw	r4,-8(fp)
  46d534:	e17fff15 	stw	r5,-4(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
  46d538:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
  46d53c:	e0bfff17 	ldw	r2,-4(fp)
  46d540:	1000021e 	bne	r2,zero,46d54c <OSQAccept+0x28>
        return ((void *)0);
  46d544:	0005883a 	mov	r2,zero
  46d548:	00004d06 	br	46d680 <OSQAccept+0x15c>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
  46d54c:	e0bffe17 	ldw	r2,-8(fp)
  46d550:	1000051e 	bne	r2,zero,46d568 <OSQAccept+0x44>
        *perr = OS_ERR_PEVENT_NULL;
  46d554:	e0bfff17 	ldw	r2,-4(fp)
  46d558:	00c00104 	movi	r3,4
  46d55c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
  46d560:	0005883a 	mov	r2,zero
  46d564:	00004606 	br	46d680 <OSQAccept+0x15c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
  46d568:	e0bffe17 	ldw	r2,-8(fp)
  46d56c:	10800003 	ldbu	r2,0(r2)
  46d570:	10803fcc 	andi	r2,r2,255
  46d574:	108000a0 	cmpeqi	r2,r2,2
  46d578:	1000051e 	bne	r2,zero,46d590 <OSQAccept+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
  46d57c:	e0bfff17 	ldw	r2,-4(fp)
  46d580:	00c00044 	movi	r3,1
  46d584:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
  46d588:	0005883a 	mov	r2,zero
  46d58c:	00003c06 	br	46d680 <OSQAccept+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46d590:	0005303a 	rdctl	r2,status
  46d594:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46d598:	e0fffb17 	ldw	r3,-20(fp)
  46d59c:	00bfff84 	movi	r2,-2
  46d5a0:	1884703a 	and	r2,r3,r2
  46d5a4:	1001703a 	wrctl	status,r2
  
  return context;
  46d5a8:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
  46d5ac:	e0bff915 	stw	r2,-28(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
  46d5b0:	e0bffe17 	ldw	r2,-8(fp)
  46d5b4:	10800117 	ldw	r2,4(r2)
  46d5b8:	e0bffa15 	stw	r2,-24(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
  46d5bc:	e0bffa17 	ldw	r2,-24(fp)
  46d5c0:	1080058b 	ldhu	r2,22(r2)
  46d5c4:	10bfffcc 	andi	r2,r2,65535
  46d5c8:	10001926 	beq	r2,zero,46d630 <OSQAccept+0x10c>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
  46d5cc:	e0bffa17 	ldw	r2,-24(fp)
  46d5d0:	10800417 	ldw	r2,16(r2)
  46d5d4:	10c00017 	ldw	r3,0(r2)
  46d5d8:	e0fff815 	stw	r3,-32(fp)
  46d5dc:	10c00104 	addi	r3,r2,4
  46d5e0:	e0bffa17 	ldw	r2,-24(fp)
  46d5e4:	10c00415 	stw	r3,16(r2)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
  46d5e8:	e0bffa17 	ldw	r2,-24(fp)
  46d5ec:	1080058b 	ldhu	r2,22(r2)
  46d5f0:	10bfffc4 	addi	r2,r2,-1
  46d5f4:	1007883a 	mov	r3,r2
  46d5f8:	e0bffa17 	ldw	r2,-24(fp)
  46d5fc:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
  46d600:	e0bffa17 	ldw	r2,-24(fp)
  46d604:	10c00417 	ldw	r3,16(r2)
  46d608:	e0bffa17 	ldw	r2,-24(fp)
  46d60c:	10800217 	ldw	r2,8(r2)
  46d610:	1880041e 	bne	r3,r2,46d624 <OSQAccept+0x100>
            pq->OSQOut = pq->OSQStart;
  46d614:	e0bffa17 	ldw	r2,-24(fp)
  46d618:	10c00117 	ldw	r3,4(r2)
  46d61c:	e0bffa17 	ldw	r2,-24(fp)
  46d620:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
  46d624:	e0bfff17 	ldw	r2,-4(fp)
  46d628:	10000005 	stb	zero,0(r2)
  46d62c:	00000406 	br	46d640 <OSQAccept+0x11c>
    } else {
        *perr = OS_ERR_Q_EMPTY;
  46d630:	e0bfff17 	ldw	r2,-4(fp)
  46d634:	00c007c4 	movi	r3,31
  46d638:	10c00005 	stb	r3,0(r2)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
  46d63c:	e03ff815 	stw	zero,-32(fp)
  46d640:	e0bff917 	ldw	r2,-28(fp)
  46d644:	e0bffc15 	stw	r2,-16(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46d648:	0005303a 	rdctl	r2,status
  46d64c:	e0bffd15 	stw	r2,-12(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46d650:	e0fffd17 	ldw	r3,-12(fp)
  46d654:	00bfff84 	movi	r2,-2
  46d658:	1884703a 	and	r2,r3,r2
  46d65c:	e0bffd15 	stw	r2,-12(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46d660:	e0bffc17 	ldw	r2,-16(fp)
  46d664:	1080004c 	andi	r2,r2,1
  46d668:	e0fffd17 	ldw	r3,-12(fp)
  46d66c:	1884b03a 	or	r2,r3,r2
  46d670:	e0bffd15 	stw	r2,-12(fp)
  
  NIOS2_WRITE_STATUS (status);
  46d674:	e0bffd17 	ldw	r2,-12(fp)
  46d678:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
  46d67c:	e0bff817 	ldw	r2,-32(fp)
}
  46d680:	e037883a 	mov	sp,fp
  46d684:	df000017 	ldw	fp,0(sp)
  46d688:	dec00104 	addi	sp,sp,4
  46d68c:	f800283a 	ret

0046d690 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
  46d690:	defff104 	addi	sp,sp,-60
  46d694:	dfc00e15 	stw	ra,56(sp)
  46d698:	df000d15 	stw	fp,52(sp)
  46d69c:	df000d04 	addi	fp,sp,52
  46d6a0:	e13ffe15 	stw	r4,-8(fp)
  46d6a4:	2805883a 	mov	r2,r5
  46d6a8:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
  46d6ac:	e03ff415 	stw	zero,-48(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
  46d6b0:	00801234 	movhi	r2,72
  46d6b4:	10a64c04 	addi	r2,r2,-26320
  46d6b8:	10800003 	ldbu	r2,0(r2)
  46d6bc:	10803fcc 	andi	r2,r2,255
  46d6c0:	10000226 	beq	r2,zero,46d6cc <OSQCreate+0x3c>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
  46d6c4:	0005883a 	mov	r2,zero
  46d6c8:	00008b06 	br	46d8f8 <OSQCreate+0x268>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46d6cc:	0005303a 	rdctl	r2,status
  46d6d0:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46d6d4:	e0fff617 	ldw	r3,-40(fp)
  46d6d8:	00bfff84 	movi	r2,-2
  46d6dc:	1884703a 	and	r2,r3,r2
  46d6e0:	1001703a 	wrctl	status,r2
  
  return context;
  46d6e4:	e0bff617 	ldw	r2,-40(fp)
    }
    OS_ENTER_CRITICAL();
  46d6e8:	e0bff415 	stw	r2,-48(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
  46d6ec:	00801234 	movhi	r2,72
  46d6f0:	10a64b04 	addi	r2,r2,-26324
  46d6f4:	10800017 	ldw	r2,0(r2)
  46d6f8:	e0bff315 	stw	r2,-52(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
  46d6fc:	00801234 	movhi	r2,72
  46d700:	10a64b04 	addi	r2,r2,-26324
  46d704:	10800017 	ldw	r2,0(r2)
  46d708:	10000726 	beq	r2,zero,46d728 <OSQCreate+0x98>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
  46d70c:	00801234 	movhi	r2,72
  46d710:	10a64b04 	addi	r2,r2,-26324
  46d714:	10800017 	ldw	r2,0(r2)
  46d718:	10c00117 	ldw	r3,4(r2)
  46d71c:	00801234 	movhi	r2,72
  46d720:	10a64b04 	addi	r2,r2,-26324
  46d724:	10c00015 	stw	r3,0(r2)
  46d728:	e0bff417 	ldw	r2,-48(fp)
  46d72c:	e0bff715 	stw	r2,-36(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46d730:	0005303a 	rdctl	r2,status
  46d734:	e0bff815 	stw	r2,-32(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46d738:	e0fff817 	ldw	r3,-32(fp)
  46d73c:	00bfff84 	movi	r2,-2
  46d740:	1884703a 	and	r2,r3,r2
  46d744:	e0bff815 	stw	r2,-32(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46d748:	e0bff717 	ldw	r2,-36(fp)
  46d74c:	1080004c 	andi	r2,r2,1
  46d750:	e0fff817 	ldw	r3,-32(fp)
  46d754:	1884b03a 	or	r2,r3,r2
  46d758:	e0bff815 	stw	r2,-32(fp)
  
  NIOS2_WRITE_STATUS (status);
  46d75c:	e0bff817 	ldw	r2,-32(fp)
  46d760:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
  46d764:	e0bff317 	ldw	r2,-52(fp)
  46d768:	10006226 	beq	r2,zero,46d8f4 <OSQCreate+0x264>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46d76c:	0005303a 	rdctl	r2,status
  46d770:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46d774:	e0fff917 	ldw	r3,-28(fp)
  46d778:	00bfff84 	movi	r2,-2
  46d77c:	1884703a 	and	r2,r3,r2
  46d780:	1001703a 	wrctl	status,r2
  
  return context;
  46d784:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();
  46d788:	e0bff415 	stw	r2,-48(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
  46d78c:	00801234 	movhi	r2,72
  46d790:	10a64904 	addi	r2,r2,-26332
  46d794:	10800017 	ldw	r2,0(r2)
  46d798:	e0bff515 	stw	r2,-44(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
  46d79c:	e0bff517 	ldw	r2,-44(fp)
  46d7a0:	10003b26 	beq	r2,zero,46d890 <OSQCreate+0x200>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
  46d7a4:	00801234 	movhi	r2,72
  46d7a8:	10a64904 	addi	r2,r2,-26332
  46d7ac:	10800017 	ldw	r2,0(r2)
  46d7b0:	10c00017 	ldw	r3,0(r2)
  46d7b4:	00801234 	movhi	r2,72
  46d7b8:	10a64904 	addi	r2,r2,-26332
  46d7bc:	10c00015 	stw	r3,0(r2)
  46d7c0:	e0bff417 	ldw	r2,-48(fp)
  46d7c4:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46d7c8:	0005303a 	rdctl	r2,status
  46d7cc:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46d7d0:	e0fffb17 	ldw	r3,-20(fp)
  46d7d4:	00bfff84 	movi	r2,-2
  46d7d8:	1884703a 	and	r2,r3,r2
  46d7dc:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46d7e0:	e0bffa17 	ldw	r2,-24(fp)
  46d7e4:	1080004c 	andi	r2,r2,1
  46d7e8:	e0fffb17 	ldw	r3,-20(fp)
  46d7ec:	1884b03a 	or	r2,r3,r2
  46d7f0:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
  46d7f4:	e0bffb17 	ldw	r2,-20(fp)
  46d7f8:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
  46d7fc:	e0bff517 	ldw	r2,-44(fp)
  46d800:	e0fffe17 	ldw	r3,-8(fp)
  46d804:	10c00115 	stw	r3,4(r2)
            pq->OSQEnd             = &start[size];
  46d808:	e0bfff0b 	ldhu	r2,-4(fp)
  46d80c:	1085883a 	add	r2,r2,r2
  46d810:	1085883a 	add	r2,r2,r2
  46d814:	e0fffe17 	ldw	r3,-8(fp)
  46d818:	1887883a 	add	r3,r3,r2
  46d81c:	e0bff517 	ldw	r2,-44(fp)
  46d820:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
  46d824:	e0bff517 	ldw	r2,-44(fp)
  46d828:	e0fffe17 	ldw	r3,-8(fp)
  46d82c:	10c00315 	stw	r3,12(r2)
            pq->OSQOut             = start;
  46d830:	e0bff517 	ldw	r2,-44(fp)
  46d834:	e0fffe17 	ldw	r3,-8(fp)
  46d838:	10c00415 	stw	r3,16(r2)
            pq->OSQSize            = size;
  46d83c:	e0bff517 	ldw	r2,-44(fp)
  46d840:	e0ffff0b 	ldhu	r3,-4(fp)
  46d844:	10c0050d 	sth	r3,20(r2)
            pq->OSQEntries         = 0;
  46d848:	e0bff517 	ldw	r2,-44(fp)
  46d84c:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
  46d850:	e0bff317 	ldw	r2,-52(fp)
  46d854:	00c00084 	movi	r3,2
  46d858:	10c00005 	stb	r3,0(r2)
            pevent->OSEventCnt     = 0;
  46d85c:	e0bff317 	ldw	r2,-52(fp)
  46d860:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
  46d864:	e0bff317 	ldw	r2,-52(fp)
  46d868:	e0fff517 	ldw	r3,-44(fp)
  46d86c:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
  46d870:	e0bff317 	ldw	r2,-52(fp)
  46d874:	00c00fc4 	movi	r3,63
  46d878:	10c00385 	stb	r3,14(r2)
            pevent->OSEventName[1] = OS_ASCII_NUL;
  46d87c:	e0bff317 	ldw	r2,-52(fp)
  46d880:	100003c5 	stb	zero,15(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
  46d884:	e13ff317 	ldw	r4,-52(fp)
  46d888:	046a00c0 	call	46a00c <OS_EventWaitListInit>
  46d88c:	00001906 	br	46d8f4 <OSQCreate+0x264>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
  46d890:	00801234 	movhi	r2,72
  46d894:	10a64b04 	addi	r2,r2,-26324
  46d898:	10c00017 	ldw	r3,0(r2)
  46d89c:	e0bff317 	ldw	r2,-52(fp)
  46d8a0:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
  46d8a4:	00801234 	movhi	r2,72
  46d8a8:	10a64b04 	addi	r2,r2,-26324
  46d8ac:	e0fff317 	ldw	r3,-52(fp)
  46d8b0:	10c00015 	stw	r3,0(r2)
  46d8b4:	e0bff417 	ldw	r2,-48(fp)
  46d8b8:	e0bffc15 	stw	r2,-16(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46d8bc:	0005303a 	rdctl	r2,status
  46d8c0:	e0bffd15 	stw	r2,-12(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46d8c4:	e0fffd17 	ldw	r3,-12(fp)
  46d8c8:	00bfff84 	movi	r2,-2
  46d8cc:	1884703a 	and	r2,r3,r2
  46d8d0:	e0bffd15 	stw	r2,-12(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46d8d4:	e0bffc17 	ldw	r2,-16(fp)
  46d8d8:	1080004c 	andi	r2,r2,1
  46d8dc:	e0fffd17 	ldw	r3,-12(fp)
  46d8e0:	1884b03a 	or	r2,r3,r2
  46d8e4:	e0bffd15 	stw	r2,-12(fp)
  
  NIOS2_WRITE_STATUS (status);
  46d8e8:	e0bffd17 	ldw	r2,-12(fp)
  46d8ec:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
  46d8f0:	e03ff315 	stw	zero,-52(fp)
        }
    }
    return (pevent);
  46d8f4:	e0bff317 	ldw	r2,-52(fp)
}
  46d8f8:	e037883a 	mov	sp,fp
  46d8fc:	dfc00117 	ldw	ra,4(sp)
  46d900:	df000017 	ldw	fp,0(sp)
  46d904:	dec00204 	addi	sp,sp,8
  46d908:	f800283a 	ret

0046d90c <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
  46d90c:	deffee04 	addi	sp,sp,-72
  46d910:	dfc01115 	stw	ra,68(sp)
  46d914:	df001015 	stw	fp,64(sp)
  46d918:	df001004 	addi	fp,sp,64
  46d91c:	e13ffd15 	stw	r4,-12(fp)
  46d920:	2805883a 	mov	r2,r5
  46d924:	e1bfff15 	stw	r6,-4(fp)
  46d928:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
  46d92c:	e03ff215 	stw	zero,-56(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
  46d930:	e0bfff17 	ldw	r2,-4(fp)
  46d934:	1000021e 	bne	r2,zero,46d940 <OSQDel+0x34>
        return (pevent);
  46d938:	e0bffd17 	ldw	r2,-12(fp)
  46d93c:	0000ce06 	br	46dc78 <OSQDel+0x36c>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
  46d940:	e0bffd17 	ldw	r2,-12(fp)
  46d944:	1000051e 	bne	r2,zero,46d95c <OSQDel+0x50>
        *perr = OS_ERR_PEVENT_NULL;
  46d948:	e0bfff17 	ldw	r2,-4(fp)
  46d94c:	00c00104 	movi	r3,4
  46d950:	10c00005 	stb	r3,0(r2)
        return (pevent);
  46d954:	e0bffd17 	ldw	r2,-12(fp)
  46d958:	0000c706 	br	46dc78 <OSQDel+0x36c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
  46d95c:	e0bffd17 	ldw	r2,-12(fp)
  46d960:	10800003 	ldbu	r2,0(r2)
  46d964:	10803fcc 	andi	r2,r2,255
  46d968:	108000a0 	cmpeqi	r2,r2,2
  46d96c:	1000051e 	bne	r2,zero,46d984 <OSQDel+0x78>
        *perr = OS_ERR_EVENT_TYPE;
  46d970:	e0bfff17 	ldw	r2,-4(fp)
  46d974:	00c00044 	movi	r3,1
  46d978:	10c00005 	stb	r3,0(r2)
        return (pevent);
  46d97c:	e0bffd17 	ldw	r2,-12(fp)
  46d980:	0000bd06 	br	46dc78 <OSQDel+0x36c>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
  46d984:	00801234 	movhi	r2,72
  46d988:	10a64c04 	addi	r2,r2,-26320
  46d98c:	10800003 	ldbu	r2,0(r2)
  46d990:	10803fcc 	andi	r2,r2,255
  46d994:	10000526 	beq	r2,zero,46d9ac <OSQDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
  46d998:	e0bfff17 	ldw	r2,-4(fp)
  46d99c:	00c003c4 	movi	r3,15
  46d9a0:	10c00005 	stb	r3,0(r2)
        return (pevent);
  46d9a4:	e0bffd17 	ldw	r2,-12(fp)
  46d9a8:	0000b306 	br	46dc78 <OSQDel+0x36c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46d9ac:	0005303a 	rdctl	r2,status
  46d9b0:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46d9b4:	e0fff417 	ldw	r3,-48(fp)
  46d9b8:	00bfff84 	movi	r2,-2
  46d9bc:	1884703a 	and	r2,r3,r2
  46d9c0:	1001703a 	wrctl	status,r2
  
  return context;
  46d9c4:	e0bff417 	ldw	r2,-48(fp)
    }
    OS_ENTER_CRITICAL();
  46d9c8:	e0bff215 	stw	r2,-56(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
  46d9cc:	e0bffd17 	ldw	r2,-12(fp)
  46d9d0:	10800283 	ldbu	r2,10(r2)
  46d9d4:	10803fcc 	andi	r2,r2,255
  46d9d8:	10000326 	beq	r2,zero,46d9e8 <OSQDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
  46d9dc:	00800044 	movi	r2,1
  46d9e0:	e0bff005 	stb	r2,-64(fp)
  46d9e4:	00000106 	br	46d9ec <OSQDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
  46d9e8:	e03ff005 	stb	zero,-64(fp)
    }
    switch (opt) {
  46d9ec:	e0bffe03 	ldbu	r2,-8(fp)
  46d9f0:	10000326 	beq	r2,zero,46da00 <OSQDel+0xf4>
  46d9f4:	10800060 	cmpeqi	r2,r2,1
  46d9f8:	10004f1e 	bne	r2,zero,46db38 <OSQDel+0x22c>
  46d9fc:	00008806 	br	46dc20 <OSQDel+0x314>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
  46da00:	e0bff003 	ldbu	r2,-64(fp)
  46da04:	1000311e 	bne	r2,zero,46dacc <OSQDel+0x1c0>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
  46da08:	e0bffd17 	ldw	r2,-12(fp)
  46da0c:	00c00fc4 	movi	r3,63
  46da10:	10c00385 	stb	r3,14(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
  46da14:	e0bffd17 	ldw	r2,-12(fp)
  46da18:	100003c5 	stb	zero,15(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
  46da1c:	e0bffd17 	ldw	r2,-12(fp)
  46da20:	10800117 	ldw	r2,4(r2)
  46da24:	e0bff315 	stw	r2,-52(fp)
                 pq->OSQPtr             = OSQFreeList;
  46da28:	00801234 	movhi	r2,72
  46da2c:	10a64904 	addi	r2,r2,-26332
  46da30:	10c00017 	ldw	r3,0(r2)
  46da34:	e0bff317 	ldw	r2,-52(fp)
  46da38:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
  46da3c:	00801234 	movhi	r2,72
  46da40:	10a64904 	addi	r2,r2,-26332
  46da44:	e0fff317 	ldw	r3,-52(fp)
  46da48:	10c00015 	stw	r3,0(r2)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
  46da4c:	e0bffd17 	ldw	r2,-12(fp)
  46da50:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
  46da54:	00801234 	movhi	r2,72
  46da58:	10a64b04 	addi	r2,r2,-26324
  46da5c:	10c00017 	ldw	r3,0(r2)
  46da60:	e0bffd17 	ldw	r2,-12(fp)
  46da64:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
  46da68:	e0bffd17 	ldw	r2,-12(fp)
  46da6c:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
  46da70:	00801234 	movhi	r2,72
  46da74:	10a64b04 	addi	r2,r2,-26324
  46da78:	e0fffd17 	ldw	r3,-12(fp)
  46da7c:	10c00015 	stw	r3,0(r2)
  46da80:	e0bff217 	ldw	r2,-56(fp)
  46da84:	e0bff515 	stw	r2,-44(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46da88:	0005303a 	rdctl	r2,status
  46da8c:	e0bff615 	stw	r2,-40(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46da90:	e0fff617 	ldw	r3,-40(fp)
  46da94:	00bfff84 	movi	r2,-2
  46da98:	1884703a 	and	r2,r3,r2
  46da9c:	e0bff615 	stw	r2,-40(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46daa0:	e0bff517 	ldw	r2,-44(fp)
  46daa4:	1080004c 	andi	r2,r2,1
  46daa8:	e0fff617 	ldw	r3,-40(fp)
  46daac:	1884b03a 	or	r2,r3,r2
  46dab0:	e0bff615 	stw	r2,-40(fp)
  
  NIOS2_WRITE_STATUS (status);
  46dab4:	e0bff617 	ldw	r2,-40(fp)
  46dab8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
  46dabc:	e0bfff17 	ldw	r2,-4(fp)
  46dac0:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
  46dac4:	e03ff115 	stw	zero,-60(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
  46dac8:	00006a06 	br	46dc74 <OSQDel+0x368>
  46dacc:	e0bff217 	ldw	r2,-56(fp)
  46dad0:	e0bff715 	stw	r2,-36(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46dad4:	0005303a 	rdctl	r2,status
  46dad8:	e0bff815 	stw	r2,-32(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46dadc:	e0fff817 	ldw	r3,-32(fp)
  46dae0:	00bfff84 	movi	r2,-2
  46dae4:	1884703a 	and	r2,r3,r2
  46dae8:	e0bff815 	stw	r2,-32(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46daec:	e0bff717 	ldw	r2,-36(fp)
  46daf0:	1080004c 	andi	r2,r2,1
  46daf4:	e0fff817 	ldw	r3,-32(fp)
  46daf8:	1884b03a 	or	r2,r3,r2
  46dafc:	e0bff815 	stw	r2,-32(fp)
  
  NIOS2_WRITE_STATUS (status);
  46db00:	e0bff817 	ldw	r2,-32(fp)
  46db04:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
  46db08:	e0bfff17 	ldw	r2,-4(fp)
  46db0c:	00c01244 	movi	r3,73
  46db10:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
  46db14:	e0bffd17 	ldw	r2,-12(fp)
  46db18:	e0bff115 	stw	r2,-60(fp)
             }
             break;
  46db1c:	00005506 	br	46dc74 <OSQDel+0x368>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
  46db20:	e13ffd17 	ldw	r4,-12(fp)
  46db24:	000b883a 	mov	r5,zero
  46db28:	01800104 	movi	r6,4
  46db2c:	000f883a 	mov	r7,zero
  46db30:	0469a7c0 	call	469a7c <OS_EventTaskRdy>
  46db34:	00000106 	br	46db3c <OSQDel+0x230>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
  46db38:	0001883a 	nop
  46db3c:	e0bffd17 	ldw	r2,-12(fp)
  46db40:	10800283 	ldbu	r2,10(r2)
  46db44:	10803fcc 	andi	r2,r2,255
  46db48:	103ff51e 	bne	r2,zero,46db20 <OSQDel+0x214>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
  46db4c:	e0bffd17 	ldw	r2,-12(fp)
  46db50:	00c00fc4 	movi	r3,63
  46db54:	10c00385 	stb	r3,14(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
  46db58:	e0bffd17 	ldw	r2,-12(fp)
  46db5c:	100003c5 	stb	zero,15(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
  46db60:	e0bffd17 	ldw	r2,-12(fp)
  46db64:	10800117 	ldw	r2,4(r2)
  46db68:	e0bff315 	stw	r2,-52(fp)
             pq->OSQPtr             = OSQFreeList;
  46db6c:	00801234 	movhi	r2,72
  46db70:	10a64904 	addi	r2,r2,-26332
  46db74:	10c00017 	ldw	r3,0(r2)
  46db78:	e0bff317 	ldw	r2,-52(fp)
  46db7c:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
  46db80:	00801234 	movhi	r2,72
  46db84:	10a64904 	addi	r2,r2,-26332
  46db88:	e0fff317 	ldw	r3,-52(fp)
  46db8c:	10c00015 	stw	r3,0(r2)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
  46db90:	e0bffd17 	ldw	r2,-12(fp)
  46db94:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
  46db98:	00801234 	movhi	r2,72
  46db9c:	10a64b04 	addi	r2,r2,-26324
  46dba0:	10c00017 	ldw	r3,0(r2)
  46dba4:	e0bffd17 	ldw	r2,-12(fp)
  46dba8:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
  46dbac:	e0bffd17 	ldw	r2,-12(fp)
  46dbb0:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
  46dbb4:	00801234 	movhi	r2,72
  46dbb8:	10a64b04 	addi	r2,r2,-26324
  46dbbc:	e0fffd17 	ldw	r3,-12(fp)
  46dbc0:	10c00015 	stw	r3,0(r2)
  46dbc4:	e0bff217 	ldw	r2,-56(fp)
  46dbc8:	e0bff915 	stw	r2,-28(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46dbcc:	0005303a 	rdctl	r2,status
  46dbd0:	e0bffa15 	stw	r2,-24(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46dbd4:	e0fffa17 	ldw	r3,-24(fp)
  46dbd8:	00bfff84 	movi	r2,-2
  46dbdc:	1884703a 	and	r2,r3,r2
  46dbe0:	e0bffa15 	stw	r2,-24(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46dbe4:	e0bff917 	ldw	r2,-28(fp)
  46dbe8:	1080004c 	andi	r2,r2,1
  46dbec:	e0fffa17 	ldw	r3,-24(fp)
  46dbf0:	1884b03a 	or	r2,r3,r2
  46dbf4:	e0bffa15 	stw	r2,-24(fp)
  
  NIOS2_WRITE_STATUS (status);
  46dbf8:	e0bffa17 	ldw	r2,-24(fp)
  46dbfc:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
  46dc00:	e0bff003 	ldbu	r2,-64(fp)
  46dc04:	10800058 	cmpnei	r2,r2,1
  46dc08:	1000011e 	bne	r2,zero,46dc10 <OSQDel+0x304>
                 OS_Sched();                               /* Find highest priority task ready to run  */
  46dc0c:	046a4980 	call	46a498 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
  46dc10:	e0bfff17 	ldw	r2,-4(fp)
  46dc14:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
  46dc18:	e03ff115 	stw	zero,-60(fp)
             break;
  46dc1c:	00001506 	br	46dc74 <OSQDel+0x368>
  46dc20:	e0bff217 	ldw	r2,-56(fp)
  46dc24:	e0bffb15 	stw	r2,-20(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46dc28:	0005303a 	rdctl	r2,status
  46dc2c:	e0bffc15 	stw	r2,-16(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46dc30:	e0fffc17 	ldw	r3,-16(fp)
  46dc34:	00bfff84 	movi	r2,-2
  46dc38:	1884703a 	and	r2,r3,r2
  46dc3c:	e0bffc15 	stw	r2,-16(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46dc40:	e0bffb17 	ldw	r2,-20(fp)
  46dc44:	1080004c 	andi	r2,r2,1
  46dc48:	e0fffc17 	ldw	r3,-16(fp)
  46dc4c:	1884b03a 	or	r2,r3,r2
  46dc50:	e0bffc15 	stw	r2,-16(fp)
  
  NIOS2_WRITE_STATUS (status);
  46dc54:	e0bffc17 	ldw	r2,-16(fp)
  46dc58:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
  46dc5c:	e0bfff17 	ldw	r2,-4(fp)
  46dc60:	00c001c4 	movi	r3,7
  46dc64:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
  46dc68:	e0bffd17 	ldw	r2,-12(fp)
  46dc6c:	e0bff115 	stw	r2,-60(fp)
             break;
  46dc70:	0001883a 	nop
    }
    return (pevent_return);
  46dc74:	e0bff117 	ldw	r2,-60(fp)
}
  46dc78:	e037883a 	mov	sp,fp
  46dc7c:	dfc00117 	ldw	ra,4(sp)
  46dc80:	df000017 	ldw	fp,0(sp)
  46dc84:	dec00204 	addi	sp,sp,8
  46dc88:	f800283a 	ret

0046dc8c <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
  46dc8c:	defff904 	addi	sp,sp,-28
  46dc90:	df000615 	stw	fp,24(sp)
  46dc94:	df000604 	addi	fp,sp,24
  46dc98:	e13fff15 	stw	r4,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
  46dc9c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
  46dca0:	e0bfff17 	ldw	r2,-4(fp)
  46dca4:	1000021e 	bne	r2,zero,46dcb0 <OSQFlush+0x24>
        return (OS_ERR_PEVENT_NULL);
  46dca8:	00800104 	movi	r2,4
  46dcac:	00002c06 	br	46dd60 <OSQFlush+0xd4>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
  46dcb0:	e0bfff17 	ldw	r2,-4(fp)
  46dcb4:	10800003 	ldbu	r2,0(r2)
  46dcb8:	10803fcc 	andi	r2,r2,255
  46dcbc:	108000a0 	cmpeqi	r2,r2,2
  46dcc0:	1000021e 	bne	r2,zero,46dccc <OSQFlush+0x40>
        return (OS_ERR_EVENT_TYPE);
  46dcc4:	00800044 	movi	r2,1
  46dcc8:	00002506 	br	46dd60 <OSQFlush+0xd4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46dccc:	0005303a 	rdctl	r2,status
  46dcd0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46dcd4:	e0fffc17 	ldw	r3,-16(fp)
  46dcd8:	00bfff84 	movi	r2,-2
  46dcdc:	1884703a 	and	r2,r3,r2
  46dce0:	1001703a 	wrctl	status,r2
  
  return context;
  46dce4:	e0bffc17 	ldw	r2,-16(fp)
    }
#endif
    OS_ENTER_CRITICAL();
  46dce8:	e0bffa15 	stw	r2,-24(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
  46dcec:	e0bfff17 	ldw	r2,-4(fp)
  46dcf0:	10800117 	ldw	r2,4(r2)
  46dcf4:	e0bffb15 	stw	r2,-20(fp)
    pq->OSQIn      = pq->OSQStart;
  46dcf8:	e0bffb17 	ldw	r2,-20(fp)
  46dcfc:	10c00117 	ldw	r3,4(r2)
  46dd00:	e0bffb17 	ldw	r2,-20(fp)
  46dd04:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
  46dd08:	e0bffb17 	ldw	r2,-20(fp)
  46dd0c:	10c00117 	ldw	r3,4(r2)
  46dd10:	e0bffb17 	ldw	r2,-20(fp)
  46dd14:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
  46dd18:	e0bffb17 	ldw	r2,-20(fp)
  46dd1c:	1000058d 	sth	zero,22(r2)
  46dd20:	e0bffa17 	ldw	r2,-24(fp)
  46dd24:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46dd28:	0005303a 	rdctl	r2,status
  46dd2c:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46dd30:	e0fffe17 	ldw	r3,-8(fp)
  46dd34:	00bfff84 	movi	r2,-2
  46dd38:	1884703a 	and	r2,r3,r2
  46dd3c:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46dd40:	e0bffd17 	ldw	r2,-12(fp)
  46dd44:	1080004c 	andi	r2,r2,1
  46dd48:	e0fffe17 	ldw	r3,-8(fp)
  46dd4c:	1884b03a 	or	r2,r3,r2
  46dd50:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
  46dd54:	e0bffe17 	ldw	r2,-8(fp)
  46dd58:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
  46dd5c:	0005883a 	mov	r2,zero
}
  46dd60:	e037883a 	mov	sp,fp
  46dd64:	df000017 	ldw	fp,0(sp)
  46dd68:	dec00104 	addi	sp,sp,4
  46dd6c:	f800283a 	ret

0046dd70 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
  46dd70:	defff004 	addi	sp,sp,-64
  46dd74:	dfc00f15 	stw	ra,60(sp)
  46dd78:	df000e15 	stw	fp,56(sp)
  46dd7c:	df000e04 	addi	fp,sp,56
  46dd80:	e13ffd15 	stw	r4,-12(fp)
  46dd84:	2805883a 	mov	r2,r5
  46dd88:	e1bfff15 	stw	r6,-4(fp)
  46dd8c:	e0bffe0d 	sth	r2,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
  46dd90:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
  46dd94:	e0bfff17 	ldw	r2,-4(fp)
  46dd98:	1000021e 	bne	r2,zero,46dda4 <OSQPend+0x34>
        return ((void *)0);
  46dd9c:	0005883a 	mov	r2,zero
  46dda0:	0000ce06 	br	46e0dc <OSQPend+0x36c>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
  46dda4:	e0bffd17 	ldw	r2,-12(fp)
  46dda8:	1000051e 	bne	r2,zero,46ddc0 <OSQPend+0x50>
        *perr = OS_ERR_PEVENT_NULL;
  46ddac:	e0bfff17 	ldw	r2,-4(fp)
  46ddb0:	00c00104 	movi	r3,4
  46ddb4:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
  46ddb8:	0005883a 	mov	r2,zero
  46ddbc:	0000c706 	br	46e0dc <OSQPend+0x36c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
  46ddc0:	e0bffd17 	ldw	r2,-12(fp)
  46ddc4:	10800003 	ldbu	r2,0(r2)
  46ddc8:	10803fcc 	andi	r2,r2,255
  46ddcc:	108000a0 	cmpeqi	r2,r2,2
  46ddd0:	1000051e 	bne	r2,zero,46dde8 <OSQPend+0x78>
        *perr = OS_ERR_EVENT_TYPE;
  46ddd4:	e0bfff17 	ldw	r2,-4(fp)
  46ddd8:	00c00044 	movi	r3,1
  46dddc:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
  46dde0:	0005883a 	mov	r2,zero
  46dde4:	0000bd06 	br	46e0dc <OSQPend+0x36c>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
  46dde8:	00801234 	movhi	r2,72
  46ddec:	10a64c04 	addi	r2,r2,-26320
  46ddf0:	10800003 	ldbu	r2,0(r2)
  46ddf4:	10803fcc 	andi	r2,r2,255
  46ddf8:	10000526 	beq	r2,zero,46de10 <OSQPend+0xa0>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
  46ddfc:	e0bfff17 	ldw	r2,-4(fp)
  46de00:	00c00084 	movi	r3,2
  46de04:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
  46de08:	0005883a 	mov	r2,zero
  46de0c:	0000b306 	br	46e0dc <OSQPend+0x36c>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
  46de10:	00801234 	movhi	r2,72
  46de14:	10a63e04 	addi	r2,r2,-26376
  46de18:	10800003 	ldbu	r2,0(r2)
  46de1c:	10803fcc 	andi	r2,r2,255
  46de20:	10000526 	beq	r2,zero,46de38 <OSQPend+0xc8>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
  46de24:	e0bfff17 	ldw	r2,-4(fp)
  46de28:	00c00344 	movi	r3,13
  46de2c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
  46de30:	0005883a 	mov	r2,zero
  46de34:	0000a906 	br	46e0dc <OSQPend+0x36c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46de38:	0005303a 	rdctl	r2,status
  46de3c:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46de40:	e0fff517 	ldw	r3,-44(fp)
  46de44:	00bfff84 	movi	r2,-2
  46de48:	1884703a 	and	r2,r3,r2
  46de4c:	1001703a 	wrctl	status,r2
  
  return context;
  46de50:	e0bff517 	ldw	r2,-44(fp)
    }
    OS_ENTER_CRITICAL();
  46de54:	e0bff315 	stw	r2,-52(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
  46de58:	e0bffd17 	ldw	r2,-12(fp)
  46de5c:	10800117 	ldw	r2,4(r2)
  46de60:	e0bff415 	stw	r2,-48(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
  46de64:	e0bff417 	ldw	r2,-48(fp)
  46de68:	1080058b 	ldhu	r2,22(r2)
  46de6c:	10bfffcc 	andi	r2,r2,65535
  46de70:	10002926 	beq	r2,zero,46df18 <OSQPend+0x1a8>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
  46de74:	e0bff417 	ldw	r2,-48(fp)
  46de78:	10800417 	ldw	r2,16(r2)
  46de7c:	10c00017 	ldw	r3,0(r2)
  46de80:	e0fff215 	stw	r3,-56(fp)
  46de84:	10c00104 	addi	r3,r2,4
  46de88:	e0bff417 	ldw	r2,-48(fp)
  46de8c:	10c00415 	stw	r3,16(r2)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
  46de90:	e0bff417 	ldw	r2,-48(fp)
  46de94:	1080058b 	ldhu	r2,22(r2)
  46de98:	10bfffc4 	addi	r2,r2,-1
  46de9c:	1007883a 	mov	r3,r2
  46dea0:	e0bff417 	ldw	r2,-48(fp)
  46dea4:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
  46dea8:	e0bff417 	ldw	r2,-48(fp)
  46deac:	10c00417 	ldw	r3,16(r2)
  46deb0:	e0bff417 	ldw	r2,-48(fp)
  46deb4:	10800217 	ldw	r2,8(r2)
  46deb8:	1880041e 	bne	r3,r2,46decc <OSQPend+0x15c>
            pq->OSQOut = pq->OSQStart;
  46debc:	e0bff417 	ldw	r2,-48(fp)
  46dec0:	10c00117 	ldw	r3,4(r2)
  46dec4:	e0bff417 	ldw	r2,-48(fp)
  46dec8:	10c00415 	stw	r3,16(r2)
  46decc:	e0bff317 	ldw	r2,-52(fp)
  46ded0:	e0bff615 	stw	r2,-40(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46ded4:	0005303a 	rdctl	r2,status
  46ded8:	e0bff715 	stw	r2,-36(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46dedc:	e0fff717 	ldw	r3,-36(fp)
  46dee0:	00bfff84 	movi	r2,-2
  46dee4:	1884703a 	and	r2,r3,r2
  46dee8:	e0bff715 	stw	r2,-36(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46deec:	e0bff617 	ldw	r2,-40(fp)
  46def0:	1080004c 	andi	r2,r2,1
  46def4:	e0fff717 	ldw	r3,-36(fp)
  46def8:	1884b03a 	or	r2,r3,r2
  46defc:	e0bff715 	stw	r2,-36(fp)
  
  NIOS2_WRITE_STATUS (status);
  46df00:	e0bff717 	ldw	r2,-36(fp)
  46df04:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
  46df08:	e0bfff17 	ldw	r2,-4(fp)
  46df0c:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
  46df10:	e0bff217 	ldw	r2,-56(fp)
  46df14:	00007106 	br	46e0dc <OSQPend+0x36c>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
  46df18:	00801234 	movhi	r2,72
  46df1c:	10a64d04 	addi	r2,r2,-26316
  46df20:	10800017 	ldw	r2,0(r2)
  46df24:	00c01234 	movhi	r3,72
  46df28:	18e64d04 	addi	r3,r3,-26316
  46df2c:	18c00017 	ldw	r3,0(r3)
  46df30:	18c00c03 	ldbu	r3,48(r3)
  46df34:	18c00114 	ori	r3,r3,4
  46df38:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
  46df3c:	00801234 	movhi	r2,72
  46df40:	10a64d04 	addi	r2,r2,-26316
  46df44:	10800017 	ldw	r2,0(r2)
  46df48:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
  46df4c:	00801234 	movhi	r2,72
  46df50:	10a64d04 	addi	r2,r2,-26316
  46df54:	10800017 	ldw	r2,0(r2)
  46df58:	e0fffe0b 	ldhu	r3,-8(fp)
  46df5c:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
  46df60:	e13ffd17 	ldw	r4,-12(fp)
  46df64:	0469c140 	call	469c14 <OS_EventTaskWait>
  46df68:	e0bff317 	ldw	r2,-52(fp)
  46df6c:	e0bff815 	stw	r2,-32(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46df70:	0005303a 	rdctl	r2,status
  46df74:	e0bff915 	stw	r2,-28(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46df78:	e0fff917 	ldw	r3,-28(fp)
  46df7c:	00bfff84 	movi	r2,-2
  46df80:	1884703a 	and	r2,r3,r2
  46df84:	e0bff915 	stw	r2,-28(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46df88:	e0bff817 	ldw	r2,-32(fp)
  46df8c:	1080004c 	andi	r2,r2,1
  46df90:	e0fff917 	ldw	r3,-28(fp)
  46df94:	1884b03a 	or	r2,r3,r2
  46df98:	e0bff915 	stw	r2,-28(fp)
  
  NIOS2_WRITE_STATUS (status);
  46df9c:	e0bff917 	ldw	r2,-28(fp)
  46dfa0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
  46dfa4:	046a4980 	call	46a498 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46dfa8:	0005303a 	rdctl	r2,status
  46dfac:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46dfb0:	e0fffa17 	ldw	r3,-24(fp)
  46dfb4:	00bfff84 	movi	r2,-2
  46dfb8:	1884703a 	and	r2,r3,r2
  46dfbc:	1001703a 	wrctl	status,r2
  
  return context;
  46dfc0:	e0bffa17 	ldw	r2,-24(fp)
    OS_ENTER_CRITICAL();
  46dfc4:	e0bff315 	stw	r2,-52(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
  46dfc8:	00801234 	movhi	r2,72
  46dfcc:	10a64d04 	addi	r2,r2,-26316
  46dfd0:	10800017 	ldw	r2,0(r2)
  46dfd4:	10800c43 	ldbu	r2,49(r2)
  46dfd8:	10803fcc 	andi	r2,r2,255
  46dfdc:	10000326 	beq	r2,zero,46dfec <OSQPend+0x27c>
  46dfe0:	108000a0 	cmpeqi	r2,r2,2
  46dfe4:	1000091e 	bne	r2,zero,46e00c <OSQPend+0x29c>
  46dfe8:	00000d06 	br	46e020 <OSQPend+0x2b0>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
  46dfec:	00801234 	movhi	r2,72
  46dff0:	10a64d04 	addi	r2,r2,-26316
  46dff4:	10800017 	ldw	r2,0(r2)
  46dff8:	10800917 	ldw	r2,36(r2)
  46dffc:	e0bff215 	stw	r2,-56(fp)
            *perr =  OS_ERR_NONE;
  46e000:	e0bfff17 	ldw	r2,-4(fp)
  46e004:	10000005 	stb	zero,0(r2)
             break;
  46e008:	00001006 	br	46e04c <OSQPend+0x2dc>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
  46e00c:	e03ff215 	stw	zero,-56(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
  46e010:	e0bfff17 	ldw	r2,-4(fp)
  46e014:	00c00384 	movi	r3,14
  46e018:	10c00005 	stb	r3,0(r2)
             break;
  46e01c:	00000b06 	br	46e04c <OSQPend+0x2dc>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
  46e020:	00801234 	movhi	r2,72
  46e024:	10a64d04 	addi	r2,r2,-26316
  46e028:	10800017 	ldw	r2,0(r2)
  46e02c:	1009883a 	mov	r4,r2
  46e030:	e17ffd17 	ldw	r5,-12(fp)
  46e034:	0469e640 	call	469e64 <OS_EventTaskRemove>
             pmsg = (void *)0;
  46e038:	e03ff215 	stw	zero,-56(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
  46e03c:	e0bfff17 	ldw	r2,-4(fp)
  46e040:	00c00284 	movi	r3,10
  46e044:	10c00005 	stb	r3,0(r2)
             break;
  46e048:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
  46e04c:	00801234 	movhi	r2,72
  46e050:	10a64d04 	addi	r2,r2,-26316
  46e054:	10800017 	ldw	r2,0(r2)
  46e058:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
  46e05c:	00801234 	movhi	r2,72
  46e060:	10a64d04 	addi	r2,r2,-26316
  46e064:	10800017 	ldw	r2,0(r2)
  46e068:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
  46e06c:	00801234 	movhi	r2,72
  46e070:	10a64d04 	addi	r2,r2,-26316
  46e074:	10800017 	ldw	r2,0(r2)
  46e078:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
  46e07c:	00801234 	movhi	r2,72
  46e080:	10a64d04 	addi	r2,r2,-26316
  46e084:	10800017 	ldw	r2,0(r2)
  46e088:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
  46e08c:	00801234 	movhi	r2,72
  46e090:	10a64d04 	addi	r2,r2,-26316
  46e094:	10800017 	ldw	r2,0(r2)
  46e098:	10000915 	stw	zero,36(r2)
  46e09c:	e0bff317 	ldw	r2,-52(fp)
  46e0a0:	e0bffb15 	stw	r2,-20(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46e0a4:	0005303a 	rdctl	r2,status
  46e0a8:	e0bffc15 	stw	r2,-16(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46e0ac:	e0fffc17 	ldw	r3,-16(fp)
  46e0b0:	00bfff84 	movi	r2,-2
  46e0b4:	1884703a 	and	r2,r3,r2
  46e0b8:	e0bffc15 	stw	r2,-16(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46e0bc:	e0bffb17 	ldw	r2,-20(fp)
  46e0c0:	1080004c 	andi	r2,r2,1
  46e0c4:	e0fffc17 	ldw	r3,-16(fp)
  46e0c8:	1884b03a 	or	r2,r3,r2
  46e0cc:	e0bffc15 	stw	r2,-16(fp)
  
  NIOS2_WRITE_STATUS (status);
  46e0d0:	e0bffc17 	ldw	r2,-16(fp)
  46e0d4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
  46e0d8:	e0bff217 	ldw	r2,-56(fp)
}
  46e0dc:	e037883a 	mov	sp,fp
  46e0e0:	dfc00117 	ldw	ra,4(sp)
  46e0e4:	df000017 	ldw	fp,0(sp)
  46e0e8:	dec00204 	addi	sp,sp,8
  46e0ec:	f800283a 	ret

0046e0f0 <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
  46e0f0:	defff404 	addi	sp,sp,-48
  46e0f4:	dfc00b15 	stw	ra,44(sp)
  46e0f8:	df000a15 	stw	fp,40(sp)
  46e0fc:	df000a04 	addi	fp,sp,40
  46e100:	e13ffd15 	stw	r4,-12(fp)
  46e104:	2805883a 	mov	r2,r5
  46e108:	e1bfff15 	stw	r6,-4(fp)
  46e10c:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
  46e110:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
  46e114:	e0bfff17 	ldw	r2,-4(fp)
  46e118:	1000021e 	bne	r2,zero,46e124 <OSQPendAbort+0x34>
        return (0);
  46e11c:	0005883a 	mov	r2,zero
  46e120:	00006106 	br	46e2a8 <OSQPendAbort+0x1b8>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
  46e124:	e0bffd17 	ldw	r2,-12(fp)
  46e128:	1000051e 	bne	r2,zero,46e140 <OSQPendAbort+0x50>
        *perr = OS_ERR_PEVENT_NULL;
  46e12c:	e0bfff17 	ldw	r2,-4(fp)
  46e130:	00c00104 	movi	r3,4
  46e134:	10c00005 	stb	r3,0(r2)
        return (0);
  46e138:	0005883a 	mov	r2,zero
  46e13c:	00005a06 	br	46e2a8 <OSQPendAbort+0x1b8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
  46e140:	e0bffd17 	ldw	r2,-12(fp)
  46e144:	10800003 	ldbu	r2,0(r2)
  46e148:	10803fcc 	andi	r2,r2,255
  46e14c:	108000a0 	cmpeqi	r2,r2,2
  46e150:	1000051e 	bne	r2,zero,46e168 <OSQPendAbort+0x78>
        *perr = OS_ERR_EVENT_TYPE;
  46e154:	e0bfff17 	ldw	r2,-4(fp)
  46e158:	00c00044 	movi	r3,1
  46e15c:	10c00005 	stb	r3,0(r2)
        return (0);
  46e160:	0005883a 	mov	r2,zero
  46e164:	00005006 	br	46e2a8 <OSQPendAbort+0x1b8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46e168:	0005303a 	rdctl	r2,status
  46e16c:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46e170:	e0fff817 	ldw	r3,-32(fp)
  46e174:	00bfff84 	movi	r2,-2
  46e178:	1884703a 	and	r2,r3,r2
  46e17c:	1001703a 	wrctl	status,r2
  
  return context;
  46e180:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
  46e184:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
  46e188:	e0bffd17 	ldw	r2,-12(fp)
  46e18c:	10800283 	ldbu	r2,10(r2)
  46e190:	10803fcc 	andi	r2,r2,255
  46e194:	10003226 	beq	r2,zero,46e260 <OSQPendAbort+0x170>
        nbr_tasks = 0;
  46e198:	e03ff605 	stb	zero,-40(fp)
        switch (opt) {
  46e19c:	e0bffe03 	ldbu	r2,-8(fp)
  46e1a0:	10800060 	cmpeqi	r2,r2,1
  46e1a4:	10000a1e 	bne	r2,zero,46e1d0 <OSQPendAbort+0xe0>
  46e1a8:	00000f06 	br	46e1e8 <OSQPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
  46e1ac:	e13ffd17 	ldw	r4,-12(fp)
  46e1b0:	000b883a 	mov	r5,zero
  46e1b4:	01800104 	movi	r6,4
  46e1b8:	01c00084 	movi	r7,2
  46e1bc:	0469a7c0 	call	469a7c <OS_EventTaskRdy>
                     nbr_tasks++;
  46e1c0:	e0bff603 	ldbu	r2,-40(fp)
  46e1c4:	10800044 	addi	r2,r2,1
  46e1c8:	e0bff605 	stb	r2,-40(fp)
  46e1cc:	00000106 	br	46e1d4 <OSQPendAbort+0xe4>
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
  46e1d0:	0001883a 	nop
  46e1d4:	e0bffd17 	ldw	r2,-12(fp)
  46e1d8:	10800283 	ldbu	r2,10(r2)
  46e1dc:	10803fcc 	andi	r2,r2,255
  46e1e0:	103ff21e 	bne	r2,zero,46e1ac <OSQPendAbort+0xbc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
  46e1e4:	00000906 	br	46e20c <OSQPendAbort+0x11c>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
  46e1e8:	e13ffd17 	ldw	r4,-12(fp)
  46e1ec:	000b883a 	mov	r5,zero
  46e1f0:	01800104 	movi	r6,4
  46e1f4:	01c00084 	movi	r7,2
  46e1f8:	0469a7c0 	call	469a7c <OS_EventTaskRdy>
                 nbr_tasks++;
  46e1fc:	e0bff603 	ldbu	r2,-40(fp)
  46e200:	10800044 	addi	r2,r2,1
  46e204:	e0bff605 	stb	r2,-40(fp)
                 break;
  46e208:	0001883a 	nop
  46e20c:	e0bff717 	ldw	r2,-36(fp)
  46e210:	e0bff915 	stw	r2,-28(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46e214:	0005303a 	rdctl	r2,status
  46e218:	e0bffa15 	stw	r2,-24(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46e21c:	e0fffa17 	ldw	r3,-24(fp)
  46e220:	00bfff84 	movi	r2,-2
  46e224:	1884703a 	and	r2,r3,r2
  46e228:	e0bffa15 	stw	r2,-24(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46e22c:	e0bff917 	ldw	r2,-28(fp)
  46e230:	1080004c 	andi	r2,r2,1
  46e234:	e0fffa17 	ldw	r3,-24(fp)
  46e238:	1884b03a 	or	r2,r3,r2
  46e23c:	e0bffa15 	stw	r2,-24(fp)
  
  NIOS2_WRITE_STATUS (status);
  46e240:	e0bffa17 	ldw	r2,-24(fp)
  46e244:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
  46e248:	046a4980 	call	46a498 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
  46e24c:	e0bfff17 	ldw	r2,-4(fp)
  46e250:	00c00384 	movi	r3,14
  46e254:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
  46e258:	e0bff603 	ldbu	r2,-40(fp)
  46e25c:	00001206 	br	46e2a8 <OSQPendAbort+0x1b8>
  46e260:	e0bff717 	ldw	r2,-36(fp)
  46e264:	e0bffb15 	stw	r2,-20(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46e268:	0005303a 	rdctl	r2,status
  46e26c:	e0bffc15 	stw	r2,-16(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46e270:	e0fffc17 	ldw	r3,-16(fp)
  46e274:	00bfff84 	movi	r2,-2
  46e278:	1884703a 	and	r2,r3,r2
  46e27c:	e0bffc15 	stw	r2,-16(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46e280:	e0bffb17 	ldw	r2,-20(fp)
  46e284:	1080004c 	andi	r2,r2,1
  46e288:	e0fffc17 	ldw	r3,-16(fp)
  46e28c:	1884b03a 	or	r2,r3,r2
  46e290:	e0bffc15 	stw	r2,-16(fp)
  
  NIOS2_WRITE_STATUS (status);
  46e294:	e0bffc17 	ldw	r2,-16(fp)
  46e298:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
  46e29c:	e0bfff17 	ldw	r2,-4(fp)
  46e2a0:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
  46e2a4:	0005883a 	mov	r2,zero
}
  46e2a8:	e037883a 	mov	sp,fp
  46e2ac:	dfc00117 	ldw	ra,4(sp)
  46e2b0:	df000017 	ldw	fp,0(sp)
  46e2b4:	dec00204 	addi	sp,sp,8
  46e2b8:	f800283a 	ret

0046e2bc <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
  46e2bc:	defff304 	addi	sp,sp,-52
  46e2c0:	dfc00c15 	stw	ra,48(sp)
  46e2c4:	df000b15 	stw	fp,44(sp)
  46e2c8:	df000b04 	addi	fp,sp,44
  46e2cc:	e13ffe15 	stw	r4,-8(fp)
  46e2d0:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
  46e2d4:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
  46e2d8:	e0bffe17 	ldw	r2,-8(fp)
  46e2dc:	1000021e 	bne	r2,zero,46e2e8 <OSQPost+0x2c>
        return (OS_ERR_PEVENT_NULL);
  46e2e0:	00800104 	movi	r2,4
  46e2e4:	00006b06 	br	46e494 <OSQPost+0x1d8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
  46e2e8:	e0bffe17 	ldw	r2,-8(fp)
  46e2ec:	10800003 	ldbu	r2,0(r2)
  46e2f0:	10803fcc 	andi	r2,r2,255
  46e2f4:	108000a0 	cmpeqi	r2,r2,2
  46e2f8:	1000021e 	bne	r2,zero,46e304 <OSQPost+0x48>
        return (OS_ERR_EVENT_TYPE);
  46e2fc:	00800044 	movi	r2,1
  46e300:	00006406 	br	46e494 <OSQPost+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46e304:	0005303a 	rdctl	r2,status
  46e308:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46e30c:	e0fff717 	ldw	r3,-36(fp)
  46e310:	00bfff84 	movi	r2,-2
  46e314:	1884703a 	and	r2,r3,r2
  46e318:	1001703a 	wrctl	status,r2
  
  return context;
  46e31c:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
  46e320:	e0bff515 	stw	r2,-44(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
  46e324:	e0bffe17 	ldw	r2,-8(fp)
  46e328:	10800283 	ldbu	r2,10(r2)
  46e32c:	10803fcc 	andi	r2,r2,255
  46e330:	10001726 	beq	r2,zero,46e390 <OSQPost+0xd4>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
  46e334:	e13ffe17 	ldw	r4,-8(fp)
  46e338:	e17fff17 	ldw	r5,-4(fp)
  46e33c:	01800104 	movi	r6,4
  46e340:	000f883a 	mov	r7,zero
  46e344:	0469a7c0 	call	469a7c <OS_EventTaskRdy>
  46e348:	e0bff517 	ldw	r2,-44(fp)
  46e34c:	e0bff815 	stw	r2,-32(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46e350:	0005303a 	rdctl	r2,status
  46e354:	e0bff915 	stw	r2,-28(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46e358:	e0fff917 	ldw	r3,-28(fp)
  46e35c:	00bfff84 	movi	r2,-2
  46e360:	1884703a 	and	r2,r3,r2
  46e364:	e0bff915 	stw	r2,-28(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46e368:	e0bff817 	ldw	r2,-32(fp)
  46e36c:	1080004c 	andi	r2,r2,1
  46e370:	e0fff917 	ldw	r3,-28(fp)
  46e374:	1884b03a 	or	r2,r3,r2
  46e378:	e0bff915 	stw	r2,-28(fp)
  
  NIOS2_WRITE_STATUS (status);
  46e37c:	e0bff917 	ldw	r2,-28(fp)
  46e380:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
  46e384:	046a4980 	call	46a498 <OS_Sched>
        return (OS_ERR_NONE);
  46e388:	0005883a 	mov	r2,zero
  46e38c:	00004106 	br	46e494 <OSQPost+0x1d8>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
  46e390:	e0bffe17 	ldw	r2,-8(fp)
  46e394:	10800117 	ldw	r2,4(r2)
  46e398:	e0bff615 	stw	r2,-40(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
  46e39c:	e0bff617 	ldw	r2,-40(fp)
  46e3a0:	10c0058b 	ldhu	r3,22(r2)
  46e3a4:	e0bff617 	ldw	r2,-40(fp)
  46e3a8:	1080050b 	ldhu	r2,20(r2)
  46e3ac:	18ffffcc 	andi	r3,r3,65535
  46e3b0:	10bfffcc 	andi	r2,r2,65535
  46e3b4:	18801136 	bltu	r3,r2,46e3fc <OSQPost+0x140>
  46e3b8:	e0bff517 	ldw	r2,-44(fp)
  46e3bc:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46e3c0:	0005303a 	rdctl	r2,status
  46e3c4:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46e3c8:	e0fffb17 	ldw	r3,-20(fp)
  46e3cc:	00bfff84 	movi	r2,-2
  46e3d0:	1884703a 	and	r2,r3,r2
  46e3d4:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46e3d8:	e0bffa17 	ldw	r2,-24(fp)
  46e3dc:	1080004c 	andi	r2,r2,1
  46e3e0:	e0fffb17 	ldw	r3,-20(fp)
  46e3e4:	1884b03a 	or	r2,r3,r2
  46e3e8:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
  46e3ec:	e0bffb17 	ldw	r2,-20(fp)
  46e3f0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
  46e3f4:	00800784 	movi	r2,30
  46e3f8:	00002606 	br	46e494 <OSQPost+0x1d8>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
  46e3fc:	e0bff617 	ldw	r2,-40(fp)
  46e400:	10800317 	ldw	r2,12(r2)
  46e404:	e0ffff17 	ldw	r3,-4(fp)
  46e408:	10c00015 	stw	r3,0(r2)
  46e40c:	10c00104 	addi	r3,r2,4
  46e410:	e0bff617 	ldw	r2,-40(fp)
  46e414:	10c00315 	stw	r3,12(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
  46e418:	e0bff617 	ldw	r2,-40(fp)
  46e41c:	1080058b 	ldhu	r2,22(r2)
  46e420:	10800044 	addi	r2,r2,1
  46e424:	1007883a 	mov	r3,r2
  46e428:	e0bff617 	ldw	r2,-40(fp)
  46e42c:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
  46e430:	e0bff617 	ldw	r2,-40(fp)
  46e434:	10c00317 	ldw	r3,12(r2)
  46e438:	e0bff617 	ldw	r2,-40(fp)
  46e43c:	10800217 	ldw	r2,8(r2)
  46e440:	1880041e 	bne	r3,r2,46e454 <OSQPost+0x198>
        pq->OSQIn = pq->OSQStart;
  46e444:	e0bff617 	ldw	r2,-40(fp)
  46e448:	10c00117 	ldw	r3,4(r2)
  46e44c:	e0bff617 	ldw	r2,-40(fp)
  46e450:	10c00315 	stw	r3,12(r2)
  46e454:	e0bff517 	ldw	r2,-44(fp)
  46e458:	e0bffc15 	stw	r2,-16(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46e45c:	0005303a 	rdctl	r2,status
  46e460:	e0bffd15 	stw	r2,-12(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46e464:	e0fffd17 	ldw	r3,-12(fp)
  46e468:	00bfff84 	movi	r2,-2
  46e46c:	1884703a 	and	r2,r3,r2
  46e470:	e0bffd15 	stw	r2,-12(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46e474:	e0bffc17 	ldw	r2,-16(fp)
  46e478:	1080004c 	andi	r2,r2,1
  46e47c:	e0fffd17 	ldw	r3,-12(fp)
  46e480:	1884b03a 	or	r2,r3,r2
  46e484:	e0bffd15 	stw	r2,-12(fp)
  
  NIOS2_WRITE_STATUS (status);
  46e488:	e0bffd17 	ldw	r2,-12(fp)
  46e48c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
  46e490:	0005883a 	mov	r2,zero
}
  46e494:	e037883a 	mov	sp,fp
  46e498:	dfc00117 	ldw	ra,4(sp)
  46e49c:	df000017 	ldw	fp,0(sp)
  46e4a0:	dec00204 	addi	sp,sp,8
  46e4a4:	f800283a 	ret

0046e4a8 <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
  46e4a8:	defff304 	addi	sp,sp,-52
  46e4ac:	dfc00c15 	stw	ra,48(sp)
  46e4b0:	df000b15 	stw	fp,44(sp)
  46e4b4:	df000b04 	addi	fp,sp,44
  46e4b8:	e13ffe15 	stw	r4,-8(fp)
  46e4bc:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
  46e4c0:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
  46e4c4:	e0bffe17 	ldw	r2,-8(fp)
  46e4c8:	1000021e 	bne	r2,zero,46e4d4 <OSQPostFront+0x2c>
        return (OS_ERR_PEVENT_NULL);
  46e4cc:	00800104 	movi	r2,4
  46e4d0:	00006d06 	br	46e688 <OSQPostFront+0x1e0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
  46e4d4:	e0bffe17 	ldw	r2,-8(fp)
  46e4d8:	10800003 	ldbu	r2,0(r2)
  46e4dc:	10803fcc 	andi	r2,r2,255
  46e4e0:	108000a0 	cmpeqi	r2,r2,2
  46e4e4:	1000021e 	bne	r2,zero,46e4f0 <OSQPostFront+0x48>
        return (OS_ERR_EVENT_TYPE);
  46e4e8:	00800044 	movi	r2,1
  46e4ec:	00006606 	br	46e688 <OSQPostFront+0x1e0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46e4f0:	0005303a 	rdctl	r2,status
  46e4f4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46e4f8:	e0fff717 	ldw	r3,-36(fp)
  46e4fc:	00bfff84 	movi	r2,-2
  46e500:	1884703a 	and	r2,r3,r2
  46e504:	1001703a 	wrctl	status,r2
  
  return context;
  46e508:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
  46e50c:	e0bff515 	stw	r2,-44(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
  46e510:	e0bffe17 	ldw	r2,-8(fp)
  46e514:	10800283 	ldbu	r2,10(r2)
  46e518:	10803fcc 	andi	r2,r2,255
  46e51c:	10001726 	beq	r2,zero,46e57c <OSQPostFront+0xd4>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
  46e520:	e13ffe17 	ldw	r4,-8(fp)
  46e524:	e17fff17 	ldw	r5,-4(fp)
  46e528:	01800104 	movi	r6,4
  46e52c:	000f883a 	mov	r7,zero
  46e530:	0469a7c0 	call	469a7c <OS_EventTaskRdy>
  46e534:	e0bff517 	ldw	r2,-44(fp)
  46e538:	e0bff815 	stw	r2,-32(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46e53c:	0005303a 	rdctl	r2,status
  46e540:	e0bff915 	stw	r2,-28(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46e544:	e0fff917 	ldw	r3,-28(fp)
  46e548:	00bfff84 	movi	r2,-2
  46e54c:	1884703a 	and	r2,r3,r2
  46e550:	e0bff915 	stw	r2,-28(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46e554:	e0bff817 	ldw	r2,-32(fp)
  46e558:	1080004c 	andi	r2,r2,1
  46e55c:	e0fff917 	ldw	r3,-28(fp)
  46e560:	1884b03a 	or	r2,r3,r2
  46e564:	e0bff915 	stw	r2,-28(fp)
  
  NIOS2_WRITE_STATUS (status);
  46e568:	e0bff917 	ldw	r2,-28(fp)
  46e56c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
  46e570:	046a4980 	call	46a498 <OS_Sched>
        return (OS_ERR_NONE);
  46e574:	0005883a 	mov	r2,zero
  46e578:	00004306 	br	46e688 <OSQPostFront+0x1e0>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
  46e57c:	e0bffe17 	ldw	r2,-8(fp)
  46e580:	10800117 	ldw	r2,4(r2)
  46e584:	e0bff615 	stw	r2,-40(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
  46e588:	e0bff617 	ldw	r2,-40(fp)
  46e58c:	10c0058b 	ldhu	r3,22(r2)
  46e590:	e0bff617 	ldw	r2,-40(fp)
  46e594:	1080050b 	ldhu	r2,20(r2)
  46e598:	18ffffcc 	andi	r3,r3,65535
  46e59c:	10bfffcc 	andi	r2,r2,65535
  46e5a0:	18801136 	bltu	r3,r2,46e5e8 <OSQPostFront+0x140>
  46e5a4:	e0bff517 	ldw	r2,-44(fp)
  46e5a8:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46e5ac:	0005303a 	rdctl	r2,status
  46e5b0:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46e5b4:	e0fffb17 	ldw	r3,-20(fp)
  46e5b8:	00bfff84 	movi	r2,-2
  46e5bc:	1884703a 	and	r2,r3,r2
  46e5c0:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46e5c4:	e0bffa17 	ldw	r2,-24(fp)
  46e5c8:	1080004c 	andi	r2,r2,1
  46e5cc:	e0fffb17 	ldw	r3,-20(fp)
  46e5d0:	1884b03a 	or	r2,r3,r2
  46e5d4:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
  46e5d8:	e0bffb17 	ldw	r2,-20(fp)
  46e5dc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
  46e5e0:	00800784 	movi	r2,30
  46e5e4:	00002806 	br	46e688 <OSQPostFront+0x1e0>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
  46e5e8:	e0bff617 	ldw	r2,-40(fp)
  46e5ec:	10c00417 	ldw	r3,16(r2)
  46e5f0:	e0bff617 	ldw	r2,-40(fp)
  46e5f4:	10800117 	ldw	r2,4(r2)
  46e5f8:	1880041e 	bne	r3,r2,46e60c <OSQPostFront+0x164>
        pq->OSQOut = pq->OSQEnd;
  46e5fc:	e0bff617 	ldw	r2,-40(fp)
  46e600:	10c00217 	ldw	r3,8(r2)
  46e604:	e0bff617 	ldw	r2,-40(fp)
  46e608:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
  46e60c:	e0bff617 	ldw	r2,-40(fp)
  46e610:	10800417 	ldw	r2,16(r2)
  46e614:	10ffff04 	addi	r3,r2,-4
  46e618:	e0bff617 	ldw	r2,-40(fp)
  46e61c:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
  46e620:	e0bff617 	ldw	r2,-40(fp)
  46e624:	10800417 	ldw	r2,16(r2)
  46e628:	e0ffff17 	ldw	r3,-4(fp)
  46e62c:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
  46e630:	e0bff617 	ldw	r2,-40(fp)
  46e634:	1080058b 	ldhu	r2,22(r2)
  46e638:	10800044 	addi	r2,r2,1
  46e63c:	1007883a 	mov	r3,r2
  46e640:	e0bff617 	ldw	r2,-40(fp)
  46e644:	10c0058d 	sth	r3,22(r2)
  46e648:	e0bff517 	ldw	r2,-44(fp)
  46e64c:	e0bffc15 	stw	r2,-16(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46e650:	0005303a 	rdctl	r2,status
  46e654:	e0bffd15 	stw	r2,-12(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46e658:	e0fffd17 	ldw	r3,-12(fp)
  46e65c:	00bfff84 	movi	r2,-2
  46e660:	1884703a 	and	r2,r3,r2
  46e664:	e0bffd15 	stw	r2,-12(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46e668:	e0bffc17 	ldw	r2,-16(fp)
  46e66c:	1080004c 	andi	r2,r2,1
  46e670:	e0fffd17 	ldw	r3,-12(fp)
  46e674:	1884b03a 	or	r2,r3,r2
  46e678:	e0bffd15 	stw	r2,-12(fp)
  
  NIOS2_WRITE_STATUS (status);
  46e67c:	e0bffd17 	ldw	r2,-12(fp)
  46e680:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
  46e684:	0005883a 	mov	r2,zero
}
  46e688:	e037883a 	mov	sp,fp
  46e68c:	dfc00117 	ldw	ra,4(sp)
  46e690:	df000017 	ldw	fp,0(sp)
  46e694:	dec00204 	addi	sp,sp,8
  46e698:	f800283a 	ret

0046e69c <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
  46e69c:	defff204 	addi	sp,sp,-56
  46e6a0:	dfc00d15 	stw	ra,52(sp)
  46e6a4:	df000c15 	stw	fp,48(sp)
  46e6a8:	df000c04 	addi	fp,sp,48
  46e6ac:	e13ffd15 	stw	r4,-12(fp)
  46e6b0:	e17ffe15 	stw	r5,-8(fp)
  46e6b4:	3005883a 	mov	r2,r6
  46e6b8:	e0bfff05 	stb	r2,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
  46e6bc:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
  46e6c0:	e0bffd17 	ldw	r2,-12(fp)
  46e6c4:	1000021e 	bne	r2,zero,46e6d0 <OSQPostOpt+0x34>
        return (OS_ERR_PEVENT_NULL);
  46e6c8:	00800104 	movi	r2,4
  46e6cc:	00009206 	br	46e918 <OSQPostOpt+0x27c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
  46e6d0:	e0bffd17 	ldw	r2,-12(fp)
  46e6d4:	10800003 	ldbu	r2,0(r2)
  46e6d8:	10803fcc 	andi	r2,r2,255
  46e6dc:	108000a0 	cmpeqi	r2,r2,2
  46e6e0:	1000021e 	bne	r2,zero,46e6ec <OSQPostOpt+0x50>
        return (OS_ERR_EVENT_TYPE);
  46e6e4:	00800044 	movi	r2,1
  46e6e8:	00008b06 	br	46e918 <OSQPostOpt+0x27c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46e6ec:	0005303a 	rdctl	r2,status
  46e6f0:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46e6f4:	e0fff617 	ldw	r3,-40(fp)
  46e6f8:	00bfff84 	movi	r2,-2
  46e6fc:	1884703a 	and	r2,r3,r2
  46e700:	1001703a 	wrctl	status,r2
  
  return context;
  46e704:	e0bff617 	ldw	r2,-40(fp)
    }
    OS_ENTER_CRITICAL();
  46e708:	e0bff415 	stw	r2,-48(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
  46e70c:	e0bffd17 	ldw	r2,-12(fp)
  46e710:	10800283 	ldbu	r2,10(r2)
  46e714:	10803fcc 	andi	r2,r2,255
  46e718:	10002826 	beq	r2,zero,46e7bc <OSQPostOpt+0x120>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
  46e71c:	e0bfff03 	ldbu	r2,-4(fp)
  46e720:	1080004c 	andi	r2,r2,1
  46e724:	10000b26 	beq	r2,zero,46e754 <OSQPostOpt+0xb8>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
  46e728:	00000506 	br	46e740 <OSQPostOpt+0xa4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
  46e72c:	e13ffd17 	ldw	r4,-12(fp)
  46e730:	e17ffe17 	ldw	r5,-8(fp)
  46e734:	01800104 	movi	r6,4
  46e738:	000f883a 	mov	r7,zero
  46e73c:	0469a7c0 	call	469a7c <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
  46e740:	e0bffd17 	ldw	r2,-12(fp)
  46e744:	10800283 	ldbu	r2,10(r2)
  46e748:	10803fcc 	andi	r2,r2,255
  46e74c:	103ff71e 	bne	r2,zero,46e72c <OSQPostOpt+0x90>
  46e750:	00000506 	br	46e768 <OSQPostOpt+0xcc>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
  46e754:	e13ffd17 	ldw	r4,-12(fp)
  46e758:	e17ffe17 	ldw	r5,-8(fp)
  46e75c:	01800104 	movi	r6,4
  46e760:	000f883a 	mov	r7,zero
  46e764:	0469a7c0 	call	469a7c <OS_EventTaskRdy>
  46e768:	e0bff417 	ldw	r2,-48(fp)
  46e76c:	e0bff715 	stw	r2,-36(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46e770:	0005303a 	rdctl	r2,status
  46e774:	e0bff815 	stw	r2,-32(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46e778:	e0fff817 	ldw	r3,-32(fp)
  46e77c:	00bfff84 	movi	r2,-2
  46e780:	1884703a 	and	r2,r3,r2
  46e784:	e0bff815 	stw	r2,-32(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46e788:	e0bff717 	ldw	r2,-36(fp)
  46e78c:	1080004c 	andi	r2,r2,1
  46e790:	e0fff817 	ldw	r3,-32(fp)
  46e794:	1884b03a 	or	r2,r3,r2
  46e798:	e0bff815 	stw	r2,-32(fp)
  
  NIOS2_WRITE_STATUS (status);
  46e79c:	e0bff817 	ldw	r2,-32(fp)
  46e7a0:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
  46e7a4:	e0bfff03 	ldbu	r2,-4(fp)
  46e7a8:	1080010c 	andi	r2,r2,4
  46e7ac:	1000011e 	bne	r2,zero,46e7b4 <OSQPostOpt+0x118>
            OS_Sched();                               /* Find highest priority task ready to run       */
  46e7b0:	046a4980 	call	46a498 <OS_Sched>
        }
        return (OS_ERR_NONE);
  46e7b4:	0005883a 	mov	r2,zero
  46e7b8:	00005706 	br	46e918 <OSQPostOpt+0x27c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
  46e7bc:	e0bffd17 	ldw	r2,-12(fp)
  46e7c0:	10800117 	ldw	r2,4(r2)
  46e7c4:	e0bff515 	stw	r2,-44(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
  46e7c8:	e0bff517 	ldw	r2,-44(fp)
  46e7cc:	10c0058b 	ldhu	r3,22(r2)
  46e7d0:	e0bff517 	ldw	r2,-44(fp)
  46e7d4:	1080050b 	ldhu	r2,20(r2)
  46e7d8:	18ffffcc 	andi	r3,r3,65535
  46e7dc:	10bfffcc 	andi	r2,r2,65535
  46e7e0:	18801136 	bltu	r3,r2,46e828 <OSQPostOpt+0x18c>
  46e7e4:	e0bff417 	ldw	r2,-48(fp)
  46e7e8:	e0bff915 	stw	r2,-28(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46e7ec:	0005303a 	rdctl	r2,status
  46e7f0:	e0bffa15 	stw	r2,-24(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46e7f4:	e0fffa17 	ldw	r3,-24(fp)
  46e7f8:	00bfff84 	movi	r2,-2
  46e7fc:	1884703a 	and	r2,r3,r2
  46e800:	e0bffa15 	stw	r2,-24(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46e804:	e0bff917 	ldw	r2,-28(fp)
  46e808:	1080004c 	andi	r2,r2,1
  46e80c:	e0fffa17 	ldw	r3,-24(fp)
  46e810:	1884b03a 	or	r2,r3,r2
  46e814:	e0bffa15 	stw	r2,-24(fp)
  
  NIOS2_WRITE_STATUS (status);
  46e818:	e0bffa17 	ldw	r2,-24(fp)
  46e81c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
  46e820:	00800784 	movi	r2,30
  46e824:	00003c06 	br	46e918 <OSQPostOpt+0x27c>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
  46e828:	e0bfff03 	ldbu	r2,-4(fp)
  46e82c:	1080008c 	andi	r2,r2,2
  46e830:	10001326 	beq	r2,zero,46e880 <OSQPostOpt+0x1e4>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
  46e834:	e0bff517 	ldw	r2,-44(fp)
  46e838:	10c00417 	ldw	r3,16(r2)
  46e83c:	e0bff517 	ldw	r2,-44(fp)
  46e840:	10800117 	ldw	r2,4(r2)
  46e844:	1880041e 	bne	r3,r2,46e858 <OSQPostOpt+0x1bc>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
  46e848:	e0bff517 	ldw	r2,-44(fp)
  46e84c:	10c00217 	ldw	r3,8(r2)
  46e850:	e0bff517 	ldw	r2,-44(fp)
  46e854:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
  46e858:	e0bff517 	ldw	r2,-44(fp)
  46e85c:	10800417 	ldw	r2,16(r2)
  46e860:	10ffff04 	addi	r3,r2,-4
  46e864:	e0bff517 	ldw	r2,-44(fp)
  46e868:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
  46e86c:	e0bff517 	ldw	r2,-44(fp)
  46e870:	10800417 	ldw	r2,16(r2)
  46e874:	e0fffe17 	ldw	r3,-8(fp)
  46e878:	10c00015 	stw	r3,0(r2)
  46e87c:	00001006 	br	46e8c0 <OSQPostOpt+0x224>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
  46e880:	e0bff517 	ldw	r2,-44(fp)
  46e884:	10800317 	ldw	r2,12(r2)
  46e888:	e0fffe17 	ldw	r3,-8(fp)
  46e88c:	10c00015 	stw	r3,0(r2)
  46e890:	10c00104 	addi	r3,r2,4
  46e894:	e0bff517 	ldw	r2,-44(fp)
  46e898:	10c00315 	stw	r3,12(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
  46e89c:	e0bff517 	ldw	r2,-44(fp)
  46e8a0:	10c00317 	ldw	r3,12(r2)
  46e8a4:	e0bff517 	ldw	r2,-44(fp)
  46e8a8:	10800217 	ldw	r2,8(r2)
  46e8ac:	1880041e 	bne	r3,r2,46e8c0 <OSQPostOpt+0x224>
            pq->OSQIn = pq->OSQStart;
  46e8b0:	e0bff517 	ldw	r2,-44(fp)
  46e8b4:	10c00117 	ldw	r3,4(r2)
  46e8b8:	e0bff517 	ldw	r2,-44(fp)
  46e8bc:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
  46e8c0:	e0bff517 	ldw	r2,-44(fp)
  46e8c4:	1080058b 	ldhu	r2,22(r2)
  46e8c8:	10800044 	addi	r2,r2,1
  46e8cc:	1007883a 	mov	r3,r2
  46e8d0:	e0bff517 	ldw	r2,-44(fp)
  46e8d4:	10c0058d 	sth	r3,22(r2)
  46e8d8:	e0bff417 	ldw	r2,-48(fp)
  46e8dc:	e0bffb15 	stw	r2,-20(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46e8e0:	0005303a 	rdctl	r2,status
  46e8e4:	e0bffc15 	stw	r2,-16(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46e8e8:	e0fffc17 	ldw	r3,-16(fp)
  46e8ec:	00bfff84 	movi	r2,-2
  46e8f0:	1884703a 	and	r2,r3,r2
  46e8f4:	e0bffc15 	stw	r2,-16(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46e8f8:	e0bffb17 	ldw	r2,-20(fp)
  46e8fc:	1080004c 	andi	r2,r2,1
  46e900:	e0fffc17 	ldw	r3,-16(fp)
  46e904:	1884b03a 	or	r2,r3,r2
  46e908:	e0bffc15 	stw	r2,-16(fp)
  
  NIOS2_WRITE_STATUS (status);
  46e90c:	e0bffc17 	ldw	r2,-16(fp)
  46e910:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
  46e914:	0005883a 	mov	r2,zero
}
  46e918:	e037883a 	mov	sp,fp
  46e91c:	dfc00117 	ldw	ra,4(sp)
  46e920:	df000017 	ldw	fp,0(sp)
  46e924:	dec00204 	addi	sp,sp,8
  46e928:	f800283a 	ret

0046e92c <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
  46e92c:	defff504 	addi	sp,sp,-44
  46e930:	df000a15 	stw	fp,40(sp)
  46e934:	df000a04 	addi	fp,sp,40
  46e938:	e13ffe15 	stw	r4,-8(fp)
  46e93c:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
  46e940:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
  46e944:	e0bffe17 	ldw	r2,-8(fp)
  46e948:	1000021e 	bne	r2,zero,46e954 <OSQQuery+0x28>
        return (OS_ERR_PEVENT_NULL);
  46e94c:	00800104 	movi	r2,4
  46e950:	00005606 	br	46eaac <OSQQuery+0x180>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
  46e954:	e0bfff17 	ldw	r2,-4(fp)
  46e958:	1000021e 	bne	r2,zero,46e964 <OSQQuery+0x38>
        return (OS_ERR_PDATA_NULL);
  46e95c:	00800244 	movi	r2,9
  46e960:	00005206 	br	46eaac <OSQQuery+0x180>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
  46e964:	e0bffe17 	ldw	r2,-8(fp)
  46e968:	10800003 	ldbu	r2,0(r2)
  46e96c:	10803fcc 	andi	r2,r2,255
  46e970:	108000a0 	cmpeqi	r2,r2,2
  46e974:	1000021e 	bne	r2,zero,46e980 <OSQQuery+0x54>
        return (OS_ERR_EVENT_TYPE);
  46e978:	00800044 	movi	r2,1
  46e97c:	00004b06 	br	46eaac <OSQQuery+0x180>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46e980:	0005303a 	rdctl	r2,status
  46e984:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46e988:	e0fffb17 	ldw	r3,-20(fp)
  46e98c:	00bfff84 	movi	r2,-2
  46e990:	1884703a 	and	r2,r3,r2
  46e994:	1001703a 	wrctl	status,r2
  
  return context;
  46e998:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
  46e99c:	e0bff915 	stw	r2,-28(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
  46e9a0:	e0bffe17 	ldw	r2,-8(fp)
  46e9a4:	10c00283 	ldbu	r3,10(r2)
  46e9a8:	e0bfff17 	ldw	r2,-4(fp)
  46e9ac:	10c002c5 	stb	r3,11(r2)
    psrc                 = &pevent->OSEventTbl[0];
  46e9b0:	e0bffe17 	ldw	r2,-8(fp)
  46e9b4:	108002c4 	addi	r2,r2,11
  46e9b8:	e0bff715 	stw	r2,-36(fp)
    pdest                = &p_q_data->OSEventTbl[0];
  46e9bc:	e0bfff17 	ldw	r2,-4(fp)
  46e9c0:	10800204 	addi	r2,r2,8
  46e9c4:	e0bff815 	stw	r2,-32(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
  46e9c8:	e03ff605 	stb	zero,-40(fp)
  46e9cc:	00000d06 	br	46ea04 <OSQQuery+0xd8>
        *pdest++ = *psrc++;
  46e9d0:	e0bff717 	ldw	r2,-36(fp)
  46e9d4:	10c00003 	ldbu	r3,0(r2)
  46e9d8:	e0bff817 	ldw	r2,-32(fp)
  46e9dc:	10c00005 	stb	r3,0(r2)
  46e9e0:	e0bff817 	ldw	r2,-32(fp)
  46e9e4:	10800044 	addi	r2,r2,1
  46e9e8:	e0bff815 	stw	r2,-32(fp)
  46e9ec:	e0bff717 	ldw	r2,-36(fp)
  46e9f0:	10800044 	addi	r2,r2,1
  46e9f4:	e0bff715 	stw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
  46e9f8:	e0bff603 	ldbu	r2,-40(fp)
  46e9fc:	10800044 	addi	r2,r2,1
  46ea00:	e0bff605 	stb	r2,-40(fp)
  46ea04:	e0bff603 	ldbu	r2,-40(fp)
  46ea08:	108000f0 	cmpltui	r2,r2,3
  46ea0c:	103ff01e 	bne	r2,zero,46e9d0 <OSQQuery+0xa4>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
  46ea10:	e0bffe17 	ldw	r2,-8(fp)
  46ea14:	10800117 	ldw	r2,4(r2)
  46ea18:	e0bffa15 	stw	r2,-24(fp)
    if (pq->OSQEntries > 0) {
  46ea1c:	e0bffa17 	ldw	r2,-24(fp)
  46ea20:	1080058b 	ldhu	r2,22(r2)
  46ea24:	10bfffcc 	andi	r2,r2,65535
  46ea28:	10000626 	beq	r2,zero,46ea44 <OSQQuery+0x118>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
  46ea2c:	e0bffa17 	ldw	r2,-24(fp)
  46ea30:	10800417 	ldw	r2,16(r2)
  46ea34:	10c00017 	ldw	r3,0(r2)
  46ea38:	e0bfff17 	ldw	r2,-4(fp)
  46ea3c:	10c00015 	stw	r3,0(r2)
  46ea40:	00000206 	br	46ea4c <OSQQuery+0x120>
    } else {
        p_q_data->OSMsg = (void *)0;
  46ea44:	e0bfff17 	ldw	r2,-4(fp)
  46ea48:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
  46ea4c:	e0bffa17 	ldw	r2,-24(fp)
  46ea50:	10c0058b 	ldhu	r3,22(r2)
  46ea54:	e0bfff17 	ldw	r2,-4(fp)
  46ea58:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
  46ea5c:	e0bffa17 	ldw	r2,-24(fp)
  46ea60:	10c0050b 	ldhu	r3,20(r2)
  46ea64:	e0bfff17 	ldw	r2,-4(fp)
  46ea68:	10c0018d 	sth	r3,6(r2)
  46ea6c:	e0bff917 	ldw	r2,-28(fp)
  46ea70:	e0bffc15 	stw	r2,-16(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46ea74:	0005303a 	rdctl	r2,status
  46ea78:	e0bffd15 	stw	r2,-12(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46ea7c:	e0fffd17 	ldw	r3,-12(fp)
  46ea80:	00bfff84 	movi	r2,-2
  46ea84:	1884703a 	and	r2,r3,r2
  46ea88:	e0bffd15 	stw	r2,-12(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46ea8c:	e0bffc17 	ldw	r2,-16(fp)
  46ea90:	1080004c 	andi	r2,r2,1
  46ea94:	e0fffd17 	ldw	r3,-12(fp)
  46ea98:	1884b03a 	or	r2,r3,r2
  46ea9c:	e0bffd15 	stw	r2,-12(fp)
  
  NIOS2_WRITE_STATUS (status);
  46eaa0:	e0bffd17 	ldw	r2,-12(fp)
  46eaa4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
  46eaa8:	0005883a 	mov	r2,zero
}
  46eaac:	e037883a 	mov	sp,fp
  46eab0:	df000017 	ldw	fp,0(sp)
  46eab4:	dec00104 	addi	sp,sp,4
  46eab8:	f800283a 	ret

0046eabc <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
  46eabc:	defffb04 	addi	sp,sp,-20
  46eac0:	dfc00415 	stw	ra,16(sp)
  46eac4:	df000315 	stw	fp,12(sp)
  46eac8:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
  46eacc:	01001234 	movhi	r4,72
  46ead0:	212c8804 	addi	r4,r4,-19936
  46ead4:	01407804 	movi	r5,480
  46ead8:	046a3d80 	call	46a3d8 <OS_MemClr>
    pq1 = &OSQTbl[0];
  46eadc:	00801234 	movhi	r2,72
  46eae0:	10ac8804 	addi	r2,r2,-19936
  46eae4:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
  46eae8:	00801234 	movhi	r2,72
  46eaec:	10ac8e04 	addi	r2,r2,-19912
  46eaf0:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
  46eaf4:	e03ffd0d 	sth	zero,-12(fp)
  46eaf8:	00000c06 	br	46eb2c <OS_QInit+0x70>
        pq1->OSQPtr = pq2;
  46eafc:	e0bffe17 	ldw	r2,-8(fp)
  46eb00:	e0ffff17 	ldw	r3,-4(fp)
  46eb04:	10c00015 	stw	r3,0(r2)
        pq1++;
  46eb08:	e0bffe17 	ldw	r2,-8(fp)
  46eb0c:	10800604 	addi	r2,r2,24
  46eb10:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
  46eb14:	e0bfff17 	ldw	r2,-4(fp)
  46eb18:	10800604 	addi	r2,r2,24
  46eb1c:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
  46eb20:	e0bffd0b 	ldhu	r2,-12(fp)
  46eb24:	10800044 	addi	r2,r2,1
  46eb28:	e0bffd0d 	sth	r2,-12(fp)
  46eb2c:	e0bffd0b 	ldhu	r2,-12(fp)
  46eb30:	108004f0 	cmpltui	r2,r2,19
  46eb34:	103ff11e 	bne	r2,zero,46eafc <OS_QInit+0x40>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
  46eb38:	e0bffe17 	ldw	r2,-8(fp)
  46eb3c:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
  46eb40:	00801234 	movhi	r2,72
  46eb44:	10a64904 	addi	r2,r2,-26332
  46eb48:	00c01234 	movhi	r3,72
  46eb4c:	18ec8804 	addi	r3,r3,-19936
  46eb50:	10c00015 	stw	r3,0(r2)
#endif
}
  46eb54:	e037883a 	mov	sp,fp
  46eb58:	dfc00117 	ldw	ra,4(sp)
  46eb5c:	df000017 	ldw	fp,0(sp)
  46eb60:	dec00204 	addi	sp,sp,8
  46eb64:	f800283a 	ret

0046eb68 <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
  46eb68:	defff904 	addi	sp,sp,-28
  46eb6c:	df000615 	stw	fp,24(sp)
  46eb70:	df000604 	addi	fp,sp,24
  46eb74:	e13fff15 	stw	r4,-4(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
  46eb78:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
  46eb7c:	e0bfff17 	ldw	r2,-4(fp)
  46eb80:	1000021e 	bne	r2,zero,46eb8c <OSSemAccept+0x24>
        return (0);
  46eb84:	0005883a 	mov	r2,zero
  46eb88:	00002a06 	br	46ec34 <OSSemAccept+0xcc>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
  46eb8c:	e0bfff17 	ldw	r2,-4(fp)
  46eb90:	10800003 	ldbu	r2,0(r2)
  46eb94:	10803fcc 	andi	r2,r2,255
  46eb98:	108000e0 	cmpeqi	r2,r2,3
  46eb9c:	1000021e 	bne	r2,zero,46eba8 <OSSemAccept+0x40>
        return (0);
  46eba0:	0005883a 	mov	r2,zero
  46eba4:	00002306 	br	46ec34 <OSSemAccept+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46eba8:	0005303a 	rdctl	r2,status
  46ebac:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46ebb0:	e0fffc17 	ldw	r3,-16(fp)
  46ebb4:	00bfff84 	movi	r2,-2
  46ebb8:	1884703a 	and	r2,r3,r2
  46ebbc:	1001703a 	wrctl	status,r2
  
  return context;
  46ebc0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
  46ebc4:	e0bffa15 	stw	r2,-24(fp)
    cnt = pevent->OSEventCnt;
  46ebc8:	e0bfff17 	ldw	r2,-4(fp)
  46ebcc:	1080020b 	ldhu	r2,8(r2)
  46ebd0:	e0bffb0d 	sth	r2,-20(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
  46ebd4:	e0bffb0b 	ldhu	r2,-20(fp)
  46ebd8:	10000626 	beq	r2,zero,46ebf4 <OSSemAccept+0x8c>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
  46ebdc:	e0bfff17 	ldw	r2,-4(fp)
  46ebe0:	1080020b 	ldhu	r2,8(r2)
  46ebe4:	10bfffc4 	addi	r2,r2,-1
  46ebe8:	1007883a 	mov	r3,r2
  46ebec:	e0bfff17 	ldw	r2,-4(fp)
  46ebf0:	10c0020d 	sth	r3,8(r2)
  46ebf4:	e0bffa17 	ldw	r2,-24(fp)
  46ebf8:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46ebfc:	0005303a 	rdctl	r2,status
  46ec00:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46ec04:	e0fffe17 	ldw	r3,-8(fp)
  46ec08:	00bfff84 	movi	r2,-2
  46ec0c:	1884703a 	and	r2,r3,r2
  46ec10:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46ec14:	e0bffd17 	ldw	r2,-12(fp)
  46ec18:	1080004c 	andi	r2,r2,1
  46ec1c:	e0fffe17 	ldw	r3,-8(fp)
  46ec20:	1884b03a 	or	r2,r3,r2
  46ec24:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
  46ec28:	e0bffe17 	ldw	r2,-8(fp)
  46ec2c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
  46ec30:	e0bffb0b 	ldhu	r2,-20(fp)
}
  46ec34:	e037883a 	mov	sp,fp
  46ec38:	df000017 	ldw	fp,0(sp)
  46ec3c:	dec00104 	addi	sp,sp,4
  46ec40:	f800283a 	ret

0046ec44 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
  46ec44:	defff804 	addi	sp,sp,-32
  46ec48:	dfc00715 	stw	ra,28(sp)
  46ec4c:	df000615 	stw	fp,24(sp)
  46ec50:	df000604 	addi	fp,sp,24
  46ec54:	2005883a 	mov	r2,r4
  46ec58:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
  46ec5c:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
  46ec60:	00801234 	movhi	r2,72
  46ec64:	10a64c04 	addi	r2,r2,-26320
  46ec68:	10800003 	ldbu	r2,0(r2)
  46ec6c:	10803fcc 	andi	r2,r2,255
  46ec70:	10000226 	beq	r2,zero,46ec7c <OSSemCreate+0x38>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
  46ec74:	0005883a 	mov	r2,zero
  46ec78:	00003806 	br	46ed5c <OSSemCreate+0x118>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46ec7c:	0005303a 	rdctl	r2,status
  46ec80:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46ec84:	e0fffc17 	ldw	r3,-16(fp)
  46ec88:	00bfff84 	movi	r2,-2
  46ec8c:	1884703a 	and	r2,r3,r2
  46ec90:	1001703a 	wrctl	status,r2
  
  return context;
  46ec94:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
  46ec98:	e0bffa15 	stw	r2,-24(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
  46ec9c:	00801234 	movhi	r2,72
  46eca0:	10a64b04 	addi	r2,r2,-26324
  46eca4:	10800017 	ldw	r2,0(r2)
  46eca8:	e0bffb15 	stw	r2,-20(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
  46ecac:	00801234 	movhi	r2,72
  46ecb0:	10a64b04 	addi	r2,r2,-26324
  46ecb4:	10800017 	ldw	r2,0(r2)
  46ecb8:	10000726 	beq	r2,zero,46ecd8 <OSSemCreate+0x94>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
  46ecbc:	00801234 	movhi	r2,72
  46ecc0:	10a64b04 	addi	r2,r2,-26324
  46ecc4:	10800017 	ldw	r2,0(r2)
  46ecc8:	10c00117 	ldw	r3,4(r2)
  46eccc:	00801234 	movhi	r2,72
  46ecd0:	10a64b04 	addi	r2,r2,-26324
  46ecd4:	10c00015 	stw	r3,0(r2)
  46ecd8:	e0bffa17 	ldw	r2,-24(fp)
  46ecdc:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46ece0:	0005303a 	rdctl	r2,status
  46ece4:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46ece8:	e0fffe17 	ldw	r3,-8(fp)
  46ecec:	00bfff84 	movi	r2,-2
  46ecf0:	1884703a 	and	r2,r3,r2
  46ecf4:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46ecf8:	e0bffd17 	ldw	r2,-12(fp)
  46ecfc:	1080004c 	andi	r2,r2,1
  46ed00:	e0fffe17 	ldw	r3,-8(fp)
  46ed04:	1884b03a 	or	r2,r3,r2
  46ed08:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
  46ed0c:	e0bffe17 	ldw	r2,-8(fp)
  46ed10:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
  46ed14:	e0bffb17 	ldw	r2,-20(fp)
  46ed18:	10000f26 	beq	r2,zero,46ed58 <OSSemCreate+0x114>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
  46ed1c:	e0bffb17 	ldw	r2,-20(fp)
  46ed20:	00c000c4 	movi	r3,3
  46ed24:	10c00005 	stb	r3,0(r2)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
  46ed28:	e0bffb17 	ldw	r2,-20(fp)
  46ed2c:	e0ffff0b 	ldhu	r3,-4(fp)
  46ed30:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
  46ed34:	e0bffb17 	ldw	r2,-20(fp)
  46ed38:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
  46ed3c:	e0bffb17 	ldw	r2,-20(fp)
  46ed40:	00c00fc4 	movi	r3,63
  46ed44:	10c00385 	stb	r3,14(r2)
        pevent->OSEventName[1] = OS_ASCII_NUL;
  46ed48:	e0bffb17 	ldw	r2,-20(fp)
  46ed4c:	100003c5 	stb	zero,15(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
  46ed50:	e13ffb17 	ldw	r4,-20(fp)
  46ed54:	046a00c0 	call	46a00c <OS_EventWaitListInit>
    }
    return (pevent);
  46ed58:	e0bffb17 	ldw	r2,-20(fp)
}
  46ed5c:	e037883a 	mov	sp,fp
  46ed60:	dfc00117 	ldw	ra,4(sp)
  46ed64:	df000017 	ldw	fp,0(sp)
  46ed68:	dec00204 	addi	sp,sp,8
  46ed6c:	f800283a 	ret

0046ed70 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
  46ed70:	deffef04 	addi	sp,sp,-68
  46ed74:	dfc01015 	stw	ra,64(sp)
  46ed78:	df000f15 	stw	fp,60(sp)
  46ed7c:	df000f04 	addi	fp,sp,60
  46ed80:	e13ffd15 	stw	r4,-12(fp)
  46ed84:	2805883a 	mov	r2,r5
  46ed88:	e1bfff15 	stw	r6,-4(fp)
  46ed8c:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
  46ed90:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
  46ed94:	e0bfff17 	ldw	r2,-4(fp)
  46ed98:	1000021e 	bne	r2,zero,46eda4 <OSSemDel+0x34>
        return (pevent);
  46ed9c:	e0bffd17 	ldw	r2,-12(fp)
  46eda0:	0000b606 	br	46f07c <OSSemDel+0x30c>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
  46eda4:	e0bffd17 	ldw	r2,-12(fp)
  46eda8:	1000051e 	bne	r2,zero,46edc0 <OSSemDel+0x50>
        *perr = OS_ERR_PEVENT_NULL;
  46edac:	e0bfff17 	ldw	r2,-4(fp)
  46edb0:	00c00104 	movi	r3,4
  46edb4:	10c00005 	stb	r3,0(r2)
        return (pevent);
  46edb8:	e0bffd17 	ldw	r2,-12(fp)
  46edbc:	0000af06 	br	46f07c <OSSemDel+0x30c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
  46edc0:	e0bffd17 	ldw	r2,-12(fp)
  46edc4:	10800003 	ldbu	r2,0(r2)
  46edc8:	10803fcc 	andi	r2,r2,255
  46edcc:	108000e0 	cmpeqi	r2,r2,3
  46edd0:	1000051e 	bne	r2,zero,46ede8 <OSSemDel+0x78>
        *perr = OS_ERR_EVENT_TYPE;
  46edd4:	e0bfff17 	ldw	r2,-4(fp)
  46edd8:	00c00044 	movi	r3,1
  46eddc:	10c00005 	stb	r3,0(r2)
        return (pevent);
  46ede0:	e0bffd17 	ldw	r2,-12(fp)
  46ede4:	0000a506 	br	46f07c <OSSemDel+0x30c>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
  46ede8:	00801234 	movhi	r2,72
  46edec:	10a64c04 	addi	r2,r2,-26320
  46edf0:	10800003 	ldbu	r2,0(r2)
  46edf4:	10803fcc 	andi	r2,r2,255
  46edf8:	10000526 	beq	r2,zero,46ee10 <OSSemDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
  46edfc:	e0bfff17 	ldw	r2,-4(fp)
  46ee00:	00c003c4 	movi	r3,15
  46ee04:	10c00005 	stb	r3,0(r2)
        return (pevent);
  46ee08:	e0bffd17 	ldw	r2,-12(fp)
  46ee0c:	00009b06 	br	46f07c <OSSemDel+0x30c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46ee10:	0005303a 	rdctl	r2,status
  46ee14:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46ee18:	e0fff417 	ldw	r3,-48(fp)
  46ee1c:	00bfff84 	movi	r2,-2
  46ee20:	1884703a 	and	r2,r3,r2
  46ee24:	1001703a 	wrctl	status,r2
  
  return context;
  46ee28:	e0bff417 	ldw	r2,-48(fp)
    }
    OS_ENTER_CRITICAL();
  46ee2c:	e0bff315 	stw	r2,-52(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
  46ee30:	e0bffd17 	ldw	r2,-12(fp)
  46ee34:	10800283 	ldbu	r2,10(r2)
  46ee38:	10803fcc 	andi	r2,r2,255
  46ee3c:	10000326 	beq	r2,zero,46ee4c <OSSemDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
  46ee40:	00800044 	movi	r2,1
  46ee44:	e0bff105 	stb	r2,-60(fp)
  46ee48:	00000106 	br	46ee50 <OSSemDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
  46ee4c:	e03ff105 	stb	zero,-60(fp)
    }
    switch (opt) {
  46ee50:	e0bffe03 	ldbu	r2,-8(fp)
  46ee54:	10000326 	beq	r2,zero,46ee64 <OSSemDel+0xf4>
  46ee58:	10800060 	cmpeqi	r2,r2,1
  46ee5c:	1000431e 	bne	r2,zero,46ef6c <OSSemDel+0x1fc>
  46ee60:	00007006 	br	46f024 <OSSemDel+0x2b4>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
  46ee64:	e0bff103 	ldbu	r2,-60(fp)
  46ee68:	1000251e 	bne	r2,zero,46ef00 <OSSemDel+0x190>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
  46ee6c:	e0bffd17 	ldw	r2,-12(fp)
  46ee70:	00c00fc4 	movi	r3,63
  46ee74:	10c00385 	stb	r3,14(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
  46ee78:	e0bffd17 	ldw	r2,-12(fp)
  46ee7c:	100003c5 	stb	zero,15(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
  46ee80:	e0bffd17 	ldw	r2,-12(fp)
  46ee84:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
  46ee88:	00801234 	movhi	r2,72
  46ee8c:	10a64b04 	addi	r2,r2,-26324
  46ee90:	10c00017 	ldw	r3,0(r2)
  46ee94:	e0bffd17 	ldw	r2,-12(fp)
  46ee98:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
  46ee9c:	e0bffd17 	ldw	r2,-12(fp)
  46eea0:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
  46eea4:	00801234 	movhi	r2,72
  46eea8:	10a64b04 	addi	r2,r2,-26324
  46eeac:	e0fffd17 	ldw	r3,-12(fp)
  46eeb0:	10c00015 	stw	r3,0(r2)
  46eeb4:	e0bff317 	ldw	r2,-52(fp)
  46eeb8:	e0bff515 	stw	r2,-44(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46eebc:	0005303a 	rdctl	r2,status
  46eec0:	e0bff615 	stw	r2,-40(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46eec4:	e0fff617 	ldw	r3,-40(fp)
  46eec8:	00bfff84 	movi	r2,-2
  46eecc:	1884703a 	and	r2,r3,r2
  46eed0:	e0bff615 	stw	r2,-40(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46eed4:	e0bff517 	ldw	r2,-44(fp)
  46eed8:	1080004c 	andi	r2,r2,1
  46eedc:	e0fff617 	ldw	r3,-40(fp)
  46eee0:	1884b03a 	or	r2,r3,r2
  46eee4:	e0bff615 	stw	r2,-40(fp)
  
  NIOS2_WRITE_STATUS (status);
  46eee8:	e0bff617 	ldw	r2,-40(fp)
  46eeec:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
  46eef0:	e0bfff17 	ldw	r2,-4(fp)
  46eef4:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
  46eef8:	e03ff215 	stw	zero,-56(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
  46eefc:	00005e06 	br	46f078 <OSSemDel+0x308>
  46ef00:	e0bff317 	ldw	r2,-52(fp)
  46ef04:	e0bff715 	stw	r2,-36(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46ef08:	0005303a 	rdctl	r2,status
  46ef0c:	e0bff815 	stw	r2,-32(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46ef10:	e0fff817 	ldw	r3,-32(fp)
  46ef14:	00bfff84 	movi	r2,-2
  46ef18:	1884703a 	and	r2,r3,r2
  46ef1c:	e0bff815 	stw	r2,-32(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46ef20:	e0bff717 	ldw	r2,-36(fp)
  46ef24:	1080004c 	andi	r2,r2,1
  46ef28:	e0fff817 	ldw	r3,-32(fp)
  46ef2c:	1884b03a 	or	r2,r3,r2
  46ef30:	e0bff815 	stw	r2,-32(fp)
  
  NIOS2_WRITE_STATUS (status);
  46ef34:	e0bff817 	ldw	r2,-32(fp)
  46ef38:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
  46ef3c:	e0bfff17 	ldw	r2,-4(fp)
  46ef40:	00c01244 	movi	r3,73
  46ef44:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
  46ef48:	e0bffd17 	ldw	r2,-12(fp)
  46ef4c:	e0bff215 	stw	r2,-56(fp)
             }
             break;
  46ef50:	00004906 	br	46f078 <OSSemDel+0x308>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
  46ef54:	e13ffd17 	ldw	r4,-12(fp)
  46ef58:	000b883a 	mov	r5,zero
  46ef5c:	01800044 	movi	r6,1
  46ef60:	000f883a 	mov	r7,zero
  46ef64:	0469a7c0 	call	469a7c <OS_EventTaskRdy>
  46ef68:	00000106 	br	46ef70 <OSSemDel+0x200>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
  46ef6c:	0001883a 	nop
  46ef70:	e0bffd17 	ldw	r2,-12(fp)
  46ef74:	10800283 	ldbu	r2,10(r2)
  46ef78:	10803fcc 	andi	r2,r2,255
  46ef7c:	103ff51e 	bne	r2,zero,46ef54 <OSSemDel+0x1e4>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
  46ef80:	e0bffd17 	ldw	r2,-12(fp)
  46ef84:	00c00fc4 	movi	r3,63
  46ef88:	10c00385 	stb	r3,14(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
  46ef8c:	e0bffd17 	ldw	r2,-12(fp)
  46ef90:	100003c5 	stb	zero,15(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
  46ef94:	e0bffd17 	ldw	r2,-12(fp)
  46ef98:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
  46ef9c:	00801234 	movhi	r2,72
  46efa0:	10a64b04 	addi	r2,r2,-26324
  46efa4:	10c00017 	ldw	r3,0(r2)
  46efa8:	e0bffd17 	ldw	r2,-12(fp)
  46efac:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
  46efb0:	e0bffd17 	ldw	r2,-12(fp)
  46efb4:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
  46efb8:	00801234 	movhi	r2,72
  46efbc:	10a64b04 	addi	r2,r2,-26324
  46efc0:	e0fffd17 	ldw	r3,-12(fp)
  46efc4:	10c00015 	stw	r3,0(r2)
  46efc8:	e0bff317 	ldw	r2,-52(fp)
  46efcc:	e0bff915 	stw	r2,-28(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46efd0:	0005303a 	rdctl	r2,status
  46efd4:	e0bffa15 	stw	r2,-24(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46efd8:	e0fffa17 	ldw	r3,-24(fp)
  46efdc:	00bfff84 	movi	r2,-2
  46efe0:	1884703a 	and	r2,r3,r2
  46efe4:	e0bffa15 	stw	r2,-24(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46efe8:	e0bff917 	ldw	r2,-28(fp)
  46efec:	1080004c 	andi	r2,r2,1
  46eff0:	e0fffa17 	ldw	r3,-24(fp)
  46eff4:	1884b03a 	or	r2,r3,r2
  46eff8:	e0bffa15 	stw	r2,-24(fp)
  
  NIOS2_WRITE_STATUS (status);
  46effc:	e0bffa17 	ldw	r2,-24(fp)
  46f000:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
  46f004:	e0bff103 	ldbu	r2,-60(fp)
  46f008:	10800058 	cmpnei	r2,r2,1
  46f00c:	1000011e 	bne	r2,zero,46f014 <OSSemDel+0x2a4>
                 OS_Sched();                               /* Find highest priority task ready to run  */
  46f010:	046a4980 	call	46a498 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
  46f014:	e0bfff17 	ldw	r2,-4(fp)
  46f018:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
  46f01c:	e03ff215 	stw	zero,-56(fp)
             break;
  46f020:	00001506 	br	46f078 <OSSemDel+0x308>
  46f024:	e0bff317 	ldw	r2,-52(fp)
  46f028:	e0bffb15 	stw	r2,-20(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46f02c:	0005303a 	rdctl	r2,status
  46f030:	e0bffc15 	stw	r2,-16(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46f034:	e0fffc17 	ldw	r3,-16(fp)
  46f038:	00bfff84 	movi	r2,-2
  46f03c:	1884703a 	and	r2,r3,r2
  46f040:	e0bffc15 	stw	r2,-16(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46f044:	e0bffb17 	ldw	r2,-20(fp)
  46f048:	1080004c 	andi	r2,r2,1
  46f04c:	e0fffc17 	ldw	r3,-16(fp)
  46f050:	1884b03a 	or	r2,r3,r2
  46f054:	e0bffc15 	stw	r2,-16(fp)
  
  NIOS2_WRITE_STATUS (status);
  46f058:	e0bffc17 	ldw	r2,-16(fp)
  46f05c:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
  46f060:	e0bfff17 	ldw	r2,-4(fp)
  46f064:	00c001c4 	movi	r3,7
  46f068:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
  46f06c:	e0bffd17 	ldw	r2,-12(fp)
  46f070:	e0bff215 	stw	r2,-56(fp)
             break;
  46f074:	0001883a 	nop
    }
    return (pevent_return);
  46f078:	e0bff217 	ldw	r2,-56(fp)
}
  46f07c:	e037883a 	mov	sp,fp
  46f080:	dfc00117 	ldw	ra,4(sp)
  46f084:	df000017 	ldw	fp,0(sp)
  46f088:	dec00204 	addi	sp,sp,8
  46f08c:	f800283a 	ret

0046f090 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
  46f090:	defff204 	addi	sp,sp,-56
  46f094:	dfc00d15 	stw	ra,52(sp)
  46f098:	df000c15 	stw	fp,48(sp)
  46f09c:	df000c04 	addi	fp,sp,48
  46f0a0:	e13ffd15 	stw	r4,-12(fp)
  46f0a4:	2805883a 	mov	r2,r5
  46f0a8:	e1bfff15 	stw	r6,-4(fp)
  46f0ac:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
  46f0b0:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
  46f0b4:	e0bfff17 	ldw	r2,-4(fp)
  46f0b8:	1000ab26 	beq	r2,zero,46f368 <OSSemPend+0x2d8>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
  46f0bc:	e0bffd17 	ldw	r2,-12(fp)
  46f0c0:	1000041e 	bne	r2,zero,46f0d4 <OSSemPend+0x44>
        *perr = OS_ERR_PEVENT_NULL;
  46f0c4:	e0bfff17 	ldw	r2,-4(fp)
  46f0c8:	00c00104 	movi	r3,4
  46f0cc:	10c00005 	stb	r3,0(r2)
        return;
  46f0d0:	0000a606 	br	46f36c <OSSemPend+0x2dc>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
  46f0d4:	e0bffd17 	ldw	r2,-12(fp)
  46f0d8:	10800003 	ldbu	r2,0(r2)
  46f0dc:	10803fcc 	andi	r2,r2,255
  46f0e0:	108000e0 	cmpeqi	r2,r2,3
  46f0e4:	1000041e 	bne	r2,zero,46f0f8 <OSSemPend+0x68>
        *perr = OS_ERR_EVENT_TYPE;
  46f0e8:	e0bfff17 	ldw	r2,-4(fp)
  46f0ec:	00c00044 	movi	r3,1
  46f0f0:	10c00005 	stb	r3,0(r2)
        return;
  46f0f4:	00009d06 	br	46f36c <OSSemPend+0x2dc>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
  46f0f8:	00801234 	movhi	r2,72
  46f0fc:	10a64c04 	addi	r2,r2,-26320
  46f100:	10800003 	ldbu	r2,0(r2)
  46f104:	10803fcc 	andi	r2,r2,255
  46f108:	10000426 	beq	r2,zero,46f11c <OSSemPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
  46f10c:	e0bfff17 	ldw	r2,-4(fp)
  46f110:	00c00084 	movi	r3,2
  46f114:	10c00005 	stb	r3,0(r2)
        return;
  46f118:	00009406 	br	46f36c <OSSemPend+0x2dc>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
  46f11c:	00801234 	movhi	r2,72
  46f120:	10a63e04 	addi	r2,r2,-26376
  46f124:	10800003 	ldbu	r2,0(r2)
  46f128:	10803fcc 	andi	r2,r2,255
  46f12c:	10000426 	beq	r2,zero,46f140 <OSSemPend+0xb0>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
  46f130:	e0bfff17 	ldw	r2,-4(fp)
  46f134:	00c00344 	movi	r3,13
  46f138:	10c00005 	stb	r3,0(r2)
        return;
  46f13c:	00008b06 	br	46f36c <OSSemPend+0x2dc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46f140:	0005303a 	rdctl	r2,status
  46f144:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46f148:	e0fff517 	ldw	r3,-44(fp)
  46f14c:	00bfff84 	movi	r2,-2
  46f150:	1884703a 	and	r2,r3,r2
  46f154:	1001703a 	wrctl	status,r2
  
  return context;
  46f158:	e0bff517 	ldw	r2,-44(fp)
    }
    OS_ENTER_CRITICAL();
  46f15c:	e0bff415 	stw	r2,-48(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
  46f160:	e0bffd17 	ldw	r2,-12(fp)
  46f164:	1080020b 	ldhu	r2,8(r2)
  46f168:	10bfffcc 	andi	r2,r2,65535
  46f16c:	10001826 	beq	r2,zero,46f1d0 <OSSemPend+0x140>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
  46f170:	e0bffd17 	ldw	r2,-12(fp)
  46f174:	1080020b 	ldhu	r2,8(r2)
  46f178:	10bfffc4 	addi	r2,r2,-1
  46f17c:	1007883a 	mov	r3,r2
  46f180:	e0bffd17 	ldw	r2,-12(fp)
  46f184:	10c0020d 	sth	r3,8(r2)
  46f188:	e0bff417 	ldw	r2,-48(fp)
  46f18c:	e0bff615 	stw	r2,-40(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46f190:	0005303a 	rdctl	r2,status
  46f194:	e0bff715 	stw	r2,-36(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46f198:	e0fff717 	ldw	r3,-36(fp)
  46f19c:	00bfff84 	movi	r2,-2
  46f1a0:	1884703a 	and	r2,r3,r2
  46f1a4:	e0bff715 	stw	r2,-36(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46f1a8:	e0bff617 	ldw	r2,-40(fp)
  46f1ac:	1080004c 	andi	r2,r2,1
  46f1b0:	e0fff717 	ldw	r3,-36(fp)
  46f1b4:	1884b03a 	or	r2,r3,r2
  46f1b8:	e0bff715 	stw	r2,-36(fp)
  
  NIOS2_WRITE_STATUS (status);
  46f1bc:	e0bff717 	ldw	r2,-36(fp)
  46f1c0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
  46f1c4:	e0bfff17 	ldw	r2,-4(fp)
  46f1c8:	10000005 	stb	zero,0(r2)
        return;
  46f1cc:	00006706 	br	46f36c <OSSemPend+0x2dc>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
  46f1d0:	00801234 	movhi	r2,72
  46f1d4:	10a64d04 	addi	r2,r2,-26316
  46f1d8:	10800017 	ldw	r2,0(r2)
  46f1dc:	00c01234 	movhi	r3,72
  46f1e0:	18e64d04 	addi	r3,r3,-26316
  46f1e4:	18c00017 	ldw	r3,0(r3)
  46f1e8:	18c00c03 	ldbu	r3,48(r3)
  46f1ec:	18c00054 	ori	r3,r3,1
  46f1f0:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
  46f1f4:	00801234 	movhi	r2,72
  46f1f8:	10a64d04 	addi	r2,r2,-26316
  46f1fc:	10800017 	ldw	r2,0(r2)
  46f200:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
  46f204:	00801234 	movhi	r2,72
  46f208:	10a64d04 	addi	r2,r2,-26316
  46f20c:	10800017 	ldw	r2,0(r2)
  46f210:	e0fffe0b 	ldhu	r3,-8(fp)
  46f214:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
  46f218:	e13ffd17 	ldw	r4,-12(fp)
  46f21c:	0469c140 	call	469c14 <OS_EventTaskWait>
  46f220:	e0bff417 	ldw	r2,-48(fp)
  46f224:	e0bff815 	stw	r2,-32(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46f228:	0005303a 	rdctl	r2,status
  46f22c:	e0bff915 	stw	r2,-28(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46f230:	e0fff917 	ldw	r3,-28(fp)
  46f234:	00bfff84 	movi	r2,-2
  46f238:	1884703a 	and	r2,r3,r2
  46f23c:	e0bff915 	stw	r2,-28(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46f240:	e0bff817 	ldw	r2,-32(fp)
  46f244:	1080004c 	andi	r2,r2,1
  46f248:	e0fff917 	ldw	r3,-28(fp)
  46f24c:	1884b03a 	or	r2,r3,r2
  46f250:	e0bff915 	stw	r2,-28(fp)
  
  NIOS2_WRITE_STATUS (status);
  46f254:	e0bff917 	ldw	r2,-28(fp)
  46f258:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
  46f25c:	046a4980 	call	46a498 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46f260:	0005303a 	rdctl	r2,status
  46f264:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46f268:	e0fffa17 	ldw	r3,-24(fp)
  46f26c:	00bfff84 	movi	r2,-2
  46f270:	1884703a 	and	r2,r3,r2
  46f274:	1001703a 	wrctl	status,r2
  
  return context;
  46f278:	e0bffa17 	ldw	r2,-24(fp)
    OS_ENTER_CRITICAL();
  46f27c:	e0bff415 	stw	r2,-48(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
  46f280:	00801234 	movhi	r2,72
  46f284:	10a64d04 	addi	r2,r2,-26316
  46f288:	10800017 	ldw	r2,0(r2)
  46f28c:	10800c43 	ldbu	r2,49(r2)
  46f290:	10803fcc 	andi	r2,r2,255
  46f294:	10000326 	beq	r2,zero,46f2a4 <OSSemPend+0x214>
  46f298:	108000a0 	cmpeqi	r2,r2,2
  46f29c:	1000041e 	bne	r2,zero,46f2b0 <OSSemPend+0x220>
  46f2a0:	00000706 	br	46f2c0 <OSSemPend+0x230>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
  46f2a4:	e0bfff17 	ldw	r2,-4(fp)
  46f2a8:	10000005 	stb	zero,0(r2)
             break;
  46f2ac:	00000e06 	br	46f2e8 <OSSemPend+0x258>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
  46f2b0:	e0bfff17 	ldw	r2,-4(fp)
  46f2b4:	00c00384 	movi	r3,14
  46f2b8:	10c00005 	stb	r3,0(r2)
             break;
  46f2bc:	00000a06 	br	46f2e8 <OSSemPend+0x258>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
  46f2c0:	00801234 	movhi	r2,72
  46f2c4:	10a64d04 	addi	r2,r2,-26316
  46f2c8:	10800017 	ldw	r2,0(r2)
  46f2cc:	1009883a 	mov	r4,r2
  46f2d0:	e17ffd17 	ldw	r5,-12(fp)
  46f2d4:	0469e640 	call	469e64 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
  46f2d8:	e0bfff17 	ldw	r2,-4(fp)
  46f2dc:	00c00284 	movi	r3,10
  46f2e0:	10c00005 	stb	r3,0(r2)
             break;
  46f2e4:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
  46f2e8:	00801234 	movhi	r2,72
  46f2ec:	10a64d04 	addi	r2,r2,-26316
  46f2f0:	10800017 	ldw	r2,0(r2)
  46f2f4:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
  46f2f8:	00801234 	movhi	r2,72
  46f2fc:	10a64d04 	addi	r2,r2,-26316
  46f300:	10800017 	ldw	r2,0(r2)
  46f304:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
  46f308:	00801234 	movhi	r2,72
  46f30c:	10a64d04 	addi	r2,r2,-26316
  46f310:	10800017 	ldw	r2,0(r2)
  46f314:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
  46f318:	00801234 	movhi	r2,72
  46f31c:	10a64d04 	addi	r2,r2,-26316
  46f320:	10800017 	ldw	r2,0(r2)
  46f324:	10000815 	stw	zero,32(r2)
  46f328:	e0bff417 	ldw	r2,-48(fp)
  46f32c:	e0bffb15 	stw	r2,-20(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46f330:	0005303a 	rdctl	r2,status
  46f334:	e0bffc15 	stw	r2,-16(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46f338:	e0fffc17 	ldw	r3,-16(fp)
  46f33c:	00bfff84 	movi	r2,-2
  46f340:	1884703a 	and	r2,r3,r2
  46f344:	e0bffc15 	stw	r2,-16(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46f348:	e0bffb17 	ldw	r2,-20(fp)
  46f34c:	1080004c 	andi	r2,r2,1
  46f350:	e0fffc17 	ldw	r3,-16(fp)
  46f354:	1884b03a 	or	r2,r3,r2
  46f358:	e0bffc15 	stw	r2,-16(fp)
  
  NIOS2_WRITE_STATUS (status);
  46f35c:	e0bffc17 	ldw	r2,-16(fp)
  46f360:	1001703a 	wrctl	status,r2
  46f364:	00000106 	br	46f36c <OSSemPend+0x2dc>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
  46f368:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
  46f36c:	e037883a 	mov	sp,fp
  46f370:	dfc00117 	ldw	ra,4(sp)
  46f374:	df000017 	ldw	fp,0(sp)
  46f378:	dec00204 	addi	sp,sp,8
  46f37c:	f800283a 	ret

0046f380 <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
  46f380:	defff404 	addi	sp,sp,-48
  46f384:	dfc00b15 	stw	ra,44(sp)
  46f388:	df000a15 	stw	fp,40(sp)
  46f38c:	df000a04 	addi	fp,sp,40
  46f390:	e13ffd15 	stw	r4,-12(fp)
  46f394:	2805883a 	mov	r2,r5
  46f398:	e1bfff15 	stw	r6,-4(fp)
  46f39c:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
  46f3a0:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
  46f3a4:	e0bfff17 	ldw	r2,-4(fp)
  46f3a8:	1000021e 	bne	r2,zero,46f3b4 <OSSemPendAbort+0x34>
        return (0);
  46f3ac:	0005883a 	mov	r2,zero
  46f3b0:	00006106 	br	46f538 <OSSemPendAbort+0x1b8>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
  46f3b4:	e0bffd17 	ldw	r2,-12(fp)
  46f3b8:	1000051e 	bne	r2,zero,46f3d0 <OSSemPendAbort+0x50>
        *perr = OS_ERR_PEVENT_NULL;
  46f3bc:	e0bfff17 	ldw	r2,-4(fp)
  46f3c0:	00c00104 	movi	r3,4
  46f3c4:	10c00005 	stb	r3,0(r2)
        return (0);
  46f3c8:	0005883a 	mov	r2,zero
  46f3cc:	00005a06 	br	46f538 <OSSemPendAbort+0x1b8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
  46f3d0:	e0bffd17 	ldw	r2,-12(fp)
  46f3d4:	10800003 	ldbu	r2,0(r2)
  46f3d8:	10803fcc 	andi	r2,r2,255
  46f3dc:	108000e0 	cmpeqi	r2,r2,3
  46f3e0:	1000051e 	bne	r2,zero,46f3f8 <OSSemPendAbort+0x78>
        *perr = OS_ERR_EVENT_TYPE;
  46f3e4:	e0bfff17 	ldw	r2,-4(fp)
  46f3e8:	00c00044 	movi	r3,1
  46f3ec:	10c00005 	stb	r3,0(r2)
        return (0);
  46f3f0:	0005883a 	mov	r2,zero
  46f3f4:	00005006 	br	46f538 <OSSemPendAbort+0x1b8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46f3f8:	0005303a 	rdctl	r2,status
  46f3fc:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46f400:	e0fff817 	ldw	r3,-32(fp)
  46f404:	00bfff84 	movi	r2,-2
  46f408:	1884703a 	and	r2,r3,r2
  46f40c:	1001703a 	wrctl	status,r2
  
  return context;
  46f410:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
  46f414:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
  46f418:	e0bffd17 	ldw	r2,-12(fp)
  46f41c:	10800283 	ldbu	r2,10(r2)
  46f420:	10803fcc 	andi	r2,r2,255
  46f424:	10003226 	beq	r2,zero,46f4f0 <OSSemPendAbort+0x170>
        nbr_tasks = 0;
  46f428:	e03ff605 	stb	zero,-40(fp)
        switch (opt) {
  46f42c:	e0bffe03 	ldbu	r2,-8(fp)
  46f430:	10800060 	cmpeqi	r2,r2,1
  46f434:	10000a1e 	bne	r2,zero,46f460 <OSSemPendAbort+0xe0>
  46f438:	00000f06 	br	46f478 <OSSemPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
  46f43c:	e13ffd17 	ldw	r4,-12(fp)
  46f440:	000b883a 	mov	r5,zero
  46f444:	01800044 	movi	r6,1
  46f448:	01c00084 	movi	r7,2
  46f44c:	0469a7c0 	call	469a7c <OS_EventTaskRdy>
                     nbr_tasks++;
  46f450:	e0bff603 	ldbu	r2,-40(fp)
  46f454:	10800044 	addi	r2,r2,1
  46f458:	e0bff605 	stb	r2,-40(fp)
  46f45c:	00000106 	br	46f464 <OSSemPendAbort+0xe4>
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
  46f460:	0001883a 	nop
  46f464:	e0bffd17 	ldw	r2,-12(fp)
  46f468:	10800283 	ldbu	r2,10(r2)
  46f46c:	10803fcc 	andi	r2,r2,255
  46f470:	103ff21e 	bne	r2,zero,46f43c <OSSemPendAbort+0xbc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
  46f474:	00000906 	br	46f49c <OSSemPendAbort+0x11c>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
  46f478:	e13ffd17 	ldw	r4,-12(fp)
  46f47c:	000b883a 	mov	r5,zero
  46f480:	01800044 	movi	r6,1
  46f484:	01c00084 	movi	r7,2
  46f488:	0469a7c0 	call	469a7c <OS_EventTaskRdy>
                 nbr_tasks++;
  46f48c:	e0bff603 	ldbu	r2,-40(fp)
  46f490:	10800044 	addi	r2,r2,1
  46f494:	e0bff605 	stb	r2,-40(fp)
                 break;
  46f498:	0001883a 	nop
  46f49c:	e0bff717 	ldw	r2,-36(fp)
  46f4a0:	e0bff915 	stw	r2,-28(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46f4a4:	0005303a 	rdctl	r2,status
  46f4a8:	e0bffa15 	stw	r2,-24(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46f4ac:	e0fffa17 	ldw	r3,-24(fp)
  46f4b0:	00bfff84 	movi	r2,-2
  46f4b4:	1884703a 	and	r2,r3,r2
  46f4b8:	e0bffa15 	stw	r2,-24(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46f4bc:	e0bff917 	ldw	r2,-28(fp)
  46f4c0:	1080004c 	andi	r2,r2,1
  46f4c4:	e0fffa17 	ldw	r3,-24(fp)
  46f4c8:	1884b03a 	or	r2,r3,r2
  46f4cc:	e0bffa15 	stw	r2,-24(fp)
  
  NIOS2_WRITE_STATUS (status);
  46f4d0:	e0bffa17 	ldw	r2,-24(fp)
  46f4d4:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
  46f4d8:	046a4980 	call	46a498 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
  46f4dc:	e0bfff17 	ldw	r2,-4(fp)
  46f4e0:	00c00384 	movi	r3,14
  46f4e4:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
  46f4e8:	e0bff603 	ldbu	r2,-40(fp)
  46f4ec:	00001206 	br	46f538 <OSSemPendAbort+0x1b8>
  46f4f0:	e0bff717 	ldw	r2,-36(fp)
  46f4f4:	e0bffb15 	stw	r2,-20(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46f4f8:	0005303a 	rdctl	r2,status
  46f4fc:	e0bffc15 	stw	r2,-16(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46f500:	e0fffc17 	ldw	r3,-16(fp)
  46f504:	00bfff84 	movi	r2,-2
  46f508:	1884703a 	and	r2,r3,r2
  46f50c:	e0bffc15 	stw	r2,-16(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46f510:	e0bffb17 	ldw	r2,-20(fp)
  46f514:	1080004c 	andi	r2,r2,1
  46f518:	e0fffc17 	ldw	r3,-16(fp)
  46f51c:	1884b03a 	or	r2,r3,r2
  46f520:	e0bffc15 	stw	r2,-16(fp)
  
  NIOS2_WRITE_STATUS (status);
  46f524:	e0bffc17 	ldw	r2,-16(fp)
  46f528:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
  46f52c:	e0bfff17 	ldw	r2,-4(fp)
  46f530:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
  46f534:	0005883a 	mov	r2,zero
}
  46f538:	e037883a 	mov	sp,fp
  46f53c:	dfc00117 	ldw	ra,4(sp)
  46f540:	df000017 	ldw	fp,0(sp)
  46f544:	dec00204 	addi	sp,sp,8
  46f548:	f800283a 	ret

0046f54c <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
  46f54c:	defff504 	addi	sp,sp,-44
  46f550:	dfc00a15 	stw	ra,40(sp)
  46f554:	df000915 	stw	fp,36(sp)
  46f558:	df000904 	addi	fp,sp,36
  46f55c:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
  46f560:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
  46f564:	e0bfff17 	ldw	r2,-4(fp)
  46f568:	1000021e 	bne	r2,zero,46f574 <OSSemPost+0x28>
        return (OS_ERR_PEVENT_NULL);
  46f56c:	00800104 	movi	r2,4
  46f570:	00005606 	br	46f6cc <OSSemPost+0x180>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
  46f574:	e0bfff17 	ldw	r2,-4(fp)
  46f578:	10800003 	ldbu	r2,0(r2)
  46f57c:	10803fcc 	andi	r2,r2,255
  46f580:	108000e0 	cmpeqi	r2,r2,3
  46f584:	1000021e 	bne	r2,zero,46f590 <OSSemPost+0x44>
        return (OS_ERR_EVENT_TYPE);
  46f588:	00800044 	movi	r2,1
  46f58c:	00004f06 	br	46f6cc <OSSemPost+0x180>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46f590:	0005303a 	rdctl	r2,status
  46f594:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46f598:	e0fff817 	ldw	r3,-32(fp)
  46f59c:	00bfff84 	movi	r2,-2
  46f5a0:	1884703a 	and	r2,r3,r2
  46f5a4:	1001703a 	wrctl	status,r2
  
  return context;
  46f5a8:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
  46f5ac:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
  46f5b0:	e0bfff17 	ldw	r2,-4(fp)
  46f5b4:	10800283 	ldbu	r2,10(r2)
  46f5b8:	10803fcc 	andi	r2,r2,255
  46f5bc:	10001726 	beq	r2,zero,46f61c <OSSemPost+0xd0>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
  46f5c0:	e13fff17 	ldw	r4,-4(fp)
  46f5c4:	000b883a 	mov	r5,zero
  46f5c8:	01800044 	movi	r6,1
  46f5cc:	000f883a 	mov	r7,zero
  46f5d0:	0469a7c0 	call	469a7c <OS_EventTaskRdy>
  46f5d4:	e0bff717 	ldw	r2,-36(fp)
  46f5d8:	e0bff915 	stw	r2,-28(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46f5dc:	0005303a 	rdctl	r2,status
  46f5e0:	e0bffa15 	stw	r2,-24(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46f5e4:	e0fffa17 	ldw	r3,-24(fp)
  46f5e8:	00bfff84 	movi	r2,-2
  46f5ec:	1884703a 	and	r2,r3,r2
  46f5f0:	e0bffa15 	stw	r2,-24(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46f5f4:	e0bff917 	ldw	r2,-28(fp)
  46f5f8:	1080004c 	andi	r2,r2,1
  46f5fc:	e0fffa17 	ldw	r3,-24(fp)
  46f600:	1884b03a 	or	r2,r3,r2
  46f604:	e0bffa15 	stw	r2,-24(fp)
  
  NIOS2_WRITE_STATUS (status);
  46f608:	e0bffa17 	ldw	r2,-24(fp)
  46f60c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
  46f610:	046a4980 	call	46a498 <OS_Sched>
        return (OS_ERR_NONE);
  46f614:	0005883a 	mov	r2,zero
  46f618:	00002c06 	br	46f6cc <OSSemPost+0x180>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
  46f61c:	e0bfff17 	ldw	r2,-4(fp)
  46f620:	1080020b 	ldhu	r2,8(r2)
  46f624:	10ffffcc 	andi	r3,r2,65535
  46f628:	00bfffd4 	movui	r2,65535
  46f62c:	18801726 	beq	r3,r2,46f68c <OSSemPost+0x140>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
  46f630:	e0bfff17 	ldw	r2,-4(fp)
  46f634:	1080020b 	ldhu	r2,8(r2)
  46f638:	10800044 	addi	r2,r2,1
  46f63c:	1007883a 	mov	r3,r2
  46f640:	e0bfff17 	ldw	r2,-4(fp)
  46f644:	10c0020d 	sth	r3,8(r2)
  46f648:	e0bff717 	ldw	r2,-36(fp)
  46f64c:	e0bffb15 	stw	r2,-20(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46f650:	0005303a 	rdctl	r2,status
  46f654:	e0bffc15 	stw	r2,-16(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46f658:	e0fffc17 	ldw	r3,-16(fp)
  46f65c:	00bfff84 	movi	r2,-2
  46f660:	1884703a 	and	r2,r3,r2
  46f664:	e0bffc15 	stw	r2,-16(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46f668:	e0bffb17 	ldw	r2,-20(fp)
  46f66c:	1080004c 	andi	r2,r2,1
  46f670:	e0fffc17 	ldw	r3,-16(fp)
  46f674:	1884b03a 	or	r2,r3,r2
  46f678:	e0bffc15 	stw	r2,-16(fp)
  
  NIOS2_WRITE_STATUS (status);
  46f67c:	e0bffc17 	ldw	r2,-16(fp)
  46f680:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
  46f684:	0005883a 	mov	r2,zero
  46f688:	00001006 	br	46f6cc <OSSemPost+0x180>
  46f68c:	e0bff717 	ldw	r2,-36(fp)
  46f690:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46f694:	0005303a 	rdctl	r2,status
  46f698:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46f69c:	e0fffe17 	ldw	r3,-8(fp)
  46f6a0:	00bfff84 	movi	r2,-2
  46f6a4:	1884703a 	and	r2,r3,r2
  46f6a8:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46f6ac:	e0bffd17 	ldw	r2,-12(fp)
  46f6b0:	1080004c 	andi	r2,r2,1
  46f6b4:	e0fffe17 	ldw	r3,-8(fp)
  46f6b8:	1884b03a 	or	r2,r3,r2
  46f6bc:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
  46f6c0:	e0bffe17 	ldw	r2,-8(fp)
  46f6c4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
  46f6c8:	00800c84 	movi	r2,50
}
  46f6cc:	e037883a 	mov	sp,fp
  46f6d0:	dfc00117 	ldw	ra,4(sp)
  46f6d4:	df000017 	ldw	fp,0(sp)
  46f6d8:	dec00204 	addi	sp,sp,8
  46f6dc:	f800283a 	ret

0046f6e0 <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
  46f6e0:	defff604 	addi	sp,sp,-40
  46f6e4:	df000915 	stw	fp,36(sp)
  46f6e8:	df000904 	addi	fp,sp,36
  46f6ec:	e13ffe15 	stw	r4,-8(fp)
  46f6f0:	e17fff15 	stw	r5,-4(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
  46f6f4:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
  46f6f8:	e0bffe17 	ldw	r2,-8(fp)
  46f6fc:	1000021e 	bne	r2,zero,46f708 <OSSemQuery+0x28>
        return (OS_ERR_PEVENT_NULL);
  46f700:	00800104 	movi	r2,4
  46f704:	00004306 	br	46f814 <OSSemQuery+0x134>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
  46f708:	e0bfff17 	ldw	r2,-4(fp)
  46f70c:	1000021e 	bne	r2,zero,46f718 <OSSemQuery+0x38>
        return (OS_ERR_PDATA_NULL);
  46f710:	00800244 	movi	r2,9
  46f714:	00003f06 	br	46f814 <OSSemQuery+0x134>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
  46f718:	e0bffe17 	ldw	r2,-8(fp)
  46f71c:	10800003 	ldbu	r2,0(r2)
  46f720:	10803fcc 	andi	r2,r2,255
  46f724:	108000e0 	cmpeqi	r2,r2,3
  46f728:	1000021e 	bne	r2,zero,46f734 <OSSemQuery+0x54>
        return (OS_ERR_EVENT_TYPE);
  46f72c:	00800044 	movi	r2,1
  46f730:	00003806 	br	46f814 <OSSemQuery+0x134>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46f734:	0005303a 	rdctl	r2,status
  46f738:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46f73c:	e0fffb17 	ldw	r3,-20(fp)
  46f740:	00bfff84 	movi	r2,-2
  46f744:	1884703a 	and	r2,r3,r2
  46f748:	1001703a 	wrctl	status,r2
  
  return context;
  46f74c:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
  46f750:	e0bffa15 	stw	r2,-24(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
  46f754:	e0bffe17 	ldw	r2,-8(fp)
  46f758:	10c00283 	ldbu	r3,10(r2)
  46f75c:	e0bfff17 	ldw	r2,-4(fp)
  46f760:	10c00145 	stb	r3,5(r2)
    psrc                   = &pevent->OSEventTbl[0];
  46f764:	e0bffe17 	ldw	r2,-8(fp)
  46f768:	108002c4 	addi	r2,r2,11
  46f76c:	e0bff715 	stw	r2,-36(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
  46f770:	e0bfff17 	ldw	r2,-4(fp)
  46f774:	10800084 	addi	r2,r2,2
  46f778:	e0bff815 	stw	r2,-32(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
  46f77c:	e03ff905 	stb	zero,-28(fp)
  46f780:	00000d06 	br	46f7b8 <OSSemQuery+0xd8>
        *pdest++ = *psrc++;
  46f784:	e0bff717 	ldw	r2,-36(fp)
  46f788:	10c00003 	ldbu	r3,0(r2)
  46f78c:	e0bff817 	ldw	r2,-32(fp)
  46f790:	10c00005 	stb	r3,0(r2)
  46f794:	e0bff817 	ldw	r2,-32(fp)
  46f798:	10800044 	addi	r2,r2,1
  46f79c:	e0bff815 	stw	r2,-32(fp)
  46f7a0:	e0bff717 	ldw	r2,-36(fp)
  46f7a4:	10800044 	addi	r2,r2,1
  46f7a8:	e0bff715 	stw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
  46f7ac:	e0bff903 	ldbu	r2,-28(fp)
  46f7b0:	10800044 	addi	r2,r2,1
  46f7b4:	e0bff905 	stb	r2,-28(fp)
  46f7b8:	e0bff903 	ldbu	r2,-28(fp)
  46f7bc:	108000f0 	cmpltui	r2,r2,3
  46f7c0:	103ff01e 	bne	r2,zero,46f784 <OSSemQuery+0xa4>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
  46f7c4:	e0bffe17 	ldw	r2,-8(fp)
  46f7c8:	10c0020b 	ldhu	r3,8(r2)
  46f7cc:	e0bfff17 	ldw	r2,-4(fp)
  46f7d0:	10c0000d 	sth	r3,0(r2)
  46f7d4:	e0bffa17 	ldw	r2,-24(fp)
  46f7d8:	e0bffc15 	stw	r2,-16(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46f7dc:	0005303a 	rdctl	r2,status
  46f7e0:	e0bffd15 	stw	r2,-12(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46f7e4:	e0fffd17 	ldw	r3,-12(fp)
  46f7e8:	00bfff84 	movi	r2,-2
  46f7ec:	1884703a 	and	r2,r3,r2
  46f7f0:	e0bffd15 	stw	r2,-12(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46f7f4:	e0bffc17 	ldw	r2,-16(fp)
  46f7f8:	1080004c 	andi	r2,r2,1
  46f7fc:	e0fffd17 	ldw	r3,-12(fp)
  46f800:	1884b03a 	or	r2,r3,r2
  46f804:	e0bffd15 	stw	r2,-12(fp)
  
  NIOS2_WRITE_STATUS (status);
  46f808:	e0bffd17 	ldw	r2,-12(fp)
  46f80c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
  46f810:	0005883a 	mov	r2,zero
}
  46f814:	e037883a 	mov	sp,fp
  46f818:	df000017 	ldw	fp,0(sp)
  46f81c:	dec00104 	addi	sp,sp,4
  46f820:	f800283a 	ret

0046f824 <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
  46f824:	defff804 	addi	sp,sp,-32
  46f828:	df000715 	stw	fp,28(sp)
  46f82c:	df000704 	addi	fp,sp,28
  46f830:	e13ffd15 	stw	r4,-12(fp)
  46f834:	2805883a 	mov	r2,r5
  46f838:	e1bfff15 	stw	r6,-4(fp)
  46f83c:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
  46f840:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
  46f844:	e0bfff17 	ldw	r2,-4(fp)
  46f848:	10003c26 	beq	r2,zero,46f93c <OSSemSet+0x118>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
  46f84c:	e0bffd17 	ldw	r2,-12(fp)
  46f850:	1000041e 	bne	r2,zero,46f864 <OSSemSet+0x40>
        *perr = OS_ERR_PEVENT_NULL;
  46f854:	e0bfff17 	ldw	r2,-4(fp)
  46f858:	00c00104 	movi	r3,4
  46f85c:	10c00005 	stb	r3,0(r2)
        return;
  46f860:	00003706 	br	46f940 <OSSemSet+0x11c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
  46f864:	e0bffd17 	ldw	r2,-12(fp)
  46f868:	10800003 	ldbu	r2,0(r2)
  46f86c:	10803fcc 	andi	r2,r2,255
  46f870:	108000e0 	cmpeqi	r2,r2,3
  46f874:	1000041e 	bne	r2,zero,46f888 <OSSemSet+0x64>
        *perr = OS_ERR_EVENT_TYPE;
  46f878:	e0bfff17 	ldw	r2,-4(fp)
  46f87c:	00c00044 	movi	r3,1
  46f880:	10c00005 	stb	r3,0(r2)
        return;
  46f884:	00002e06 	br	46f940 <OSSemSet+0x11c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46f888:	0005303a 	rdctl	r2,status
  46f88c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46f890:	e0fffa17 	ldw	r3,-24(fp)
  46f894:	00bfff84 	movi	r2,-2
  46f898:	1884703a 	and	r2,r3,r2
  46f89c:	1001703a 	wrctl	status,r2
  
  return context;
  46f8a0:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
  46f8a4:	e0bff915 	stw	r2,-28(fp)
    *perr = OS_ERR_NONE;
  46f8a8:	e0bfff17 	ldw	r2,-4(fp)
  46f8ac:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
  46f8b0:	e0bffd17 	ldw	r2,-12(fp)
  46f8b4:	1080020b 	ldhu	r2,8(r2)
  46f8b8:	10bfffcc 	andi	r2,r2,65535
  46f8bc:	10000426 	beq	r2,zero,46f8d0 <OSSemSet+0xac>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
  46f8c0:	e0bffd17 	ldw	r2,-12(fp)
  46f8c4:	e0fffe0b 	ldhu	r3,-8(fp)
  46f8c8:	10c0020d 	sth	r3,8(r2)
  46f8cc:	00000b06 	br	46f8fc <OSSemSet+0xd8>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
  46f8d0:	e0bffd17 	ldw	r2,-12(fp)
  46f8d4:	10800283 	ldbu	r2,10(r2)
  46f8d8:	10803fcc 	andi	r2,r2,255
  46f8dc:	1000041e 	bne	r2,zero,46f8f0 <OSSemSet+0xcc>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
  46f8e0:	e0bffd17 	ldw	r2,-12(fp)
  46f8e4:	e0fffe0b 	ldhu	r3,-8(fp)
  46f8e8:	10c0020d 	sth	r3,8(r2)
  46f8ec:	00000306 	br	46f8fc <OSSemSet+0xd8>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
  46f8f0:	e0bfff17 	ldw	r2,-4(fp)
  46f8f4:	00c01244 	movi	r3,73
  46f8f8:	10c00005 	stb	r3,0(r2)
  46f8fc:	e0bff917 	ldw	r2,-28(fp)
  46f900:	e0bffb15 	stw	r2,-20(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46f904:	0005303a 	rdctl	r2,status
  46f908:	e0bffc15 	stw	r2,-16(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46f90c:	e0fffc17 	ldw	r3,-16(fp)
  46f910:	00bfff84 	movi	r2,-2
  46f914:	1884703a 	and	r2,r3,r2
  46f918:	e0bffc15 	stw	r2,-16(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46f91c:	e0bffb17 	ldw	r2,-20(fp)
  46f920:	1080004c 	andi	r2,r2,1
  46f924:	e0fffc17 	ldw	r3,-16(fp)
  46f928:	1884b03a 	or	r2,r3,r2
  46f92c:	e0bffc15 	stw	r2,-16(fp)
  
  NIOS2_WRITE_STATUS (status);
  46f930:	e0bffc17 	ldw	r2,-16(fp)
  46f934:	1001703a 	wrctl	status,r2
  46f938:	00000106 	br	46f940 <OSSemSet+0x11c>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
  46f93c:	0001883a 	nop
        } else {
            *perr              = OS_ERR_TASK_WAITING;
        }
    }
    OS_EXIT_CRITICAL();
}
  46f940:	e037883a 	mov	sp,fp
  46f944:	df000017 	ldw	fp,0(sp)
  46f948:	dec00104 	addi	sp,sp,4
  46f94c:	f800283a 	ret

0046f950 <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
  46f950:	deffed04 	addi	sp,sp,-76
  46f954:	dfc01215 	stw	ra,72(sp)
  46f958:	df001115 	stw	fp,68(sp)
  46f95c:	df001104 	addi	fp,sp,68
  46f960:	2007883a 	mov	r3,r4
  46f964:	2805883a 	mov	r2,r5
  46f968:	e0fffe05 	stb	r3,-8(fp)
  46f96c:	e0bfff05 	stb	r2,-4(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
  46f970:	e03ff115 	stw	zero,-60(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
  46f974:	e0bffe03 	ldbu	r2,-8(fp)
  46f978:	10800530 	cmpltui	r2,r2,20
  46f97c:	1000051e 	bne	r2,zero,46f994 <OSTaskChangePrio+0x44>
        if (oldprio != OS_PRIO_SELF) {
  46f980:	e0bffe03 	ldbu	r2,-8(fp)
  46f984:	10803fe0 	cmpeqi	r2,r2,255
  46f988:	1000021e 	bne	r2,zero,46f994 <OSTaskChangePrio+0x44>
            return (OS_ERR_PRIO_INVALID);
  46f98c:	00800a84 	movi	r2,42
  46f990:	00016006 	br	46ff14 <OSTaskChangePrio+0x5c4>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
  46f994:	e0bfff03 	ldbu	r2,-4(fp)
  46f998:	10800530 	cmpltui	r2,r2,20
  46f99c:	1000021e 	bne	r2,zero,46f9a8 <OSTaskChangePrio+0x58>
        return (OS_ERR_PRIO_INVALID);
  46f9a0:	00800a84 	movi	r2,42
  46f9a4:	00015b06 	br	46ff14 <OSTaskChangePrio+0x5c4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46f9a8:	0005303a 	rdctl	r2,status
  46f9ac:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46f9b0:	e0fff517 	ldw	r3,-44(fp)
  46f9b4:	00bfff84 	movi	r2,-2
  46f9b8:	1884703a 	and	r2,r3,r2
  46f9bc:	1001703a 	wrctl	status,r2
  
  return context;
  46f9c0:	e0bff517 	ldw	r2,-44(fp)
    }
#endif
    OS_ENTER_CRITICAL();
  46f9c4:	e0bff115 	stw	r2,-60(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
  46f9c8:	e0bfff03 	ldbu	r2,-4(fp)
  46f9cc:	00c01234 	movhi	r3,72
  46f9d0:	18f31404 	addi	r3,r3,-13232
  46f9d4:	1085883a 	add	r2,r2,r2
  46f9d8:	1085883a 	add	r2,r2,r2
  46f9dc:	1885883a 	add	r2,r3,r2
  46f9e0:	10800017 	ldw	r2,0(r2)
  46f9e4:	10001126 	beq	r2,zero,46fa2c <OSTaskChangePrio+0xdc>
  46f9e8:	e0bff117 	ldw	r2,-60(fp)
  46f9ec:	e0bff615 	stw	r2,-40(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46f9f0:	0005303a 	rdctl	r2,status
  46f9f4:	e0bff715 	stw	r2,-36(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46f9f8:	e0fff717 	ldw	r3,-36(fp)
  46f9fc:	00bfff84 	movi	r2,-2
  46fa00:	1884703a 	and	r2,r3,r2
  46fa04:	e0bff715 	stw	r2,-36(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46fa08:	e0bff617 	ldw	r2,-40(fp)
  46fa0c:	1080004c 	andi	r2,r2,1
  46fa10:	e0fff717 	ldw	r3,-36(fp)
  46fa14:	1884b03a 	or	r2,r3,r2
  46fa18:	e0bff715 	stw	r2,-36(fp)
  
  NIOS2_WRITE_STATUS (status);
  46fa1c:	e0bff717 	ldw	r2,-36(fp)
  46fa20:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
  46fa24:	00800a04 	movi	r2,40
  46fa28:	00013a06 	br	46ff14 <OSTaskChangePrio+0x5c4>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
  46fa2c:	e0bffe03 	ldbu	r2,-8(fp)
  46fa30:	10803fd8 	cmpnei	r2,r2,255
  46fa34:	1000051e 	bne	r2,zero,46fa4c <OSTaskChangePrio+0xfc>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
  46fa38:	00801234 	movhi	r2,72
  46fa3c:	10a64d04 	addi	r2,r2,-26316
  46fa40:	10800017 	ldw	r2,0(r2)
  46fa44:	10800c83 	ldbu	r2,50(r2)
  46fa48:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
  46fa4c:	e0bffe03 	ldbu	r2,-8(fp)
  46fa50:	00c01234 	movhi	r3,72
  46fa54:	18f31404 	addi	r3,r3,-13232
  46fa58:	1085883a 	add	r2,r2,r2
  46fa5c:	1085883a 	add	r2,r2,r2
  46fa60:	1885883a 	add	r2,r3,r2
  46fa64:	10800017 	ldw	r2,0(r2)
  46fa68:	e0bff215 	stw	r2,-56(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
  46fa6c:	e0bff217 	ldw	r2,-56(fp)
  46fa70:	1000111e 	bne	r2,zero,46fab8 <OSTaskChangePrio+0x168>
  46fa74:	e0bff117 	ldw	r2,-60(fp)
  46fa78:	e0bff815 	stw	r2,-32(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46fa7c:	0005303a 	rdctl	r2,status
  46fa80:	e0bff915 	stw	r2,-28(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46fa84:	e0fff917 	ldw	r3,-28(fp)
  46fa88:	00bfff84 	movi	r2,-2
  46fa8c:	1884703a 	and	r2,r3,r2
  46fa90:	e0bff915 	stw	r2,-28(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46fa94:	e0bff817 	ldw	r2,-32(fp)
  46fa98:	1080004c 	andi	r2,r2,1
  46fa9c:	e0fff917 	ldw	r3,-28(fp)
  46faa0:	1884b03a 	or	r2,r3,r2
  46faa4:	e0bff915 	stw	r2,-28(fp)
  
  NIOS2_WRITE_STATUS (status);
  46faa8:	e0bff917 	ldw	r2,-28(fp)
  46faac:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
  46fab0:	00800a44 	movi	r2,41
  46fab4:	00011706 	br	46ff14 <OSTaskChangePrio+0x5c4>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
  46fab8:	e0bff217 	ldw	r2,-56(fp)
  46fabc:	10800058 	cmpnei	r2,r2,1
  46fac0:	1000111e 	bne	r2,zero,46fb08 <OSTaskChangePrio+0x1b8>
  46fac4:	e0bff117 	ldw	r2,-60(fp)
  46fac8:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46facc:	0005303a 	rdctl	r2,status
  46fad0:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46fad4:	e0fffb17 	ldw	r3,-20(fp)
  46fad8:	00bfff84 	movi	r2,-2
  46fadc:	1884703a 	and	r2,r3,r2
  46fae0:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46fae4:	e0bffa17 	ldw	r2,-24(fp)
  46fae8:	1080004c 	andi	r2,r2,1
  46faec:	e0fffb17 	ldw	r3,-20(fp)
  46faf0:	1884b03a 	or	r2,r3,r2
  46faf4:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
  46faf8:	e0bffb17 	ldw	r2,-20(fp)
  46fafc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
  46fb00:	008010c4 	movi	r2,67
  46fb04:	00010306 	br	46ff14 <OSTaskChangePrio+0x5c4>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
  46fb08:	e0bfff03 	ldbu	r2,-4(fp)
  46fb0c:	1004d0fa 	srli	r2,r2,3
  46fb10:	e0bff305 	stb	r2,-52(fp)
    x_new                 = (INT8U)(newprio & 0x07);
  46fb14:	e0bfff03 	ldbu	r2,-4(fp)
  46fb18:	108001cc 	andi	r2,r2,7
  46fb1c:	e0bff345 	stb	r2,-51(fp)
    bity_new              = (INT8U)(1 << y_new);
  46fb20:	e0bff303 	ldbu	r2,-52(fp)
  46fb24:	00c00044 	movi	r3,1
  46fb28:	1884983a 	sll	r2,r3,r2
  46fb2c:	e0bff385 	stb	r2,-50(fp)
    bitx_new              = (INT8U)(1 << x_new);
  46fb30:	e0bff343 	ldbu	r2,-51(fp)
  46fb34:	00c00044 	movi	r3,1
  46fb38:	1884983a 	sll	r2,r3,r2
  46fb3c:	e0bff3c5 	stb	r2,-49(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
  46fb40:	e0bffe03 	ldbu	r2,-8(fp)
  46fb44:	00c01234 	movhi	r3,72
  46fb48:	18f31404 	addi	r3,r3,-13232
  46fb4c:	1085883a 	add	r2,r2,r2
  46fb50:	1085883a 	add	r2,r2,r2
  46fb54:	1885883a 	add	r2,r3,r2
  46fb58:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
  46fb5c:	e0bfff03 	ldbu	r2,-4(fp)
  46fb60:	00c01234 	movhi	r3,72
  46fb64:	18f31404 	addi	r3,r3,-13232
  46fb68:	1085883a 	add	r2,r2,r2
  46fb6c:	1085883a 	add	r2,r2,r2
  46fb70:	1885883a 	add	r2,r3,r2
  46fb74:	e0fff217 	ldw	r3,-56(fp)
  46fb78:	10c00015 	stw	r3,0(r2)
    y_old                 =  ptcb->OSTCBY;
  46fb7c:	e0bff217 	ldw	r2,-56(fp)
  46fb80:	10800d03 	ldbu	r2,52(r2)
  46fb84:	e0bff405 	stb	r2,-48(fp)
    bity_old              =  ptcb->OSTCBBitY;
  46fb88:	e0bff217 	ldw	r2,-56(fp)
  46fb8c:	10800d83 	ldbu	r2,54(r2)
  46fb90:	e0bff445 	stb	r2,-47(fp)
    bitx_old              =  ptcb->OSTCBBitX;
  46fb94:	e0bff217 	ldw	r2,-56(fp)
  46fb98:	10800d43 	ldbu	r2,53(r2)
  46fb9c:	e0bff485 	stb	r2,-46(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
  46fba0:	e0bff403 	ldbu	r2,-48(fp)
  46fba4:	00c01234 	movhi	r3,72
  46fba8:	18e64a44 	addi	r3,r3,-26327
  46fbac:	1885883a 	add	r2,r3,r2
  46fbb0:	10c00003 	ldbu	r3,0(r2)
  46fbb4:	e0bff483 	ldbu	r2,-46(fp)
  46fbb8:	1884703a 	and	r2,r3,r2
  46fbbc:	10803fcc 	andi	r2,r2,255
  46fbc0:	10003526 	beq	r2,zero,46fc98 <OSTaskChangePrio+0x348>
         OSRdyTbl[y_old] &= ~bitx_old;
  46fbc4:	e0bff403 	ldbu	r2,-48(fp)
  46fbc8:	e0fff403 	ldbu	r3,-48(fp)
  46fbcc:	01001234 	movhi	r4,72
  46fbd0:	21264a44 	addi	r4,r4,-26327
  46fbd4:	20c7883a 	add	r3,r4,r3
  46fbd8:	18c00003 	ldbu	r3,0(r3)
  46fbdc:	1809883a 	mov	r4,r3
  46fbe0:	e0fff483 	ldbu	r3,-46(fp)
  46fbe4:	00c6303a 	nor	r3,zero,r3
  46fbe8:	20c6703a 	and	r3,r4,r3
  46fbec:	01001234 	movhi	r4,72
  46fbf0:	21264a44 	addi	r4,r4,-26327
  46fbf4:	2085883a 	add	r2,r4,r2
  46fbf8:	10c00005 	stb	r3,0(r2)
         if (OSRdyTbl[y_old] == 0) {
  46fbfc:	e0bff403 	ldbu	r2,-48(fp)
  46fc00:	00c01234 	movhi	r3,72
  46fc04:	18e64a44 	addi	r3,r3,-26327
  46fc08:	1885883a 	add	r2,r3,r2
  46fc0c:	10800003 	ldbu	r2,0(r2)
  46fc10:	10803fcc 	andi	r2,r2,255
  46fc14:	10000b1e 	bne	r2,zero,46fc44 <OSTaskChangePrio+0x2f4>
             OSRdyGrp &= ~bity_old;
  46fc18:	e0bff443 	ldbu	r2,-47(fp)
  46fc1c:	0084303a 	nor	r2,zero,r2
  46fc20:	1007883a 	mov	r3,r2
  46fc24:	00801234 	movhi	r2,72
  46fc28:	10a64a04 	addi	r2,r2,-26328
  46fc2c:	10800003 	ldbu	r2,0(r2)
  46fc30:	1884703a 	and	r2,r3,r2
  46fc34:	1007883a 	mov	r3,r2
  46fc38:	00801234 	movhi	r2,72
  46fc3c:	10a64a04 	addi	r2,r2,-26328
  46fc40:	10c00005 	stb	r3,0(r2)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
  46fc44:	00801234 	movhi	r2,72
  46fc48:	10a64a04 	addi	r2,r2,-26328
  46fc4c:	10c00003 	ldbu	r3,0(r2)
  46fc50:	e0bff383 	ldbu	r2,-50(fp)
  46fc54:	1884b03a 	or	r2,r3,r2
  46fc58:	1007883a 	mov	r3,r2
  46fc5c:	00801234 	movhi	r2,72
  46fc60:	10a64a04 	addi	r2,r2,-26328
  46fc64:	10c00005 	stb	r3,0(r2)
         OSRdyTbl[y_new] |= bitx_new;
  46fc68:	e0bff303 	ldbu	r2,-52(fp)
  46fc6c:	e0fff303 	ldbu	r3,-52(fp)
  46fc70:	01001234 	movhi	r4,72
  46fc74:	21264a44 	addi	r4,r4,-26327
  46fc78:	20c7883a 	add	r3,r4,r3
  46fc7c:	19000003 	ldbu	r4,0(r3)
  46fc80:	e0fff3c3 	ldbu	r3,-49(fp)
  46fc84:	20c6b03a 	or	r3,r4,r3
  46fc88:	01001234 	movhi	r4,72
  46fc8c:	21264a44 	addi	r4,r4,-26327
  46fc90:	2085883a 	add	r2,r4,r2
  46fc94:	10c00005 	stb	r3,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
  46fc98:	e0bff217 	ldw	r2,-56(fp)
  46fc9c:	10800717 	ldw	r2,28(r2)
  46fca0:	e0bfef15 	stw	r2,-68(fp)
    if (pevent != (OS_EVENT *)0) {
  46fca4:	e0bfef17 	ldw	r2,-68(fp)
  46fca8:	10003126 	beq	r2,zero,46fd70 <OSTaskChangePrio+0x420>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
  46fcac:	e0bff403 	ldbu	r2,-48(fp)
  46fcb0:	e0fff403 	ldbu	r3,-48(fp)
  46fcb4:	e13fef17 	ldw	r4,-68(fp)
  46fcb8:	20c7883a 	add	r3,r4,r3
  46fcbc:	18c00204 	addi	r3,r3,8
  46fcc0:	18c000c3 	ldbu	r3,3(r3)
  46fcc4:	1809883a 	mov	r4,r3
  46fcc8:	e0fff483 	ldbu	r3,-46(fp)
  46fccc:	00c6303a 	nor	r3,zero,r3
  46fcd0:	20c6703a 	and	r3,r4,r3
  46fcd4:	e13fef17 	ldw	r4,-68(fp)
  46fcd8:	2085883a 	add	r2,r4,r2
  46fcdc:	10800204 	addi	r2,r2,8
  46fce0:	10c000c5 	stb	r3,3(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
  46fce4:	e0bff403 	ldbu	r2,-48(fp)
  46fce8:	e0ffef17 	ldw	r3,-68(fp)
  46fcec:	1885883a 	add	r2,r3,r2
  46fcf0:	10800204 	addi	r2,r2,8
  46fcf4:	108000c3 	ldbu	r2,3(r2)
  46fcf8:	10803fcc 	andi	r2,r2,255
  46fcfc:	1000091e 	bne	r2,zero,46fd24 <OSTaskChangePrio+0x3d4>
            pevent->OSEventGrp    &= ~bity_old;
  46fd00:	e0bfef17 	ldw	r2,-68(fp)
  46fd04:	10800283 	ldbu	r2,10(r2)
  46fd08:	1007883a 	mov	r3,r2
  46fd0c:	e0bff443 	ldbu	r2,-47(fp)
  46fd10:	0084303a 	nor	r2,zero,r2
  46fd14:	1884703a 	and	r2,r3,r2
  46fd18:	1007883a 	mov	r3,r2
  46fd1c:	e0bfef17 	ldw	r2,-68(fp)
  46fd20:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
  46fd24:	e0bfef17 	ldw	r2,-68(fp)
  46fd28:	10c00283 	ldbu	r3,10(r2)
  46fd2c:	e0bff383 	ldbu	r2,-50(fp)
  46fd30:	1884b03a 	or	r2,r3,r2
  46fd34:	1007883a 	mov	r3,r2
  46fd38:	e0bfef17 	ldw	r2,-68(fp)
  46fd3c:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
  46fd40:	e0bff303 	ldbu	r2,-52(fp)
  46fd44:	e0fff303 	ldbu	r3,-52(fp)
  46fd48:	e13fef17 	ldw	r4,-68(fp)
  46fd4c:	20c7883a 	add	r3,r4,r3
  46fd50:	18c00204 	addi	r3,r3,8
  46fd54:	190000c3 	ldbu	r4,3(r3)
  46fd58:	e0fff3c3 	ldbu	r3,-49(fp)
  46fd5c:	20c6b03a 	or	r3,r4,r3
  46fd60:	e13fef17 	ldw	r4,-68(fp)
  46fd64:	2085883a 	add	r2,r4,r2
  46fd68:	10800204 	addi	r2,r2,8
  46fd6c:	10c000c5 	stb	r3,3(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
  46fd70:	e0bff217 	ldw	r2,-56(fp)
  46fd74:	10800817 	ldw	r2,32(r2)
  46fd78:	10004026 	beq	r2,zero,46fe7c <OSTaskChangePrio+0x52c>
        pevents =  ptcb->OSTCBEventMultiPtr;
  46fd7c:	e0bff217 	ldw	r2,-56(fp)
  46fd80:	10800817 	ldw	r2,32(r2)
  46fd84:	e0bff015 	stw	r2,-64(fp)
        pevent  = *pevents;
  46fd88:	e0bff017 	ldw	r2,-64(fp)
  46fd8c:	10800017 	ldw	r2,0(r2)
  46fd90:	e0bfef15 	stw	r2,-68(fp)
        while (pevent != (OS_EVENT *)0) {
  46fd94:	00003706 	br	46fe74 <OSTaskChangePrio+0x524>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
  46fd98:	e0bff403 	ldbu	r2,-48(fp)
  46fd9c:	e0fff403 	ldbu	r3,-48(fp)
  46fda0:	e13fef17 	ldw	r4,-68(fp)
  46fda4:	20c7883a 	add	r3,r4,r3
  46fda8:	18c00204 	addi	r3,r3,8
  46fdac:	18c000c3 	ldbu	r3,3(r3)
  46fdb0:	1809883a 	mov	r4,r3
  46fdb4:	e0fff483 	ldbu	r3,-46(fp)
  46fdb8:	00c6303a 	nor	r3,zero,r3
  46fdbc:	20c6703a 	and	r3,r4,r3
  46fdc0:	e13fef17 	ldw	r4,-68(fp)
  46fdc4:	2085883a 	add	r2,r4,r2
  46fdc8:	10800204 	addi	r2,r2,8
  46fdcc:	10c000c5 	stb	r3,3(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
  46fdd0:	e0bff403 	ldbu	r2,-48(fp)
  46fdd4:	e0ffef17 	ldw	r3,-68(fp)
  46fdd8:	1885883a 	add	r2,r3,r2
  46fddc:	10800204 	addi	r2,r2,8
  46fde0:	108000c3 	ldbu	r2,3(r2)
  46fde4:	10803fcc 	andi	r2,r2,255
  46fde8:	1000091e 	bne	r2,zero,46fe10 <OSTaskChangePrio+0x4c0>
                pevent->OSEventGrp    &= ~bity_old;
  46fdec:	e0bfef17 	ldw	r2,-68(fp)
  46fdf0:	10800283 	ldbu	r2,10(r2)
  46fdf4:	1007883a 	mov	r3,r2
  46fdf8:	e0bff443 	ldbu	r2,-47(fp)
  46fdfc:	0084303a 	nor	r2,zero,r2
  46fe00:	1884703a 	and	r2,r3,r2
  46fe04:	1007883a 	mov	r3,r2
  46fe08:	e0bfef17 	ldw	r2,-68(fp)
  46fe0c:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
  46fe10:	e0bfef17 	ldw	r2,-68(fp)
  46fe14:	10c00283 	ldbu	r3,10(r2)
  46fe18:	e0bff383 	ldbu	r2,-50(fp)
  46fe1c:	1884b03a 	or	r2,r3,r2
  46fe20:	1007883a 	mov	r3,r2
  46fe24:	e0bfef17 	ldw	r2,-68(fp)
  46fe28:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
  46fe2c:	e0bff303 	ldbu	r2,-52(fp)
  46fe30:	e0fff303 	ldbu	r3,-52(fp)
  46fe34:	e13fef17 	ldw	r4,-68(fp)
  46fe38:	20c7883a 	add	r3,r4,r3
  46fe3c:	18c00204 	addi	r3,r3,8
  46fe40:	190000c3 	ldbu	r4,3(r3)
  46fe44:	e0fff3c3 	ldbu	r3,-49(fp)
  46fe48:	20c6b03a 	or	r3,r4,r3
  46fe4c:	e13fef17 	ldw	r4,-68(fp)
  46fe50:	2085883a 	add	r2,r4,r2
  46fe54:	10800204 	addi	r2,r2,8
  46fe58:	10c000c5 	stb	r3,3(r2)
            pevents++;
  46fe5c:	e0bff017 	ldw	r2,-64(fp)
  46fe60:	10800104 	addi	r2,r2,4
  46fe64:	e0bff015 	stw	r2,-64(fp)
            pevent                     = *pevents;
  46fe68:	e0bff017 	ldw	r2,-64(fp)
  46fe6c:	10800017 	ldw	r2,0(r2)
  46fe70:	e0bfef15 	stw	r2,-68(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
  46fe74:	e0bfef17 	ldw	r2,-68(fp)
  46fe78:	103fc71e 	bne	r2,zero,46fd98 <OSTaskChangePrio+0x448>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
  46fe7c:	e0bff217 	ldw	r2,-56(fp)
  46fe80:	e0ffff03 	ldbu	r3,-4(fp)
  46fe84:	10c00c85 	stb	r3,50(r2)
    ptcb->OSTCBY    = y_new;
  46fe88:	e0bff217 	ldw	r2,-56(fp)
  46fe8c:	e0fff303 	ldbu	r3,-52(fp)
  46fe90:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX    = x_new;
  46fe94:	e0bff217 	ldw	r2,-56(fp)
  46fe98:	e0fff343 	ldbu	r3,-51(fp)
  46fe9c:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY = bity_new;
  46fea0:	e0bff217 	ldw	r2,-56(fp)
  46fea4:	e0fff383 	ldbu	r3,-50(fp)
  46fea8:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX = bitx_new;
  46feac:	e0bff217 	ldw	r2,-56(fp)
  46feb0:	e0fff3c3 	ldbu	r3,-49(fp)
  46feb4:	10c00d45 	stb	r3,53(r2)
  46feb8:	e0bff117 	ldw	r2,-60(fp)
  46febc:	e0bffc15 	stw	r2,-16(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46fec0:	0005303a 	rdctl	r2,status
  46fec4:	e0bffd15 	stw	r2,-12(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46fec8:	e0fffd17 	ldw	r3,-12(fp)
  46fecc:	00bfff84 	movi	r2,-2
  46fed0:	1884703a 	and	r2,r3,r2
  46fed4:	e0bffd15 	stw	r2,-12(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46fed8:	e0bffc17 	ldw	r2,-16(fp)
  46fedc:	1080004c 	andi	r2,r2,1
  46fee0:	e0fffd17 	ldw	r3,-12(fp)
  46fee4:	1884b03a 	or	r2,r3,r2
  46fee8:	e0bffd15 	stw	r2,-12(fp)
  
  NIOS2_WRITE_STATUS (status);
  46feec:	e0bffd17 	ldw	r2,-12(fp)
  46fef0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
  46fef4:	00801234 	movhi	r2,72
  46fef8:	10a63e44 	addi	r2,r2,-26375
  46fefc:	10800003 	ldbu	r2,0(r2)
  46ff00:	10803fcc 	andi	r2,r2,255
  46ff04:	10800058 	cmpnei	r2,r2,1
  46ff08:	1000011e 	bne	r2,zero,46ff10 <OSTaskChangePrio+0x5c0>
        OS_Sched();                                         /* Find new highest priority task          */
  46ff0c:	046a4980 	call	46a498 <OS_Sched>
    }
    return (OS_ERR_NONE);
  46ff10:	0005883a 	mov	r2,zero
}
  46ff14:	e037883a 	mov	sp,fp
  46ff18:	dfc00117 	ldw	ra,4(sp)
  46ff1c:	df000017 	ldw	fp,0(sp)
  46ff20:	dec00204 	addi	sp,sp,8
  46ff24:	f800283a 	ret

0046ff28 <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
  46ff28:	deffea04 	addi	sp,sp,-88
  46ff2c:	dfc01515 	stw	ra,84(sp)
  46ff30:	df001415 	stw	fp,80(sp)
  46ff34:	df001404 	addi	fp,sp,80
  46ff38:	e13ffc15 	stw	r4,-16(fp)
  46ff3c:	e17ffd15 	stw	r5,-12(fp)
  46ff40:	e1bffe15 	stw	r6,-8(fp)
  46ff44:	3805883a 	mov	r2,r7
  46ff48:	e0bfff05 	stb	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
  46ff4c:	e03fef15 	stw	zero,-68(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
  46ff50:	e0bfff03 	ldbu	r2,-4(fp)
  46ff54:	10800570 	cmpltui	r2,r2,21
  46ff58:	1000021e 	bne	r2,zero,46ff64 <OSTaskCreate+0x3c>
        return (OS_ERR_PRIO_INVALID);
  46ff5c:	00800a84 	movi	r2,42
  46ff60:	00008706 	br	470180 <OSTaskCreate+0x258>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  46ff64:	0005303a 	rdctl	r2,status
  46ff68:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  46ff6c:	e0fff217 	ldw	r3,-56(fp)
  46ff70:	00bfff84 	movi	r2,-2
  46ff74:	1884703a 	and	r2,r3,r2
  46ff78:	1001703a 	wrctl	status,r2
  
  return context;
  46ff7c:	e0bff217 	ldw	r2,-56(fp)
    }
#endif
    OS_ENTER_CRITICAL();
  46ff80:	e0bfef15 	stw	r2,-68(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
  46ff84:	00801234 	movhi	r2,72
  46ff88:	10a64c04 	addi	r2,r2,-26320
  46ff8c:	10800003 	ldbu	r2,0(r2)
  46ff90:	10803fcc 	andi	r2,r2,255
  46ff94:	10001126 	beq	r2,zero,46ffdc <OSTaskCreate+0xb4>
  46ff98:	e0bfef17 	ldw	r2,-68(fp)
  46ff9c:	e0bff315 	stw	r2,-52(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  46ffa0:	0005303a 	rdctl	r2,status
  46ffa4:	e0bff415 	stw	r2,-48(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  46ffa8:	e0fff417 	ldw	r3,-48(fp)
  46ffac:	00bfff84 	movi	r2,-2
  46ffb0:	1884703a 	and	r2,r3,r2
  46ffb4:	e0bff415 	stw	r2,-48(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  46ffb8:	e0bff317 	ldw	r2,-52(fp)
  46ffbc:	1080004c 	andi	r2,r2,1
  46ffc0:	e0fff417 	ldw	r3,-48(fp)
  46ffc4:	1884b03a 	or	r2,r3,r2
  46ffc8:	e0bff415 	stw	r2,-48(fp)
  
  NIOS2_WRITE_STATUS (status);
  46ffcc:	e0bff417 	ldw	r2,-48(fp)
  46ffd0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
  46ffd4:	00800f04 	movi	r2,60
  46ffd8:	00006906 	br	470180 <OSTaskCreate+0x258>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
  46ffdc:	e0bfff03 	ldbu	r2,-4(fp)
  46ffe0:	00c01234 	movhi	r3,72
  46ffe4:	18f31404 	addi	r3,r3,-13232
  46ffe8:	1085883a 	add	r2,r2,r2
  46ffec:	1085883a 	add	r2,r2,r2
  46fff0:	1885883a 	add	r2,r3,r2
  46fff4:	10800017 	ldw	r2,0(r2)
  46fff8:	1000511e 	bne	r2,zero,470140 <OSTaskCreate+0x218>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
  46fffc:	e0bfff03 	ldbu	r2,-4(fp)
  470000:	00c01234 	movhi	r3,72
  470004:	18f31404 	addi	r3,r3,-13232
  470008:	1085883a 	add	r2,r2,r2
  47000c:	1085883a 	add	r2,r2,r2
  470010:	1885883a 	add	r2,r3,r2
  470014:	00c00044 	movi	r3,1
  470018:	10c00015 	stw	r3,0(r2)
  47001c:	e0bfef17 	ldw	r2,-68(fp)
  470020:	e0bff515 	stw	r2,-44(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  470024:	0005303a 	rdctl	r2,status
  470028:	e0bff615 	stw	r2,-40(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  47002c:	e0fff617 	ldw	r3,-40(fp)
  470030:	00bfff84 	movi	r2,-2
  470034:	1884703a 	and	r2,r3,r2
  470038:	e0bff615 	stw	r2,-40(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  47003c:	e0bff517 	ldw	r2,-44(fp)
  470040:	1080004c 	andi	r2,r2,1
  470044:	e0fff617 	ldw	r3,-40(fp)
  470048:	1884b03a 	or	r2,r3,r2
  47004c:	e0bff615 	stw	r2,-40(fp)
  
  NIOS2_WRITE_STATUS (status);
  470050:	e0bff617 	ldw	r2,-40(fp)
  470054:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
  470058:	e13ffc17 	ldw	r4,-16(fp)
  47005c:	e17ffd17 	ldw	r5,-12(fp)
  470060:	e1bffe17 	ldw	r6,-8(fp)
  470064:	000f883a 	mov	r7,zero
  470068:	04742540 	call	474254 <OSTaskStkInit>
  47006c:	e0bff015 	stw	r2,-64(fp)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
  470070:	e0bfff03 	ldbu	r2,-4(fp)
  470074:	d8000015 	stw	zero,0(sp)
  470078:	d8000115 	stw	zero,4(sp)
  47007c:	d8000215 	stw	zero,8(sp)
  470080:	1009883a 	mov	r4,r2
  470084:	e17ff017 	ldw	r5,-64(fp)
  470088:	000d883a 	mov	r6,zero
  47008c:	000f883a 	mov	r7,zero
  470090:	046a9140 	call	46a914 <OS_TCBInit>
  470094:	e0bff105 	stb	r2,-60(fp)
        if (err == OS_ERR_NONE) {
  470098:	e0bff103 	ldbu	r2,-60(fp)
  47009c:	1000081e 	bne	r2,zero,4700c0 <OSTaskCreate+0x198>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
  4700a0:	00801234 	movhi	r2,72
  4700a4:	10a63e44 	addi	r2,r2,-26375
  4700a8:	10800003 	ldbu	r2,0(r2)
  4700ac:	10803fcc 	andi	r2,r2,255
  4700b0:	10800058 	cmpnei	r2,r2,1
  4700b4:	1000201e 	bne	r2,zero,470138 <OSTaskCreate+0x210>
                OS_Sched();
  4700b8:	046a4980 	call	46a498 <OS_Sched>
  4700bc:	00001e06 	br	470138 <OSTaskCreate+0x210>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  4700c0:	0005303a 	rdctl	r2,status
  4700c4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  4700c8:	e0fff717 	ldw	r3,-36(fp)
  4700cc:	00bfff84 	movi	r2,-2
  4700d0:	1884703a 	and	r2,r3,r2
  4700d4:	1001703a 	wrctl	status,r2
  
  return context;
  4700d8:	e0bff717 	ldw	r2,-36(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
  4700dc:	e0bfef15 	stw	r2,-68(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
  4700e0:	e0bfff03 	ldbu	r2,-4(fp)
  4700e4:	00c01234 	movhi	r3,72
  4700e8:	18f31404 	addi	r3,r3,-13232
  4700ec:	1085883a 	add	r2,r2,r2
  4700f0:	1085883a 	add	r2,r2,r2
  4700f4:	1885883a 	add	r2,r3,r2
  4700f8:	10000015 	stw	zero,0(r2)
  4700fc:	e0bfef17 	ldw	r2,-68(fp)
  470100:	e0bff815 	stw	r2,-32(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  470104:	0005303a 	rdctl	r2,status
  470108:	e0bff915 	stw	r2,-28(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  47010c:	e0fff917 	ldw	r3,-28(fp)
  470110:	00bfff84 	movi	r2,-2
  470114:	1884703a 	and	r2,r3,r2
  470118:	e0bff915 	stw	r2,-28(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  47011c:	e0bff817 	ldw	r2,-32(fp)
  470120:	1080004c 	andi	r2,r2,1
  470124:	e0fff917 	ldw	r3,-28(fp)
  470128:	1884b03a 	or	r2,r3,r2
  47012c:	e0bff915 	stw	r2,-28(fp)
  
  NIOS2_WRITE_STATUS (status);
  470130:	e0bff917 	ldw	r2,-28(fp)
  470134:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
  470138:	e0bff103 	ldbu	r2,-60(fp)
  47013c:	00001006 	br	470180 <OSTaskCreate+0x258>
  470140:	e0bfef17 	ldw	r2,-68(fp)
  470144:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  470148:	0005303a 	rdctl	r2,status
  47014c:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  470150:	e0fffb17 	ldw	r3,-20(fp)
  470154:	00bfff84 	movi	r2,-2
  470158:	1884703a 	and	r2,r3,r2
  47015c:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  470160:	e0bffa17 	ldw	r2,-24(fp)
  470164:	1080004c 	andi	r2,r2,1
  470168:	e0fffb17 	ldw	r3,-20(fp)
  47016c:	1884b03a 	or	r2,r3,r2
  470170:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
  470174:	e0bffb17 	ldw	r2,-20(fp)
  470178:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
  47017c:	00800a04 	movi	r2,40
}
  470180:	e037883a 	mov	sp,fp
  470184:	dfc00117 	ldw	ra,4(sp)
  470188:	df000017 	ldw	fp,0(sp)
  47018c:	dec00204 	addi	sp,sp,8
  470190:	f800283a 	ret

00470194 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
  470194:	deffe804 	addi	sp,sp,-96
  470198:	dfc01715 	stw	ra,92(sp)
  47019c:	df001615 	stw	fp,88(sp)
  4701a0:	df001604 	addi	fp,sp,88
  4701a4:	e13ffa15 	stw	r4,-24(fp)
  4701a8:	e17ffb15 	stw	r5,-20(fp)
  4701ac:	e1bffc15 	stw	r6,-16(fp)
  4701b0:	3805883a 	mov	r2,r7
  4701b4:	e1000217 	ldw	r4,8(fp)
  4701b8:	e0c00617 	ldw	r3,24(fp)
  4701bc:	e0bffd05 	stb	r2,-12(fp)
  4701c0:	e13ffe0d 	sth	r4,-8(fp)
  4701c4:	e0ffff0d 	sth	r3,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
  4701c8:	e03fed15 	stw	zero,-76(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
  4701cc:	e0bffd03 	ldbu	r2,-12(fp)
  4701d0:	10800570 	cmpltui	r2,r2,21
  4701d4:	1000021e 	bne	r2,zero,4701e0 <OSTaskCreateExt+0x4c>
        return (OS_ERR_PRIO_INVALID);
  4701d8:	00800a84 	movi	r2,42
  4701dc:	00009106 	br	470424 <OSTaskCreateExt+0x290>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  4701e0:	0005303a 	rdctl	r2,status
  4701e4:	e0bff015 	stw	r2,-64(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  4701e8:	e0fff017 	ldw	r3,-64(fp)
  4701ec:	00bfff84 	movi	r2,-2
  4701f0:	1884703a 	and	r2,r3,r2
  4701f4:	1001703a 	wrctl	status,r2
  
  return context;
  4701f8:	e0bff017 	ldw	r2,-64(fp)
    }
#endif
    OS_ENTER_CRITICAL();
  4701fc:	e0bfed15 	stw	r2,-76(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
  470200:	00801234 	movhi	r2,72
  470204:	10a64c04 	addi	r2,r2,-26320
  470208:	10800003 	ldbu	r2,0(r2)
  47020c:	10803fcc 	andi	r2,r2,255
  470210:	10001126 	beq	r2,zero,470258 <OSTaskCreateExt+0xc4>
  470214:	e0bfed17 	ldw	r2,-76(fp)
  470218:	e0bff115 	stw	r2,-60(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  47021c:	0005303a 	rdctl	r2,status
  470220:	e0bff215 	stw	r2,-56(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  470224:	e0fff217 	ldw	r3,-56(fp)
  470228:	00bfff84 	movi	r2,-2
  47022c:	1884703a 	and	r2,r3,r2
  470230:	e0bff215 	stw	r2,-56(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  470234:	e0bff117 	ldw	r2,-60(fp)
  470238:	1080004c 	andi	r2,r2,1
  47023c:	e0fff217 	ldw	r3,-56(fp)
  470240:	1884b03a 	or	r2,r3,r2
  470244:	e0bff215 	stw	r2,-56(fp)
  
  NIOS2_WRITE_STATUS (status);
  470248:	e0bff217 	ldw	r2,-56(fp)
  47024c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
  470250:	00800f04 	movi	r2,60
  470254:	00007306 	br	470424 <OSTaskCreateExt+0x290>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
  470258:	e0bffd03 	ldbu	r2,-12(fp)
  47025c:	00c01234 	movhi	r3,72
  470260:	18f31404 	addi	r3,r3,-13232
  470264:	1085883a 	add	r2,r2,r2
  470268:	1085883a 	add	r2,r2,r2
  47026c:	1885883a 	add	r2,r3,r2
  470270:	10800017 	ldw	r2,0(r2)
  470274:	10005b1e 	bne	r2,zero,4703e4 <OSTaskCreateExt+0x250>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
  470278:	e0bffd03 	ldbu	r2,-12(fp)
  47027c:	00c01234 	movhi	r3,72
  470280:	18f31404 	addi	r3,r3,-13232
  470284:	1085883a 	add	r2,r2,r2
  470288:	1085883a 	add	r2,r2,r2
  47028c:	1885883a 	add	r2,r3,r2
  470290:	00c00044 	movi	r3,1
  470294:	10c00015 	stw	r3,0(r2)
  470298:	e0bfed17 	ldw	r2,-76(fp)
  47029c:	e0bff315 	stw	r2,-52(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  4702a0:	0005303a 	rdctl	r2,status
  4702a4:	e0bff415 	stw	r2,-48(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  4702a8:	e0fff417 	ldw	r3,-48(fp)
  4702ac:	00bfff84 	movi	r2,-2
  4702b0:	1884703a 	and	r2,r3,r2
  4702b4:	e0bff415 	stw	r2,-48(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  4702b8:	e0bff317 	ldw	r2,-52(fp)
  4702bc:	1080004c 	andi	r2,r2,1
  4702c0:	e0fff417 	ldw	r3,-48(fp)
  4702c4:	1884b03a 	or	r2,r3,r2
  4702c8:	e0bff415 	stw	r2,-48(fp)
  
  NIOS2_WRITE_STATUS (status);
  4702cc:	e0bff417 	ldw	r2,-48(fp)
  4702d0:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
  4702d4:	e0bfff0b 	ldhu	r2,-4(fp)
  4702d8:	e1000317 	ldw	r4,12(fp)
  4702dc:	e1400417 	ldw	r5,16(fp)
  4702e0:	100d883a 	mov	r6,r2
  4702e4:	04719300 	call	471930 <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
  4702e8:	e0bfff0b 	ldhu	r2,-4(fp)
  4702ec:	e13ffa17 	ldw	r4,-24(fp)
  4702f0:	e17ffb17 	ldw	r5,-20(fp)
  4702f4:	e1bffc17 	ldw	r6,-16(fp)
  4702f8:	100f883a 	mov	r7,r2
  4702fc:	04742540 	call	474254 <OSTaskStkInit>
  470300:	e0bfee15 	stw	r2,-72(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
  470304:	e0fffd03 	ldbu	r3,-12(fp)
  470308:	e0bffe0b 	ldhu	r2,-8(fp)
  47030c:	e13fff0b 	ldhu	r4,-4(fp)
  470310:	e1400417 	ldw	r5,16(fp)
  470314:	d9400015 	stw	r5,0(sp)
  470318:	e1400517 	ldw	r5,20(fp)
  47031c:	d9400115 	stw	r5,4(sp)
  470320:	d9000215 	stw	r4,8(sp)
  470324:	1809883a 	mov	r4,r3
  470328:	e17fee17 	ldw	r5,-72(fp)
  47032c:	e1800317 	ldw	r6,12(fp)
  470330:	100f883a 	mov	r7,r2
  470334:	046a9140 	call	46a914 <OS_TCBInit>
  470338:	e0bfef05 	stb	r2,-68(fp)
        if (err == OS_ERR_NONE) {
  47033c:	e0bfef03 	ldbu	r2,-68(fp)
  470340:	1000081e 	bne	r2,zero,470364 <OSTaskCreateExt+0x1d0>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
  470344:	00801234 	movhi	r2,72
  470348:	10a63e44 	addi	r2,r2,-26375
  47034c:	10800003 	ldbu	r2,0(r2)
  470350:	10803fcc 	andi	r2,r2,255
  470354:	10800058 	cmpnei	r2,r2,1
  470358:	1000201e 	bne	r2,zero,4703dc <OSTaskCreateExt+0x248>
                OS_Sched();
  47035c:	046a4980 	call	46a498 <OS_Sched>
  470360:	00001e06 	br	4703dc <OSTaskCreateExt+0x248>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  470364:	0005303a 	rdctl	r2,status
  470368:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  47036c:	e0fff517 	ldw	r3,-44(fp)
  470370:	00bfff84 	movi	r2,-2
  470374:	1884703a 	and	r2,r3,r2
  470378:	1001703a 	wrctl	status,r2
  
  return context;
  47037c:	e0bff517 	ldw	r2,-44(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
  470380:	e0bfed15 	stw	r2,-76(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
  470384:	e0bffd03 	ldbu	r2,-12(fp)
  470388:	00c01234 	movhi	r3,72
  47038c:	18f31404 	addi	r3,r3,-13232
  470390:	1085883a 	add	r2,r2,r2
  470394:	1085883a 	add	r2,r2,r2
  470398:	1885883a 	add	r2,r3,r2
  47039c:	10000015 	stw	zero,0(r2)
  4703a0:	e0bfed17 	ldw	r2,-76(fp)
  4703a4:	e0bff615 	stw	r2,-40(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  4703a8:	0005303a 	rdctl	r2,status
  4703ac:	e0bff715 	stw	r2,-36(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  4703b0:	e0fff717 	ldw	r3,-36(fp)
  4703b4:	00bfff84 	movi	r2,-2
  4703b8:	1884703a 	and	r2,r3,r2
  4703bc:	e0bff715 	stw	r2,-36(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  4703c0:	e0bff617 	ldw	r2,-40(fp)
  4703c4:	1080004c 	andi	r2,r2,1
  4703c8:	e0fff717 	ldw	r3,-36(fp)
  4703cc:	1884b03a 	or	r2,r3,r2
  4703d0:	e0bff715 	stw	r2,-36(fp)
  
  NIOS2_WRITE_STATUS (status);
  4703d4:	e0bff717 	ldw	r2,-36(fp)
  4703d8:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
  4703dc:	e0bfef03 	ldbu	r2,-68(fp)
  4703e0:	00001006 	br	470424 <OSTaskCreateExt+0x290>
  4703e4:	e0bfed17 	ldw	r2,-76(fp)
  4703e8:	e0bff815 	stw	r2,-32(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  4703ec:	0005303a 	rdctl	r2,status
  4703f0:	e0bff915 	stw	r2,-28(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  4703f4:	e0fff917 	ldw	r3,-28(fp)
  4703f8:	00bfff84 	movi	r2,-2
  4703fc:	1884703a 	and	r2,r3,r2
  470400:	e0bff915 	stw	r2,-28(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  470404:	e0bff817 	ldw	r2,-32(fp)
  470408:	1080004c 	andi	r2,r2,1
  47040c:	e0fff917 	ldw	r3,-28(fp)
  470410:	1884b03a 	or	r2,r3,r2
  470414:	e0bff915 	stw	r2,-28(fp)
  
  NIOS2_WRITE_STATUS (status);
  470418:	e0bff917 	ldw	r2,-28(fp)
  47041c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
  470420:	00800a04 	movi	r2,40
}
  470424:	e037883a 	mov	sp,fp
  470428:	dfc00117 	ldw	ra,4(sp)
  47042c:	df000017 	ldw	fp,0(sp)
  470430:	dec00204 	addi	sp,sp,8
  470434:	f800283a 	ret

00470438 <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
  470438:	defff004 	addi	sp,sp,-64
  47043c:	dfc00f15 	stw	ra,60(sp)
  470440:	df000e15 	stw	fp,56(sp)
  470444:	df000e04 	addi	fp,sp,56
  470448:	2005883a 	mov	r2,r4
  47044c:	e0bfff05 	stb	r2,-4(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
  470450:	e03ff215 	stw	zero,-56(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
  470454:	00801234 	movhi	r2,72
  470458:	10a64c04 	addi	r2,r2,-26320
  47045c:	10800003 	ldbu	r2,0(r2)
  470460:	10803fcc 	andi	r2,r2,255
  470464:	10000226 	beq	r2,zero,470470 <OSTaskDel+0x38>
        return (OS_ERR_TASK_DEL_ISR);
  470468:	00801004 	movi	r2,64
  47046c:	00011006 	br	4708b0 <OSTaskDel+0x478>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
  470470:	e0bfff03 	ldbu	r2,-4(fp)
  470474:	10800518 	cmpnei	r2,r2,20
  470478:	1000021e 	bne	r2,zero,470484 <OSTaskDel+0x4c>
        return (OS_ERR_TASK_DEL_IDLE);
  47047c:	00800f84 	movi	r2,62
  470480:	00010b06 	br	4708b0 <OSTaskDel+0x478>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
  470484:	e0bfff03 	ldbu	r2,-4(fp)
  470488:	10800530 	cmpltui	r2,r2,20
  47048c:	1000051e 	bne	r2,zero,4704a4 <OSTaskDel+0x6c>
        if (prio != OS_PRIO_SELF) {
  470490:	e0bfff03 	ldbu	r2,-4(fp)
  470494:	10803fe0 	cmpeqi	r2,r2,255
  470498:	1000021e 	bne	r2,zero,4704a4 <OSTaskDel+0x6c>
            return (OS_ERR_PRIO_INVALID);
  47049c:	00800a84 	movi	r2,42
  4704a0:	00010306 	br	4708b0 <OSTaskDel+0x478>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  4704a4:	0005303a 	rdctl	r2,status
  4704a8:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  4704ac:	e0fff517 	ldw	r3,-44(fp)
  4704b0:	00bfff84 	movi	r2,-2
  4704b4:	1884703a 	and	r2,r3,r2
  4704b8:	1001703a 	wrctl	status,r2
  
  return context;
  4704bc:	e0bff517 	ldw	r2,-44(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
  4704c0:	e0bff215 	stw	r2,-56(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
  4704c4:	e0bfff03 	ldbu	r2,-4(fp)
  4704c8:	10803fd8 	cmpnei	r2,r2,255
  4704cc:	1000051e 	bne	r2,zero,4704e4 <OSTaskDel+0xac>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
  4704d0:	00801234 	movhi	r2,72
  4704d4:	10a64d04 	addi	r2,r2,-26316
  4704d8:	10800017 	ldw	r2,0(r2)
  4704dc:	10800c83 	ldbu	r2,50(r2)
  4704e0:	e0bfff05 	stb	r2,-4(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
  4704e4:	e0bfff03 	ldbu	r2,-4(fp)
  4704e8:	00c01234 	movhi	r3,72
  4704ec:	18f31404 	addi	r3,r3,-13232
  4704f0:	1085883a 	add	r2,r2,r2
  4704f4:	1085883a 	add	r2,r2,r2
  4704f8:	1885883a 	add	r2,r3,r2
  4704fc:	10800017 	ldw	r2,0(r2)
  470500:	e0bff315 	stw	r2,-52(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
  470504:	e0bff317 	ldw	r2,-52(fp)
  470508:	1000111e 	bne	r2,zero,470550 <OSTaskDel+0x118>
  47050c:	e0bff217 	ldw	r2,-56(fp)
  470510:	e0bff615 	stw	r2,-40(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  470514:	0005303a 	rdctl	r2,status
  470518:	e0bff715 	stw	r2,-36(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  47051c:	e0fff717 	ldw	r3,-36(fp)
  470520:	00bfff84 	movi	r2,-2
  470524:	1884703a 	and	r2,r3,r2
  470528:	e0bff715 	stw	r2,-36(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  47052c:	e0bff617 	ldw	r2,-40(fp)
  470530:	1080004c 	andi	r2,r2,1
  470534:	e0fff717 	ldw	r3,-36(fp)
  470538:	1884b03a 	or	r2,r3,r2
  47053c:	e0bff715 	stw	r2,-36(fp)
  
  NIOS2_WRITE_STATUS (status);
  470540:	e0bff717 	ldw	r2,-36(fp)
  470544:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
  470548:	008010c4 	movi	r2,67
  47054c:	0000d806 	br	4708b0 <OSTaskDel+0x478>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
  470550:	e0bff317 	ldw	r2,-52(fp)
  470554:	10800058 	cmpnei	r2,r2,1
  470558:	1000111e 	bne	r2,zero,4705a0 <OSTaskDel+0x168>
  47055c:	e0bff217 	ldw	r2,-56(fp)
  470560:	e0bff815 	stw	r2,-32(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  470564:	0005303a 	rdctl	r2,status
  470568:	e0bff915 	stw	r2,-28(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  47056c:	e0fff917 	ldw	r3,-28(fp)
  470570:	00bfff84 	movi	r2,-2
  470574:	1884703a 	and	r2,r3,r2
  470578:	e0bff915 	stw	r2,-28(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  47057c:	e0bff817 	ldw	r2,-32(fp)
  470580:	1080004c 	andi	r2,r2,1
  470584:	e0fff917 	ldw	r3,-28(fp)
  470588:	1884b03a 	or	r2,r3,r2
  47058c:	e0bff915 	stw	r2,-28(fp)
  
  NIOS2_WRITE_STATUS (status);
  470590:	e0bff917 	ldw	r2,-28(fp)
  470594:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
  470598:	00800f44 	movi	r2,61
  47059c:	0000c406 	br	4708b0 <OSTaskDel+0x478>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
  4705a0:	e0bff317 	ldw	r2,-52(fp)
  4705a4:	10800d03 	ldbu	r2,52(r2)
  4705a8:	10803fcc 	andi	r2,r2,255
  4705ac:	e0fff317 	ldw	r3,-52(fp)
  4705b0:	18c00d03 	ldbu	r3,52(r3)
  4705b4:	18c03fcc 	andi	r3,r3,255
  4705b8:	01001234 	movhi	r4,72
  4705bc:	21264a44 	addi	r4,r4,-26327
  4705c0:	20c7883a 	add	r3,r4,r3
  4705c4:	18c00003 	ldbu	r3,0(r3)
  4705c8:	1809883a 	mov	r4,r3
  4705cc:	e0fff317 	ldw	r3,-52(fp)
  4705d0:	18c00d43 	ldbu	r3,53(r3)
  4705d4:	00c6303a 	nor	r3,zero,r3
  4705d8:	20c6703a 	and	r3,r4,r3
  4705dc:	01001234 	movhi	r4,72
  4705e0:	21264a44 	addi	r4,r4,-26327
  4705e4:	2085883a 	add	r2,r4,r2
  4705e8:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
  4705ec:	e0bff317 	ldw	r2,-52(fp)
  4705f0:	10800d03 	ldbu	r2,52(r2)
  4705f4:	10803fcc 	andi	r2,r2,255
  4705f8:	00c01234 	movhi	r3,72
  4705fc:	18e64a44 	addi	r3,r3,-26327
  470600:	1885883a 	add	r2,r3,r2
  470604:	10800003 	ldbu	r2,0(r2)
  470608:	10803fcc 	andi	r2,r2,255
  47060c:	10000c1e 	bne	r2,zero,470640 <OSTaskDel+0x208>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
  470610:	e0bff317 	ldw	r2,-52(fp)
  470614:	10800d83 	ldbu	r2,54(r2)
  470618:	0084303a 	nor	r2,zero,r2
  47061c:	1007883a 	mov	r3,r2
  470620:	00801234 	movhi	r2,72
  470624:	10a64a04 	addi	r2,r2,-26328
  470628:	10800003 	ldbu	r2,0(r2)
  47062c:	1884703a 	and	r2,r3,r2
  470630:	1007883a 	mov	r3,r2
  470634:	00801234 	movhi	r2,72
  470638:	10a64a04 	addi	r2,r2,-26328
  47063c:	10c00005 	stb	r3,0(r2)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
  470640:	e0bff317 	ldw	r2,-52(fp)
  470644:	10800717 	ldw	r2,28(r2)
  470648:	10000526 	beq	r2,zero,470660 <OSTaskDel+0x228>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
  47064c:	e0bff317 	ldw	r2,-52(fp)
  470650:	10800717 	ldw	r2,28(r2)
  470654:	e13ff317 	ldw	r4,-52(fp)
  470658:	100b883a 	mov	r5,r2
  47065c:	0469e640 	call	469e64 <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
  470660:	e0bff317 	ldw	r2,-52(fp)
  470664:	10800817 	ldw	r2,32(r2)
  470668:	10000526 	beq	r2,zero,470680 <OSTaskDel+0x248>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
  47066c:	e0bff317 	ldw	r2,-52(fp)
  470670:	10800817 	ldw	r2,32(r2)
  470674:	e13ff317 	ldw	r4,-52(fp)
  470678:	100b883a 	mov	r5,r2
  47067c:	0469f140 	call	469f14 <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
  470680:	e0bff317 	ldw	r2,-52(fp)
  470684:	10800a17 	ldw	r2,40(r2)
  470688:	e0bff415 	stw	r2,-48(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
  47068c:	e0bff417 	ldw	r2,-48(fp)
  470690:	10000226 	beq	r2,zero,47069c <OSTaskDel+0x264>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
  470694:	e13ff417 	ldw	r4,-48(fp)
  470698:	046cb680 	call	46cb68 <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
  47069c:	e0bff317 	ldw	r2,-52(fp)
  4706a0:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
  4706a4:	e0bff317 	ldw	r2,-52(fp)
  4706a8:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
  4706ac:	e0bff317 	ldw	r2,-52(fp)
  4706b0:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
  4706b4:	00801234 	movhi	r2,72
  4706b8:	10a63e04 	addi	r2,r2,-26376
  4706bc:	10800003 	ldbu	r2,0(r2)
  4706c0:	10803fcc 	andi	r2,r2,255
  4706c4:	10803fe0 	cmpeqi	r2,r2,255
  4706c8:	1000081e 	bne	r2,zero,4706ec <OSTaskDel+0x2b4>
        OSLockNesting++;
  4706cc:	00801234 	movhi	r2,72
  4706d0:	10a63e04 	addi	r2,r2,-26376
  4706d4:	10800003 	ldbu	r2,0(r2)
  4706d8:	10800044 	addi	r2,r2,1
  4706dc:	1007883a 	mov	r3,r2
  4706e0:	00801234 	movhi	r2,72
  4706e4:	10a63e04 	addi	r2,r2,-26376
  4706e8:	10c00005 	stb	r3,0(r2)
  4706ec:	e0bff217 	ldw	r2,-56(fp)
  4706f0:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  4706f4:	0005303a 	rdctl	r2,status
  4706f8:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  4706fc:	e0fffb17 	ldw	r3,-20(fp)
  470700:	00bfff84 	movi	r2,-2
  470704:	1884703a 	and	r2,r3,r2
  470708:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  47070c:	e0bffa17 	ldw	r2,-24(fp)
  470710:	1080004c 	andi	r2,r2,1
  470714:	e0fffb17 	ldw	r3,-20(fp)
  470718:	1884b03a 	or	r2,r3,r2
  47071c:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
  470720:	e0bffb17 	ldw	r2,-20(fp)
  470724:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
  470728:	0469a600 	call	469a60 <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  47072c:	0005303a 	rdctl	r2,status
  470730:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  470734:	e0fffc17 	ldw	r3,-16(fp)
  470738:	00bfff84 	movi	r2,-2
  47073c:	1884703a 	and	r2,r3,r2
  470740:	1001703a 	wrctl	status,r2
  
  return context;
  470744:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
  470748:	e0bff215 	stw	r2,-56(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
  47074c:	00801234 	movhi	r2,72
  470750:	10a63e04 	addi	r2,r2,-26376
  470754:	10800003 	ldbu	r2,0(r2)
  470758:	10803fcc 	andi	r2,r2,255
  47075c:	10000826 	beq	r2,zero,470780 <OSTaskDel+0x348>
        OSLockNesting--;
  470760:	00801234 	movhi	r2,72
  470764:	10a63e04 	addi	r2,r2,-26376
  470768:	10800003 	ldbu	r2,0(r2)
  47076c:	10bfffc4 	addi	r2,r2,-1
  470770:	1007883a 	mov	r3,r2
  470774:	00801234 	movhi	r2,72
  470778:	10a63e04 	addi	r2,r2,-26376
  47077c:	10c00005 	stb	r3,0(r2)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
  470780:	e13ff317 	ldw	r4,-52(fp)
  470784:	04745680 	call	474568 <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
  470788:	00801234 	movhi	r2,72
  47078c:	10a64644 	addi	r2,r2,-26343
  470790:	10800003 	ldbu	r2,0(r2)
  470794:	10bfffc4 	addi	r2,r2,-1
  470798:	1007883a 	mov	r3,r2
  47079c:	00801234 	movhi	r2,72
  4707a0:	10a64644 	addi	r2,r2,-26343
  4707a4:	10c00005 	stb	r3,0(r2)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
  4707a8:	e0bfff03 	ldbu	r2,-4(fp)
  4707ac:	00c01234 	movhi	r3,72
  4707b0:	18f31404 	addi	r3,r3,-13232
  4707b4:	1085883a 	add	r2,r2,r2
  4707b8:	1085883a 	add	r2,r2,r2
  4707bc:	1885883a 	add	r2,r3,r2
  4707c0:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
  4707c4:	e0bff317 	ldw	r2,-52(fp)
  4707c8:	10800617 	ldw	r2,24(r2)
  4707cc:	1000091e 	bne	r2,zero,4707f4 <OSTaskDel+0x3bc>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
  4707d0:	e0bff317 	ldw	r2,-52(fp)
  4707d4:	10800517 	ldw	r2,20(r2)
  4707d8:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
  4707dc:	e0bff317 	ldw	r2,-52(fp)
  4707e0:	10c00517 	ldw	r3,20(r2)
  4707e4:	00801234 	movhi	r2,72
  4707e8:	10a64104 	addi	r2,r2,-26364
  4707ec:	10c00015 	stw	r3,0(r2)
  4707f0:	00000a06 	br	47081c <OSTaskDel+0x3e4>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
  4707f4:	e0bff317 	ldw	r2,-52(fp)
  4707f8:	10800617 	ldw	r2,24(r2)
  4707fc:	e0fff317 	ldw	r3,-52(fp)
  470800:	18c00517 	ldw	r3,20(r3)
  470804:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
  470808:	e0bff317 	ldw	r2,-52(fp)
  47080c:	10800517 	ldw	r2,20(r2)
  470810:	e0fff317 	ldw	r3,-52(fp)
  470814:	18c00617 	ldw	r3,24(r3)
  470818:	10c00615 	stw	r3,24(r2)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
  47081c:	00801234 	movhi	r2,72
  470820:	10a64504 	addi	r2,r2,-26348
  470824:	10c00017 	ldw	r3,0(r2)
  470828:	e0bff317 	ldw	r2,-52(fp)
  47082c:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
  470830:	00801234 	movhi	r2,72
  470834:	10a64504 	addi	r2,r2,-26348
  470838:	e0fff317 	ldw	r3,-52(fp)
  47083c:	10c00015 	stw	r3,0(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
  470840:	e0bff317 	ldw	r2,-52(fp)
  470844:	00c00fc4 	movi	r3,63
  470848:	10c01305 	stb	r3,76(r2)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
  47084c:	e0bff317 	ldw	r2,-52(fp)
  470850:	10001345 	stb	zero,77(r2)
  470854:	e0bff217 	ldw	r2,-56(fp)
  470858:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  47085c:	0005303a 	rdctl	r2,status
  470860:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  470864:	e0fffe17 	ldw	r3,-8(fp)
  470868:	00bfff84 	movi	r2,-2
  47086c:	1884703a 	and	r2,r3,r2
  470870:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  470874:	e0bffd17 	ldw	r2,-12(fp)
  470878:	1080004c 	andi	r2,r2,1
  47087c:	e0fffe17 	ldw	r3,-8(fp)
  470880:	1884b03a 	or	r2,r3,r2
  470884:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
  470888:	e0bffe17 	ldw	r2,-8(fp)
  47088c:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
  470890:	00801234 	movhi	r2,72
  470894:	10a63e44 	addi	r2,r2,-26375
  470898:	10800003 	ldbu	r2,0(r2)
  47089c:	10803fcc 	andi	r2,r2,255
  4708a0:	10800058 	cmpnei	r2,r2,1
  4708a4:	1000011e 	bne	r2,zero,4708ac <OSTaskDel+0x474>
        OS_Sched();                                     /* Find new highest priority task              */
  4708a8:	046a4980 	call	46a498 <OS_Sched>
    }
    return (OS_ERR_NONE);
  4708ac:	0005883a 	mov	r2,zero
}
  4708b0:	e037883a 	mov	sp,fp
  4708b4:	dfc00117 	ldw	ra,4(sp)
  4708b8:	df000017 	ldw	fp,0(sp)
  4708bc:	dec00204 	addi	sp,sp,8
  4708c0:	f800283a 	ret

004708c4 <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
  4708c4:	defff104 	addi	sp,sp,-60
  4708c8:	df000e15 	stw	fp,56(sp)
  4708cc:	df000e04 	addi	fp,sp,56
  4708d0:	2005883a 	mov	r2,r4
  4708d4:	e0bfff05 	stb	r2,-4(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
  4708d8:	e03ff215 	stw	zero,-56(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
  4708dc:	e0bfff03 	ldbu	r2,-4(fp)
  4708e0:	10800518 	cmpnei	r2,r2,20
  4708e4:	1000021e 	bne	r2,zero,4708f0 <OSTaskDelReq+0x2c>
        return (OS_ERR_TASK_DEL_IDLE);
  4708e8:	00800f84 	movi	r2,62
  4708ec:	00007306 	br	470abc <OSTaskDelReq+0x1f8>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
  4708f0:	e0bfff03 	ldbu	r2,-4(fp)
  4708f4:	10800530 	cmpltui	r2,r2,20
  4708f8:	1000051e 	bne	r2,zero,470910 <OSTaskDelReq+0x4c>
        if (prio != OS_PRIO_SELF) {
  4708fc:	e0bfff03 	ldbu	r2,-4(fp)
  470900:	10803fe0 	cmpeqi	r2,r2,255
  470904:	1000021e 	bne	r2,zero,470910 <OSTaskDelReq+0x4c>
            return (OS_ERR_PRIO_INVALID);
  470908:	00800a84 	movi	r2,42
  47090c:	00006b06 	br	470abc <OSTaskDelReq+0x1f8>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
  470910:	e0bfff03 	ldbu	r2,-4(fp)
  470914:	10803fd8 	cmpnei	r2,r2,255
  470918:	10001e1e 	bne	r2,zero,470994 <OSTaskDelReq+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  47091c:	0005303a 	rdctl	r2,status
  470920:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  470924:	e0fff517 	ldw	r3,-44(fp)
  470928:	00bfff84 	movi	r2,-2
  47092c:	1884703a 	and	r2,r3,r2
  470930:	1001703a 	wrctl	status,r2
  
  return context;
  470934:	e0bff517 	ldw	r2,-44(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
  470938:	e0bff215 	stw	r2,-56(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
  47093c:	00801234 	movhi	r2,72
  470940:	10a64d04 	addi	r2,r2,-26316
  470944:	10800017 	ldw	r2,0(r2)
  470948:	10800dc3 	ldbu	r2,55(r2)
  47094c:	e0bff305 	stb	r2,-52(fp)
  470950:	e0bff217 	ldw	r2,-56(fp)
  470954:	e0bff615 	stw	r2,-40(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  470958:	0005303a 	rdctl	r2,status
  47095c:	e0bff715 	stw	r2,-36(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  470960:	e0fff717 	ldw	r3,-36(fp)
  470964:	00bfff84 	movi	r2,-2
  470968:	1884703a 	and	r2,r3,r2
  47096c:	e0bff715 	stw	r2,-36(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  470970:	e0bff617 	ldw	r2,-40(fp)
  470974:	1080004c 	andi	r2,r2,1
  470978:	e0fff717 	ldw	r3,-36(fp)
  47097c:	1884b03a 	or	r2,r3,r2
  470980:	e0bff715 	stw	r2,-36(fp)
  
  NIOS2_WRITE_STATUS (status);
  470984:	e0bff717 	ldw	r2,-36(fp)
  470988:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
  47098c:	e0bff303 	ldbu	r2,-52(fp)
  470990:	00004a06 	br	470abc <OSTaskDelReq+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  470994:	0005303a 	rdctl	r2,status
  470998:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  47099c:	e0fff817 	ldw	r3,-32(fp)
  4709a0:	00bfff84 	movi	r2,-2
  4709a4:	1884703a 	and	r2,r3,r2
  4709a8:	1001703a 	wrctl	status,r2
  
  return context;
  4709ac:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
  4709b0:	e0bff215 	stw	r2,-56(fp)
    ptcb = OSTCBPrioTbl[prio];
  4709b4:	e0bfff03 	ldbu	r2,-4(fp)
  4709b8:	00c01234 	movhi	r3,72
  4709bc:	18f31404 	addi	r3,r3,-13232
  4709c0:	1085883a 	add	r2,r2,r2
  4709c4:	1085883a 	add	r2,r2,r2
  4709c8:	1885883a 	add	r2,r3,r2
  4709cc:	10800017 	ldw	r2,0(r2)
  4709d0:	e0bff415 	stw	r2,-48(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
  4709d4:	e0bff417 	ldw	r2,-48(fp)
  4709d8:	1000111e 	bne	r2,zero,470a20 <OSTaskDelReq+0x15c>
  4709dc:	e0bff217 	ldw	r2,-56(fp)
  4709e0:	e0bff915 	stw	r2,-28(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  4709e4:	0005303a 	rdctl	r2,status
  4709e8:	e0bffa15 	stw	r2,-24(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  4709ec:	e0fffa17 	ldw	r3,-24(fp)
  4709f0:	00bfff84 	movi	r2,-2
  4709f4:	1884703a 	and	r2,r3,r2
  4709f8:	e0bffa15 	stw	r2,-24(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  4709fc:	e0bff917 	ldw	r2,-28(fp)
  470a00:	1080004c 	andi	r2,r2,1
  470a04:	e0fffa17 	ldw	r3,-24(fp)
  470a08:	1884b03a 	or	r2,r3,r2
  470a0c:	e0bffa15 	stw	r2,-24(fp)
  
  NIOS2_WRITE_STATUS (status);
  470a10:	e0bffa17 	ldw	r2,-24(fp)
  470a14:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
  470a18:	008010c4 	movi	r2,67
  470a1c:	00002706 	br	470abc <OSTaskDelReq+0x1f8>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
  470a20:	e0bff417 	ldw	r2,-48(fp)
  470a24:	10800058 	cmpnei	r2,r2,1
  470a28:	1000111e 	bne	r2,zero,470a70 <OSTaskDelReq+0x1ac>
  470a2c:	e0bff217 	ldw	r2,-56(fp)
  470a30:	e0bffb15 	stw	r2,-20(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  470a34:	0005303a 	rdctl	r2,status
  470a38:	e0bffc15 	stw	r2,-16(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  470a3c:	e0fffc17 	ldw	r3,-16(fp)
  470a40:	00bfff84 	movi	r2,-2
  470a44:	1884703a 	and	r2,r3,r2
  470a48:	e0bffc15 	stw	r2,-16(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  470a4c:	e0bffb17 	ldw	r2,-20(fp)
  470a50:	1080004c 	andi	r2,r2,1
  470a54:	e0fffc17 	ldw	r3,-16(fp)
  470a58:	1884b03a 	or	r2,r3,r2
  470a5c:	e0bffc15 	stw	r2,-16(fp)
  
  NIOS2_WRITE_STATUS (status);
  470a60:	e0bffc17 	ldw	r2,-16(fp)
  470a64:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
  470a68:	00800f44 	movi	r2,61
  470a6c:	00001306 	br	470abc <OSTaskDelReq+0x1f8>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
  470a70:	e0bff417 	ldw	r2,-48(fp)
  470a74:	00c00fc4 	movi	r3,63
  470a78:	10c00dc5 	stb	r3,55(r2)
  470a7c:	e0bff217 	ldw	r2,-56(fp)
  470a80:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  470a84:	0005303a 	rdctl	r2,status
  470a88:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  470a8c:	e0fffe17 	ldw	r3,-8(fp)
  470a90:	00bfff84 	movi	r2,-2
  470a94:	1884703a 	and	r2,r3,r2
  470a98:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  470a9c:	e0bffd17 	ldw	r2,-12(fp)
  470aa0:	1080004c 	andi	r2,r2,1
  470aa4:	e0fffe17 	ldw	r3,-8(fp)
  470aa8:	1884b03a 	or	r2,r3,r2
  470aac:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
  470ab0:	e0bffe17 	ldw	r2,-8(fp)
  470ab4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
  470ab8:	0005883a 	mov	r2,zero
}
  470abc:	e037883a 	mov	sp,fp
  470ac0:	df000017 	ldw	fp,0(sp)
  470ac4:	dec00104 	addi	sp,sp,4
  470ac8:	f800283a 	ret

00470acc <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
  470acc:	defff104 	addi	sp,sp,-60
  470ad0:	dfc00e15 	stw	ra,56(sp)
  470ad4:	df000d15 	stw	fp,52(sp)
  470ad8:	df000d04 	addi	fp,sp,52
  470adc:	2005883a 	mov	r2,r4
  470ae0:	e17ffe15 	stw	r5,-8(fp)
  470ae4:	e1bfff15 	stw	r6,-4(fp)
  470ae8:	e0bffd05 	stb	r2,-12(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
  470aec:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
  470af0:	e0bfff17 	ldw	r2,-4(fp)
  470af4:	1000021e 	bne	r2,zero,470b00 <OSTaskNameGet+0x34>
        return (0);
  470af8:	0005883a 	mov	r2,zero
  470afc:	00007906 	br	470ce4 <OSTaskNameGet+0x218>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
  470b00:	e0bffd03 	ldbu	r2,-12(fp)
  470b04:	10800570 	cmpltui	r2,r2,21
  470b08:	1000081e 	bne	r2,zero,470b2c <OSTaskNameGet+0x60>
        if (prio != OS_PRIO_SELF) {
  470b0c:	e0bffd03 	ldbu	r2,-12(fp)
  470b10:	10803fe0 	cmpeqi	r2,r2,255
  470b14:	1000051e 	bne	r2,zero,470b2c <OSTaskNameGet+0x60>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
  470b18:	e0bfff17 	ldw	r2,-4(fp)
  470b1c:	00c00a84 	movi	r3,42
  470b20:	10c00005 	stb	r3,0(r2)
            return (0);
  470b24:	0005883a 	mov	r2,zero
  470b28:	00006e06 	br	470ce4 <OSTaskNameGet+0x218>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
  470b2c:	e0bffe17 	ldw	r2,-8(fp)
  470b30:	1000051e 	bne	r2,zero,470b48 <OSTaskNameGet+0x7c>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
  470b34:	e0bfff17 	ldw	r2,-4(fp)
  470b38:	00c00304 	movi	r3,12
  470b3c:	10c00005 	stb	r3,0(r2)
        return (0);
  470b40:	0005883a 	mov	r2,zero
  470b44:	00006706 	br	470ce4 <OSTaskNameGet+0x218>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
  470b48:	00801234 	movhi	r2,72
  470b4c:	10a64c04 	addi	r2,r2,-26320
  470b50:	10800003 	ldbu	r2,0(r2)
  470b54:	10803fcc 	andi	r2,r2,255
  470b58:	10000526 	beq	r2,zero,470b70 <OSTaskNameGet+0xa4>
        *perr = OS_ERR_NAME_GET_ISR;
  470b5c:	e0bfff17 	ldw	r2,-4(fp)
  470b60:	00c00444 	movi	r3,17
  470b64:	10c00005 	stb	r3,0(r2)
        return (0);
  470b68:	0005883a 	mov	r2,zero
  470b6c:	00005d06 	br	470ce4 <OSTaskNameGet+0x218>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  470b70:	0005303a 	rdctl	r2,status
  470b74:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  470b78:	e0fff617 	ldw	r3,-40(fp)
  470b7c:	00bfff84 	movi	r2,-2
  470b80:	1884703a 	and	r2,r3,r2
  470b84:	1001703a 	wrctl	status,r2
  
  return context;
  470b88:	e0bff617 	ldw	r2,-40(fp)
    }
    OS_ENTER_CRITICAL();
  470b8c:	e0bff315 	stw	r2,-52(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
  470b90:	e0bffd03 	ldbu	r2,-12(fp)
  470b94:	10803fd8 	cmpnei	r2,r2,255
  470b98:	1000051e 	bne	r2,zero,470bb0 <OSTaskNameGet+0xe4>
        prio = OSTCBCur->OSTCBPrio;
  470b9c:	00801234 	movhi	r2,72
  470ba0:	10a64d04 	addi	r2,r2,-26316
  470ba4:	10800017 	ldw	r2,0(r2)
  470ba8:	10800c83 	ldbu	r2,50(r2)
  470bac:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
  470bb0:	e0bffd03 	ldbu	r2,-12(fp)
  470bb4:	00c01234 	movhi	r3,72
  470bb8:	18f31404 	addi	r3,r3,-13232
  470bbc:	1085883a 	add	r2,r2,r2
  470bc0:	1085883a 	add	r2,r2,r2
  470bc4:	1885883a 	add	r2,r3,r2
  470bc8:	10800017 	ldw	r2,0(r2)
  470bcc:	e0bff415 	stw	r2,-48(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
  470bd0:	e0bff417 	ldw	r2,-48(fp)
  470bd4:	1000141e 	bne	r2,zero,470c28 <OSTaskNameGet+0x15c>
  470bd8:	e0bff317 	ldw	r2,-52(fp)
  470bdc:	e0bff715 	stw	r2,-36(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  470be0:	0005303a 	rdctl	r2,status
  470be4:	e0bff815 	stw	r2,-32(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  470be8:	e0fff817 	ldw	r3,-32(fp)
  470bec:	00bfff84 	movi	r2,-2
  470bf0:	1884703a 	and	r2,r3,r2
  470bf4:	e0bff815 	stw	r2,-32(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  470bf8:	e0bff717 	ldw	r2,-36(fp)
  470bfc:	1080004c 	andi	r2,r2,1
  470c00:	e0fff817 	ldw	r3,-32(fp)
  470c04:	1884b03a 	or	r2,r3,r2
  470c08:	e0bff815 	stw	r2,-32(fp)
  
  NIOS2_WRITE_STATUS (status);
  470c0c:	e0bff817 	ldw	r2,-32(fp)
  470c10:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
  470c14:	e0bfff17 	ldw	r2,-4(fp)
  470c18:	00c010c4 	movi	r3,67
  470c1c:	10c00005 	stb	r3,0(r2)
        return (0);
  470c20:	0005883a 	mov	r2,zero
  470c24:	00002f06 	br	470ce4 <OSTaskNameGet+0x218>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
  470c28:	e0bff417 	ldw	r2,-48(fp)
  470c2c:	10800058 	cmpnei	r2,r2,1
  470c30:	1000141e 	bne	r2,zero,470c84 <OSTaskNameGet+0x1b8>
  470c34:	e0bff317 	ldw	r2,-52(fp)
  470c38:	e0bff915 	stw	r2,-28(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  470c3c:	0005303a 	rdctl	r2,status
  470c40:	e0bffa15 	stw	r2,-24(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  470c44:	e0fffa17 	ldw	r3,-24(fp)
  470c48:	00bfff84 	movi	r2,-2
  470c4c:	1884703a 	and	r2,r3,r2
  470c50:	e0bffa15 	stw	r2,-24(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  470c54:	e0bff917 	ldw	r2,-28(fp)
  470c58:	1080004c 	andi	r2,r2,1
  470c5c:	e0fffa17 	ldw	r3,-24(fp)
  470c60:	1884b03a 	or	r2,r3,r2
  470c64:	e0bffa15 	stw	r2,-24(fp)
  
  NIOS2_WRITE_STATUS (status);
  470c68:	e0bffa17 	ldw	r2,-24(fp)
  470c6c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
  470c70:	e0bfff17 	ldw	r2,-4(fp)
  470c74:	00c010c4 	movi	r3,67
  470c78:	10c00005 	stb	r3,0(r2)
        return (0);
  470c7c:	0005883a 	mov	r2,zero
  470c80:	00001806 	br	470ce4 <OSTaskNameGet+0x218>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
  470c84:	e0bff417 	ldw	r2,-48(fp)
  470c88:	10801304 	addi	r2,r2,76
  470c8c:	e13ffe17 	ldw	r4,-8(fp)
  470c90:	100b883a 	mov	r5,r2
  470c94:	046a6000 	call	46a600 <OS_StrCopy>
  470c98:	e0bff505 	stb	r2,-44(fp)
  470c9c:	e0bff317 	ldw	r2,-52(fp)
  470ca0:	e0bffb15 	stw	r2,-20(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  470ca4:	0005303a 	rdctl	r2,status
  470ca8:	e0bffc15 	stw	r2,-16(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  470cac:	e0fffc17 	ldw	r3,-16(fp)
  470cb0:	00bfff84 	movi	r2,-2
  470cb4:	1884703a 	and	r2,r3,r2
  470cb8:	e0bffc15 	stw	r2,-16(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  470cbc:	e0bffb17 	ldw	r2,-20(fp)
  470cc0:	1080004c 	andi	r2,r2,1
  470cc4:	e0fffc17 	ldw	r3,-16(fp)
  470cc8:	1884b03a 	or	r2,r3,r2
  470ccc:	e0bffc15 	stw	r2,-16(fp)
  
  NIOS2_WRITE_STATUS (status);
  470cd0:	e0bffc17 	ldw	r2,-16(fp)
  470cd4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
  470cd8:	e0bfff17 	ldw	r2,-4(fp)
  470cdc:	10000005 	stb	zero,0(r2)
    return (len);
  470ce0:	e0bff503 	ldbu	r2,-44(fp)
}
  470ce4:	e037883a 	mov	sp,fp
  470ce8:	dfc00117 	ldw	ra,4(sp)
  470cec:	df000017 	ldw	fp,0(sp)
  470cf0:	dec00204 	addi	sp,sp,8
  470cf4:	f800283a 	ret

00470cf8 <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
  470cf8:	deffef04 	addi	sp,sp,-68
  470cfc:	dfc01015 	stw	ra,64(sp)
  470d00:	df000f15 	stw	fp,60(sp)
  470d04:	df000f04 	addi	fp,sp,60
  470d08:	2005883a 	mov	r2,r4
  470d0c:	e17ffe15 	stw	r5,-8(fp)
  470d10:	e1bfff15 	stw	r6,-4(fp)
  470d14:	e0bffd05 	stb	r2,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
  470d18:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
  470d1c:	e0bfff17 	ldw	r2,-4(fp)
  470d20:	10008c26 	beq	r2,zero,470f54 <OSTaskNameSet+0x25c>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
  470d24:	e0bffd03 	ldbu	r2,-12(fp)
  470d28:	10800570 	cmpltui	r2,r2,21
  470d2c:	1000071e 	bne	r2,zero,470d4c <OSTaskNameSet+0x54>
        if (prio != OS_PRIO_SELF) {
  470d30:	e0bffd03 	ldbu	r2,-12(fp)
  470d34:	10803fe0 	cmpeqi	r2,r2,255
  470d38:	1000041e 	bne	r2,zero,470d4c <OSTaskNameSet+0x54>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
  470d3c:	e0bfff17 	ldw	r2,-4(fp)
  470d40:	00c00a84 	movi	r3,42
  470d44:	10c00005 	stb	r3,0(r2)
            return;
  470d48:	00008306 	br	470f58 <OSTaskNameSet+0x260>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
  470d4c:	e0bffe17 	ldw	r2,-8(fp)
  470d50:	1000041e 	bne	r2,zero,470d64 <OSTaskNameSet+0x6c>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
  470d54:	e0bfff17 	ldw	r2,-4(fp)
  470d58:	00c00304 	movi	r3,12
  470d5c:	10c00005 	stb	r3,0(r2)
        return;
  470d60:	00007d06 	br	470f58 <OSTaskNameSet+0x260>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
  470d64:	00801234 	movhi	r2,72
  470d68:	10a64c04 	addi	r2,r2,-26320
  470d6c:	10800003 	ldbu	r2,0(r2)
  470d70:	10803fcc 	andi	r2,r2,255
  470d74:	10000426 	beq	r2,zero,470d88 <OSTaskNameSet+0x90>
        *perr = OS_ERR_NAME_SET_ISR;
  470d78:	e0bfff17 	ldw	r2,-4(fp)
  470d7c:	00c00484 	movi	r3,18
  470d80:	10c00005 	stb	r3,0(r2)
        return;
  470d84:	00007406 	br	470f58 <OSTaskNameSet+0x260>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  470d88:	0005303a 	rdctl	r2,status
  470d8c:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  470d90:	e0fff417 	ldw	r3,-48(fp)
  470d94:	00bfff84 	movi	r2,-2
  470d98:	1884703a 	and	r2,r3,r2
  470d9c:	1001703a 	wrctl	status,r2
  
  return context;
  470da0:	e0bff417 	ldw	r2,-48(fp)
    }
    OS_ENTER_CRITICAL();
  470da4:	e0bff115 	stw	r2,-60(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
  470da8:	e0bffd03 	ldbu	r2,-12(fp)
  470dac:	10803fd8 	cmpnei	r2,r2,255
  470db0:	1000051e 	bne	r2,zero,470dc8 <OSTaskNameSet+0xd0>
        prio = OSTCBCur->OSTCBPrio;
  470db4:	00801234 	movhi	r2,72
  470db8:	10a64d04 	addi	r2,r2,-26316
  470dbc:	10800017 	ldw	r2,0(r2)
  470dc0:	10800c83 	ldbu	r2,50(r2)
  470dc4:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
  470dc8:	e0bffd03 	ldbu	r2,-12(fp)
  470dcc:	00c01234 	movhi	r3,72
  470dd0:	18f31404 	addi	r3,r3,-13232
  470dd4:	1085883a 	add	r2,r2,r2
  470dd8:	1085883a 	add	r2,r2,r2
  470ddc:	1885883a 	add	r2,r3,r2
  470de0:	10800017 	ldw	r2,0(r2)
  470de4:	e0bff215 	stw	r2,-56(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
  470de8:	e0bff217 	ldw	r2,-56(fp)
  470dec:	1000131e 	bne	r2,zero,470e3c <OSTaskNameSet+0x144>
  470df0:	e0bff117 	ldw	r2,-60(fp)
  470df4:	e0bff515 	stw	r2,-44(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  470df8:	0005303a 	rdctl	r2,status
  470dfc:	e0bff615 	stw	r2,-40(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  470e00:	e0fff617 	ldw	r3,-40(fp)
  470e04:	00bfff84 	movi	r2,-2
  470e08:	1884703a 	and	r2,r3,r2
  470e0c:	e0bff615 	stw	r2,-40(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  470e10:	e0bff517 	ldw	r2,-44(fp)
  470e14:	1080004c 	andi	r2,r2,1
  470e18:	e0fff617 	ldw	r3,-40(fp)
  470e1c:	1884b03a 	or	r2,r3,r2
  470e20:	e0bff615 	stw	r2,-40(fp)
  
  NIOS2_WRITE_STATUS (status);
  470e24:	e0bff617 	ldw	r2,-40(fp)
  470e28:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
  470e2c:	e0bfff17 	ldw	r2,-4(fp)
  470e30:	00c010c4 	movi	r3,67
  470e34:	10c00005 	stb	r3,0(r2)
        return;
  470e38:	00004706 	br	470f58 <OSTaskNameSet+0x260>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
  470e3c:	e0bff217 	ldw	r2,-56(fp)
  470e40:	10800058 	cmpnei	r2,r2,1
  470e44:	1000131e 	bne	r2,zero,470e94 <OSTaskNameSet+0x19c>
  470e48:	e0bff117 	ldw	r2,-60(fp)
  470e4c:	e0bff715 	stw	r2,-36(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  470e50:	0005303a 	rdctl	r2,status
  470e54:	e0bff815 	stw	r2,-32(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  470e58:	e0fff817 	ldw	r3,-32(fp)
  470e5c:	00bfff84 	movi	r2,-2
  470e60:	1884703a 	and	r2,r3,r2
  470e64:	e0bff815 	stw	r2,-32(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  470e68:	e0bff717 	ldw	r2,-36(fp)
  470e6c:	1080004c 	andi	r2,r2,1
  470e70:	e0fff817 	ldw	r3,-32(fp)
  470e74:	1884b03a 	or	r2,r3,r2
  470e78:	e0bff815 	stw	r2,-32(fp)
  
  NIOS2_WRITE_STATUS (status);
  470e7c:	e0bff817 	ldw	r2,-32(fp)
  470e80:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
  470e84:	e0bfff17 	ldw	r2,-4(fp)
  470e88:	00c010c4 	movi	r3,67
  470e8c:	10c00005 	stb	r3,0(r2)
        return;
  470e90:	00003106 	br	470f58 <OSTaskNameSet+0x260>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
  470e94:	e13ffe17 	ldw	r4,-8(fp)
  470e98:	046a67c0 	call	46a67c <OS_StrLen>
  470e9c:	e0bff305 	stb	r2,-52(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
  470ea0:	e0bff303 	ldbu	r2,-52(fp)
  470ea4:	10800830 	cmpltui	r2,r2,32
  470ea8:	1000131e 	bne	r2,zero,470ef8 <OSTaskNameSet+0x200>
  470eac:	e0bff117 	ldw	r2,-60(fp)
  470eb0:	e0bff915 	stw	r2,-28(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  470eb4:	0005303a 	rdctl	r2,status
  470eb8:	e0bffa15 	stw	r2,-24(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  470ebc:	e0fffa17 	ldw	r3,-24(fp)
  470ec0:	00bfff84 	movi	r2,-2
  470ec4:	1884703a 	and	r2,r3,r2
  470ec8:	e0bffa15 	stw	r2,-24(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  470ecc:	e0bff917 	ldw	r2,-28(fp)
  470ed0:	1080004c 	andi	r2,r2,1
  470ed4:	e0fffa17 	ldw	r3,-24(fp)
  470ed8:	1884b03a 	or	r2,r3,r2
  470edc:	e0bffa15 	stw	r2,-24(fp)
  
  NIOS2_WRITE_STATUS (status);
  470ee0:	e0bffa17 	ldw	r2,-24(fp)
  470ee4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
  470ee8:	e0bfff17 	ldw	r2,-4(fp)
  470eec:	00c01044 	movi	r3,65
  470ef0:	10c00005 	stb	r3,0(r2)
        return;
  470ef4:	00001806 	br	470f58 <OSTaskNameSet+0x260>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
  470ef8:	e0bff217 	ldw	r2,-56(fp)
  470efc:	10801304 	addi	r2,r2,76
  470f00:	1009883a 	mov	r4,r2
  470f04:	e17ffe17 	ldw	r5,-8(fp)
  470f08:	046a6000 	call	46a600 <OS_StrCopy>
  470f0c:	e0bff117 	ldw	r2,-60(fp)
  470f10:	e0bffb15 	stw	r2,-20(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  470f14:	0005303a 	rdctl	r2,status
  470f18:	e0bffc15 	stw	r2,-16(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  470f1c:	e0fffc17 	ldw	r3,-16(fp)
  470f20:	00bfff84 	movi	r2,-2
  470f24:	1884703a 	and	r2,r3,r2
  470f28:	e0bffc15 	stw	r2,-16(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  470f2c:	e0bffb17 	ldw	r2,-20(fp)
  470f30:	1080004c 	andi	r2,r2,1
  470f34:	e0fffc17 	ldw	r3,-16(fp)
  470f38:	1884b03a 	or	r2,r3,r2
  470f3c:	e0bffc15 	stw	r2,-16(fp)
  
  NIOS2_WRITE_STATUS (status);
  470f40:	e0bffc17 	ldw	r2,-16(fp)
  470f44:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
  470f48:	e0bfff17 	ldw	r2,-4(fp)
  470f4c:	10000005 	stb	zero,0(r2)
  470f50:	00000106 	br	470f58 <OSTaskNameSet+0x260>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
        return;
  470f54:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
  470f58:	e037883a 	mov	sp,fp
  470f5c:	dfc00117 	ldw	ra,4(sp)
  470f60:	df000017 	ldw	fp,0(sp)
  470f64:	dec00204 	addi	sp,sp,8
  470f68:	f800283a 	ret

00470f6c <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
  470f6c:	deffee04 	addi	sp,sp,-72
  470f70:	dfc01115 	stw	ra,68(sp)
  470f74:	df001015 	stw	fp,64(sp)
  470f78:	df001004 	addi	fp,sp,64
  470f7c:	2005883a 	mov	r2,r4
  470f80:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
  470f84:	e03ff015 	stw	zero,-64(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
  470f88:	e0bfff03 	ldbu	r2,-4(fp)
  470f8c:	10800530 	cmpltui	r2,r2,20
  470f90:	1000021e 	bne	r2,zero,470f9c <OSTaskResume+0x30>
        return (OS_ERR_PRIO_INVALID);
  470f94:	00800a84 	movi	r2,42
  470f98:	0000ae06 	br	471254 <OSTaskResume+0x2e8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  470f9c:	0005303a 	rdctl	r2,status
  470fa0:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  470fa4:	e0fff217 	ldw	r3,-56(fp)
  470fa8:	00bfff84 	movi	r2,-2
  470fac:	1884703a 	and	r2,r3,r2
  470fb0:	1001703a 	wrctl	status,r2
  
  return context;
  470fb4:	e0bff217 	ldw	r2,-56(fp)
    }
#endif
    OS_ENTER_CRITICAL();
  470fb8:	e0bff015 	stw	r2,-64(fp)
    ptcb = OSTCBPrioTbl[prio];
  470fbc:	e0bfff03 	ldbu	r2,-4(fp)
  470fc0:	00c01234 	movhi	r3,72
  470fc4:	18f31404 	addi	r3,r3,-13232
  470fc8:	1085883a 	add	r2,r2,r2
  470fcc:	1085883a 	add	r2,r2,r2
  470fd0:	1885883a 	add	r2,r3,r2
  470fd4:	10800017 	ldw	r2,0(r2)
  470fd8:	e0bff115 	stw	r2,-60(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
  470fdc:	e0bff117 	ldw	r2,-60(fp)
  470fe0:	1000111e 	bne	r2,zero,471028 <OSTaskResume+0xbc>
  470fe4:	e0bff017 	ldw	r2,-64(fp)
  470fe8:	e0bff315 	stw	r2,-52(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  470fec:	0005303a 	rdctl	r2,status
  470ff0:	e0bff415 	stw	r2,-48(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  470ff4:	e0fff417 	ldw	r3,-48(fp)
  470ff8:	00bfff84 	movi	r2,-2
  470ffc:	1884703a 	and	r2,r3,r2
  471000:	e0bff415 	stw	r2,-48(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  471004:	e0bff317 	ldw	r2,-52(fp)
  471008:	1080004c 	andi	r2,r2,1
  47100c:	e0fff417 	ldw	r3,-48(fp)
  471010:	1884b03a 	or	r2,r3,r2
  471014:	e0bff415 	stw	r2,-48(fp)
  
  NIOS2_WRITE_STATUS (status);
  471018:	e0bff417 	ldw	r2,-48(fp)
  47101c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
  471020:	00801184 	movi	r2,70
  471024:	00008b06 	br	471254 <OSTaskResume+0x2e8>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
  471028:	e0bff117 	ldw	r2,-60(fp)
  47102c:	10800058 	cmpnei	r2,r2,1
  471030:	1000111e 	bne	r2,zero,471078 <OSTaskResume+0x10c>
  471034:	e0bff017 	ldw	r2,-64(fp)
  471038:	e0bff515 	stw	r2,-44(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  47103c:	0005303a 	rdctl	r2,status
  471040:	e0bff615 	stw	r2,-40(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  471044:	e0fff617 	ldw	r3,-40(fp)
  471048:	00bfff84 	movi	r2,-2
  47104c:	1884703a 	and	r2,r3,r2
  471050:	e0bff615 	stw	r2,-40(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  471054:	e0bff517 	ldw	r2,-44(fp)
  471058:	1080004c 	andi	r2,r2,1
  47105c:	e0fff617 	ldw	r3,-40(fp)
  471060:	1884b03a 	or	r2,r3,r2
  471064:	e0bff615 	stw	r2,-40(fp)
  
  NIOS2_WRITE_STATUS (status);
  471068:	e0bff617 	ldw	r2,-40(fp)
  47106c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
  471070:	008010c4 	movi	r2,67
  471074:	00007706 	br	471254 <OSTaskResume+0x2e8>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
  471078:	e0bff117 	ldw	r2,-60(fp)
  47107c:	10800c03 	ldbu	r2,48(r2)
  471080:	10803fcc 	andi	r2,r2,255
  471084:	1080020c 	andi	r2,r2,8
  471088:	10006226 	beq	r2,zero,471214 <OSTaskResume+0x2a8>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
  47108c:	e0bff117 	ldw	r2,-60(fp)
  471090:	10c00c03 	ldbu	r3,48(r2)
  471094:	00bffdc4 	movi	r2,-9
  471098:	1884703a 	and	r2,r3,r2
  47109c:	1007883a 	mov	r3,r2
  4710a0:	e0bff117 	ldw	r2,-60(fp)
  4710a4:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
  4710a8:	e0bff117 	ldw	r2,-60(fp)
  4710ac:	10800c03 	ldbu	r2,48(r2)
  4710b0:	10803fcc 	andi	r2,r2,255
  4710b4:	1000461e 	bne	r2,zero,4711d0 <OSTaskResume+0x264>
            if (ptcb->OSTCBDly == 0) {
  4710b8:	e0bff117 	ldw	r2,-60(fp)
  4710bc:	10800b8b 	ldhu	r2,46(r2)
  4710c0:	10bfffcc 	andi	r2,r2,65535
  4710c4:	1000321e 	bne	r2,zero,471190 <OSTaskResume+0x224>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
  4710c8:	e0bff117 	ldw	r2,-60(fp)
  4710cc:	10c00d83 	ldbu	r3,54(r2)
  4710d0:	00801234 	movhi	r2,72
  4710d4:	10a64a04 	addi	r2,r2,-26328
  4710d8:	10800003 	ldbu	r2,0(r2)
  4710dc:	1884b03a 	or	r2,r3,r2
  4710e0:	1007883a 	mov	r3,r2
  4710e4:	00801234 	movhi	r2,72
  4710e8:	10a64a04 	addi	r2,r2,-26328
  4710ec:	10c00005 	stb	r3,0(r2)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
  4710f0:	e0bff117 	ldw	r2,-60(fp)
  4710f4:	10800d03 	ldbu	r2,52(r2)
  4710f8:	10803fcc 	andi	r2,r2,255
  4710fc:	e0fff117 	ldw	r3,-60(fp)
  471100:	18c00d03 	ldbu	r3,52(r3)
  471104:	18c03fcc 	andi	r3,r3,255
  471108:	01001234 	movhi	r4,72
  47110c:	21264a44 	addi	r4,r4,-26327
  471110:	20c7883a 	add	r3,r4,r3
  471114:	19000003 	ldbu	r4,0(r3)
  471118:	e0fff117 	ldw	r3,-60(fp)
  47111c:	18c00d43 	ldbu	r3,53(r3)
  471120:	20c6b03a 	or	r3,r4,r3
  471124:	01001234 	movhi	r4,72
  471128:	21264a44 	addi	r4,r4,-26327
  47112c:	2085883a 	add	r2,r4,r2
  471130:	10c00005 	stb	r3,0(r2)
  471134:	e0bff017 	ldw	r2,-64(fp)
  471138:	e0bff715 	stw	r2,-36(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  47113c:	0005303a 	rdctl	r2,status
  471140:	e0bff815 	stw	r2,-32(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  471144:	e0fff817 	ldw	r3,-32(fp)
  471148:	00bfff84 	movi	r2,-2
  47114c:	1884703a 	and	r2,r3,r2
  471150:	e0bff815 	stw	r2,-32(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  471154:	e0bff717 	ldw	r2,-36(fp)
  471158:	1080004c 	andi	r2,r2,1
  47115c:	e0fff817 	ldw	r3,-32(fp)
  471160:	1884b03a 	or	r2,r3,r2
  471164:	e0bff815 	stw	r2,-32(fp)
  
  NIOS2_WRITE_STATUS (status);
  471168:	e0bff817 	ldw	r2,-32(fp)
  47116c:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
  471170:	00801234 	movhi	r2,72
  471174:	10a63e44 	addi	r2,r2,-26375
  471178:	10800003 	ldbu	r2,0(r2)
  47117c:	10803fcc 	andi	r2,r2,255
  471180:	10800058 	cmpnei	r2,r2,1
  471184:	1000211e 	bne	r2,zero,47120c <OSTaskResume+0x2a0>
                    OS_Sched();                               /* Find new highest priority task        */
  471188:	046a4980 	call	46a498 <OS_Sched>
  47118c:	00001f06 	br	47120c <OSTaskResume+0x2a0>
  471190:	e0bff017 	ldw	r2,-64(fp)
  471194:	e0bff915 	stw	r2,-28(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  471198:	0005303a 	rdctl	r2,status
  47119c:	e0bffa15 	stw	r2,-24(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  4711a0:	e0fffa17 	ldw	r3,-24(fp)
  4711a4:	00bfff84 	movi	r2,-2
  4711a8:	1884703a 	and	r2,r3,r2
  4711ac:	e0bffa15 	stw	r2,-24(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  4711b0:	e0bff917 	ldw	r2,-28(fp)
  4711b4:	1080004c 	andi	r2,r2,1
  4711b8:	e0fffa17 	ldw	r3,-24(fp)
  4711bc:	1884b03a 	or	r2,r3,r2
  4711c0:	e0bffa15 	stw	r2,-24(fp)
  
  NIOS2_WRITE_STATUS (status);
  4711c4:	e0bffa17 	ldw	r2,-24(fp)
  4711c8:	1001703a 	wrctl	status,r2
  4711cc:	00000f06 	br	47120c <OSTaskResume+0x2a0>
  4711d0:	e0bff017 	ldw	r2,-64(fp)
  4711d4:	e0bffb15 	stw	r2,-20(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  4711d8:	0005303a 	rdctl	r2,status
  4711dc:	e0bffc15 	stw	r2,-16(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  4711e0:	e0fffc17 	ldw	r3,-16(fp)
  4711e4:	00bfff84 	movi	r2,-2
  4711e8:	1884703a 	and	r2,r3,r2
  4711ec:	e0bffc15 	stw	r2,-16(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  4711f0:	e0bffb17 	ldw	r2,-20(fp)
  4711f4:	1080004c 	andi	r2,r2,1
  4711f8:	e0fffc17 	ldw	r3,-16(fp)
  4711fc:	1884b03a 	or	r2,r3,r2
  471200:	e0bffc15 	stw	r2,-16(fp)
  
  NIOS2_WRITE_STATUS (status);
  471204:	e0bffc17 	ldw	r2,-16(fp)
  471208:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
  47120c:	0005883a 	mov	r2,zero
  471210:	00001006 	br	471254 <OSTaskResume+0x2e8>
  471214:	e0bff017 	ldw	r2,-64(fp)
  471218:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  47121c:	0005303a 	rdctl	r2,status
  471220:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  471224:	e0fffe17 	ldw	r3,-8(fp)
  471228:	00bfff84 	movi	r2,-2
  47122c:	1884703a 	and	r2,r3,r2
  471230:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  471234:	e0bffd17 	ldw	r2,-12(fp)
  471238:	1080004c 	andi	r2,r2,1
  47123c:	e0fffe17 	ldw	r3,-8(fp)
  471240:	1884b03a 	or	r2,r3,r2
  471244:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
  471248:	e0bffe17 	ldw	r2,-8(fp)
  47124c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
  471250:	00801104 	movi	r2,68
}
  471254:	e037883a 	mov	sp,fp
  471258:	dfc00117 	ldw	ra,4(sp)
  47125c:	df000017 	ldw	fp,0(sp)
  471260:	dec00204 	addi	sp,sp,8
  471264:	f800283a 	ret

00471268 <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
  471268:	deffef04 	addi	sp,sp,-68
  47126c:	df001015 	stw	fp,64(sp)
  471270:	df001004 	addi	fp,sp,64
  471274:	2005883a 	mov	r2,r4
  471278:	e17fff15 	stw	r5,-4(fp)
  47127c:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
  471280:	e03ff215 	stw	zero,-56(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
  471284:	e0bffe03 	ldbu	r2,-8(fp)
  471288:	10800570 	cmpltui	r2,r2,21
  47128c:	1000051e 	bne	r2,zero,4712a4 <OSTaskStkChk+0x3c>
        if (prio != OS_PRIO_SELF) {
  471290:	e0bffe03 	ldbu	r2,-8(fp)
  471294:	10803fe0 	cmpeqi	r2,r2,255
  471298:	1000021e 	bne	r2,zero,4712a4 <OSTaskStkChk+0x3c>
            return (OS_ERR_PRIO_INVALID);
  47129c:	00800a84 	movi	r2,42
  4712a0:	00008e06 	br	4714dc <OSTaskStkChk+0x274>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
  4712a4:	e0bfff17 	ldw	r2,-4(fp)
  4712a8:	1000021e 	bne	r2,zero,4712b4 <OSTaskStkChk+0x4c>
        return (OS_ERR_PDATA_NULL);
  4712ac:	00800244 	movi	r2,9
  4712b0:	00008a06 	br	4714dc <OSTaskStkChk+0x274>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
  4712b4:	e0bfff17 	ldw	r2,-4(fp)
  4712b8:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
  4712bc:	e0bfff17 	ldw	r2,-4(fp)
  4712c0:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  4712c4:	0005303a 	rdctl	r2,status
  4712c8:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  4712cc:	e0fff517 	ldw	r3,-44(fp)
  4712d0:	00bfff84 	movi	r2,-2
  4712d4:	1884703a 	and	r2,r3,r2
  4712d8:	1001703a 	wrctl	status,r2
  
  return context;
  4712dc:	e0bff517 	ldw	r2,-44(fp)
    OS_ENTER_CRITICAL();
  4712e0:	e0bff215 	stw	r2,-56(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
  4712e4:	e0bffe03 	ldbu	r2,-8(fp)
  4712e8:	10803fd8 	cmpnei	r2,r2,255
  4712ec:	1000051e 	bne	r2,zero,471304 <OSTaskStkChk+0x9c>
        prio = OSTCBCur->OSTCBPrio;
  4712f0:	00801234 	movhi	r2,72
  4712f4:	10a64d04 	addi	r2,r2,-26316
  4712f8:	10800017 	ldw	r2,0(r2)
  4712fc:	10800c83 	ldbu	r2,50(r2)
  471300:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
  471304:	e0bffe03 	ldbu	r2,-8(fp)
  471308:	00c01234 	movhi	r3,72
  47130c:	18f31404 	addi	r3,r3,-13232
  471310:	1085883a 	add	r2,r2,r2
  471314:	1085883a 	add	r2,r2,r2
  471318:	1885883a 	add	r2,r3,r2
  47131c:	10800017 	ldw	r2,0(r2)
  471320:	e0bff315 	stw	r2,-52(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
  471324:	e0bff317 	ldw	r2,-52(fp)
  471328:	1000111e 	bne	r2,zero,471370 <OSTaskStkChk+0x108>
  47132c:	e0bff217 	ldw	r2,-56(fp)
  471330:	e0bff615 	stw	r2,-40(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  471334:	0005303a 	rdctl	r2,status
  471338:	e0bff715 	stw	r2,-36(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  47133c:	e0fff717 	ldw	r3,-36(fp)
  471340:	00bfff84 	movi	r2,-2
  471344:	1884703a 	and	r2,r3,r2
  471348:	e0bff715 	stw	r2,-36(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  47134c:	e0bff617 	ldw	r2,-40(fp)
  471350:	1080004c 	andi	r2,r2,1
  471354:	e0fff717 	ldw	r3,-36(fp)
  471358:	1884b03a 	or	r2,r3,r2
  47135c:	e0bff715 	stw	r2,-36(fp)
  
  NIOS2_WRITE_STATUS (status);
  471360:	e0bff717 	ldw	r2,-36(fp)
  471364:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
  471368:	008010c4 	movi	r2,67
  47136c:	00005b06 	br	4714dc <OSTaskStkChk+0x274>
    }
    if (ptcb == OS_TCB_RESERVED) {
  471370:	e0bff317 	ldw	r2,-52(fp)
  471374:	10800058 	cmpnei	r2,r2,1
  471378:	1000111e 	bne	r2,zero,4713c0 <OSTaskStkChk+0x158>
  47137c:	e0bff217 	ldw	r2,-56(fp)
  471380:	e0bff815 	stw	r2,-32(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  471384:	0005303a 	rdctl	r2,status
  471388:	e0bff915 	stw	r2,-28(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  47138c:	e0fff917 	ldw	r3,-28(fp)
  471390:	00bfff84 	movi	r2,-2
  471394:	1884703a 	and	r2,r3,r2
  471398:	e0bff915 	stw	r2,-28(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  47139c:	e0bff817 	ldw	r2,-32(fp)
  4713a0:	1080004c 	andi	r2,r2,1
  4713a4:	e0fff917 	ldw	r3,-28(fp)
  4713a8:	1884b03a 	or	r2,r3,r2
  4713ac:	e0bff915 	stw	r2,-28(fp)
  
  NIOS2_WRITE_STATUS (status);
  4713b0:	e0bff917 	ldw	r2,-28(fp)
  4713b4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
  4713b8:	008010c4 	movi	r2,67
  4713bc:	00004706 	br	4714dc <OSTaskStkChk+0x274>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
  4713c0:	e0bff317 	ldw	r2,-52(fp)
  4713c4:	1080040b 	ldhu	r2,16(r2)
  4713c8:	10bfffcc 	andi	r2,r2,65535
  4713cc:	1080004c 	andi	r2,r2,1
  4713d0:	1000111e 	bne	r2,zero,471418 <OSTaskStkChk+0x1b0>
  4713d4:	e0bff217 	ldw	r2,-56(fp)
  4713d8:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  4713dc:	0005303a 	rdctl	r2,status
  4713e0:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  4713e4:	e0fffb17 	ldw	r3,-20(fp)
  4713e8:	00bfff84 	movi	r2,-2
  4713ec:	1884703a 	and	r2,r3,r2
  4713f0:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  4713f4:	e0bffa17 	ldw	r2,-24(fp)
  4713f8:	1080004c 	andi	r2,r2,1
  4713fc:	e0fffb17 	ldw	r3,-20(fp)
  471400:	1884b03a 	or	r2,r3,r2
  471404:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
  471408:	e0bffb17 	ldw	r2,-20(fp)
  47140c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
  471410:	00801144 	movi	r2,69
  471414:	00003106 	br	4714dc <OSTaskStkChk+0x274>
    }
    nfree = 0;
  471418:	e03ff115 	stw	zero,-60(fp)
    size  = ptcb->OSTCBStkSize;
  47141c:	e0bff317 	ldw	r2,-52(fp)
  471420:	10800317 	ldw	r2,12(r2)
  471424:	e0bff415 	stw	r2,-48(fp)
    pchk  = ptcb->OSTCBStkBottom;
  471428:	e0bff317 	ldw	r2,-52(fp)
  47142c:	10800217 	ldw	r2,8(r2)
  471430:	e0bff015 	stw	r2,-64(fp)
  471434:	e0bff217 	ldw	r2,-56(fp)
  471438:	e0bffc15 	stw	r2,-16(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  47143c:	0005303a 	rdctl	r2,status
  471440:	e0bffd15 	stw	r2,-12(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  471444:	e0fffd17 	ldw	r3,-12(fp)
  471448:	00bfff84 	movi	r2,-2
  47144c:	1884703a 	and	r2,r3,r2
  471450:	e0bffd15 	stw	r2,-12(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  471454:	e0bffc17 	ldw	r2,-16(fp)
  471458:	1080004c 	andi	r2,r2,1
  47145c:	e0fffd17 	ldw	r3,-12(fp)
  471460:	1884b03a 	or	r2,r3,r2
  471464:	e0bffd15 	stw	r2,-12(fp)
  
  NIOS2_WRITE_STATUS (status);
  471468:	e0bffd17 	ldw	r2,-12(fp)
  47146c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
  471470:	00000306 	br	471480 <OSTaskStkChk+0x218>
        nfree++;
  471474:	e0bff117 	ldw	r2,-60(fp)
  471478:	10800044 	addi	r2,r2,1
  47147c:	e0bff115 	stw	r2,-60(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
  471480:	e0bff017 	ldw	r2,-64(fp)
  471484:	10800017 	ldw	r2,0(r2)
  471488:	1005003a 	cmpeq	r2,r2,zero
  47148c:	e0fff017 	ldw	r3,-64(fp)
  471490:	18c00104 	addi	r3,r3,4
  471494:	e0fff015 	stw	r3,-64(fp)
  471498:	10803fcc 	andi	r2,r2,255
  47149c:	103ff51e 	bne	r2,zero,471474 <OSTaskStkChk+0x20c>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
  4714a0:	e0bff117 	ldw	r2,-60(fp)
  4714a4:	1085883a 	add	r2,r2,r2
  4714a8:	1085883a 	add	r2,r2,r2
  4714ac:	1007883a 	mov	r3,r2
  4714b0:	e0bfff17 	ldw	r2,-4(fp)
  4714b4:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
  4714b8:	e0fff417 	ldw	r3,-48(fp)
  4714bc:	e0bff117 	ldw	r2,-60(fp)
  4714c0:	1885c83a 	sub	r2,r3,r2
  4714c4:	1085883a 	add	r2,r2,r2
  4714c8:	1085883a 	add	r2,r2,r2
  4714cc:	1007883a 	mov	r3,r2
  4714d0:	e0bfff17 	ldw	r2,-4(fp)
  4714d4:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
  4714d8:	0005883a 	mov	r2,zero
}
  4714dc:	e037883a 	mov	sp,fp
  4714e0:	df000017 	ldw	fp,0(sp)
  4714e4:	dec00104 	addi	sp,sp,4
  4714e8:	f800283a 	ret

004714ec <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
  4714ec:	defff204 	addi	sp,sp,-56
  4714f0:	dfc00d15 	stw	ra,52(sp)
  4714f4:	df000c15 	stw	fp,48(sp)
  4714f8:	df000c04 	addi	fp,sp,48
  4714fc:	2005883a 	mov	r2,r4
  471500:	e0bfff05 	stb	r2,-4(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
  471504:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
  471508:	e0bfff03 	ldbu	r2,-4(fp)
  47150c:	10800518 	cmpnei	r2,r2,20
  471510:	1000021e 	bne	r2,zero,47151c <OSTaskSuspend+0x30>
        return (OS_ERR_TASK_SUSPEND_IDLE);
  471514:	008011c4 	movi	r2,71
  471518:	00009406 	br	47176c <OSTaskSuspend+0x280>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
  47151c:	e0bfff03 	ldbu	r2,-4(fp)
  471520:	10800530 	cmpltui	r2,r2,20
  471524:	1000051e 	bne	r2,zero,47153c <OSTaskSuspend+0x50>
        if (prio != OS_PRIO_SELF) {
  471528:	e0bfff03 	ldbu	r2,-4(fp)
  47152c:	10803fe0 	cmpeqi	r2,r2,255
  471530:	1000021e 	bne	r2,zero,47153c <OSTaskSuspend+0x50>
            return (OS_ERR_PRIO_INVALID);
  471534:	00800a84 	movi	r2,42
  471538:	00008c06 	br	47176c <OSTaskSuspend+0x280>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  47153c:	0005303a 	rdctl	r2,status
  471540:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  471544:	e0fff817 	ldw	r3,-32(fp)
  471548:	00bfff84 	movi	r2,-2
  47154c:	1884703a 	and	r2,r3,r2
  471550:	1001703a 	wrctl	status,r2
  
  return context;
  471554:	e0bff817 	ldw	r2,-32(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
  471558:	e0bff515 	stw	r2,-44(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
  47155c:	e0bfff03 	ldbu	r2,-4(fp)
  471560:	10803fd8 	cmpnei	r2,r2,255
  471564:	1000081e 	bne	r2,zero,471588 <OSTaskSuspend+0x9c>
        prio = OSTCBCur->OSTCBPrio;
  471568:	00801234 	movhi	r2,72
  47156c:	10a64d04 	addi	r2,r2,-26316
  471570:	10800017 	ldw	r2,0(r2)
  471574:	10800c83 	ldbu	r2,50(r2)
  471578:	e0bfff05 	stb	r2,-4(fp)
        self = OS_TRUE;
  47157c:	00800044 	movi	r2,1
  471580:	e0bff405 	stb	r2,-48(fp)
  471584:	00000b06 	br	4715b4 <OSTaskSuspend+0xc8>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
  471588:	00801234 	movhi	r2,72
  47158c:	10a64d04 	addi	r2,r2,-26316
  471590:	10800017 	ldw	r2,0(r2)
  471594:	10800c83 	ldbu	r2,50(r2)
  471598:	10c03fcc 	andi	r3,r2,255
  47159c:	e0bfff03 	ldbu	r2,-4(fp)
  4715a0:	1880031e 	bne	r3,r2,4715b0 <OSTaskSuspend+0xc4>
        self = OS_TRUE;
  4715a4:	00800044 	movi	r2,1
  4715a8:	e0bff405 	stb	r2,-48(fp)
  4715ac:	00000106 	br	4715b4 <OSTaskSuspend+0xc8>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
  4715b0:	e03ff405 	stb	zero,-48(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
  4715b4:	e0bfff03 	ldbu	r2,-4(fp)
  4715b8:	00c01234 	movhi	r3,72
  4715bc:	18f31404 	addi	r3,r3,-13232
  4715c0:	1085883a 	add	r2,r2,r2
  4715c4:	1085883a 	add	r2,r2,r2
  4715c8:	1885883a 	add	r2,r3,r2
  4715cc:	10800017 	ldw	r2,0(r2)
  4715d0:	e0bff615 	stw	r2,-40(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
  4715d4:	e0bff617 	ldw	r2,-40(fp)
  4715d8:	1000111e 	bne	r2,zero,471620 <OSTaskSuspend+0x134>
  4715dc:	e0bff517 	ldw	r2,-44(fp)
  4715e0:	e0bff915 	stw	r2,-28(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  4715e4:	0005303a 	rdctl	r2,status
  4715e8:	e0bffa15 	stw	r2,-24(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  4715ec:	e0fffa17 	ldw	r3,-24(fp)
  4715f0:	00bfff84 	movi	r2,-2
  4715f4:	1884703a 	and	r2,r3,r2
  4715f8:	e0bffa15 	stw	r2,-24(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  4715fc:	e0bff917 	ldw	r2,-28(fp)
  471600:	1080004c 	andi	r2,r2,1
  471604:	e0fffa17 	ldw	r3,-24(fp)
  471608:	1884b03a 	or	r2,r3,r2
  47160c:	e0bffa15 	stw	r2,-24(fp)
  
  NIOS2_WRITE_STATUS (status);
  471610:	e0bffa17 	ldw	r2,-24(fp)
  471614:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
  471618:	00801204 	movi	r2,72
  47161c:	00005306 	br	47176c <OSTaskSuspend+0x280>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
  471620:	e0bff617 	ldw	r2,-40(fp)
  471624:	10800058 	cmpnei	r2,r2,1
  471628:	1000111e 	bne	r2,zero,471670 <OSTaskSuspend+0x184>
  47162c:	e0bff517 	ldw	r2,-44(fp)
  471630:	e0bffb15 	stw	r2,-20(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  471634:	0005303a 	rdctl	r2,status
  471638:	e0bffc15 	stw	r2,-16(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  47163c:	e0fffc17 	ldw	r3,-16(fp)
  471640:	00bfff84 	movi	r2,-2
  471644:	1884703a 	and	r2,r3,r2
  471648:	e0bffc15 	stw	r2,-16(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  47164c:	e0bffb17 	ldw	r2,-20(fp)
  471650:	1080004c 	andi	r2,r2,1
  471654:	e0fffc17 	ldw	r3,-16(fp)
  471658:	1884b03a 	or	r2,r3,r2
  47165c:	e0bffc15 	stw	r2,-16(fp)
  
  NIOS2_WRITE_STATUS (status);
  471660:	e0bffc17 	ldw	r2,-16(fp)
  471664:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
  471668:	008010c4 	movi	r2,67
  47166c:	00003f06 	br	47176c <OSTaskSuspend+0x280>
    }
    y            = ptcb->OSTCBY;
  471670:	e0bff617 	ldw	r2,-40(fp)
  471674:	10800d03 	ldbu	r2,52(r2)
  471678:	e0bff705 	stb	r2,-36(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
  47167c:	e0bff703 	ldbu	r2,-36(fp)
  471680:	e0fff703 	ldbu	r3,-36(fp)
  471684:	01001234 	movhi	r4,72
  471688:	21264a44 	addi	r4,r4,-26327
  47168c:	20c7883a 	add	r3,r4,r3
  471690:	18c00003 	ldbu	r3,0(r3)
  471694:	1809883a 	mov	r4,r3
  471698:	e0fff617 	ldw	r3,-40(fp)
  47169c:	18c00d43 	ldbu	r3,53(r3)
  4716a0:	00c6303a 	nor	r3,zero,r3
  4716a4:	20c6703a 	and	r3,r4,r3
  4716a8:	01001234 	movhi	r4,72
  4716ac:	21264a44 	addi	r4,r4,-26327
  4716b0:	2085883a 	add	r2,r4,r2
  4716b4:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0) {
  4716b8:	e0bff703 	ldbu	r2,-36(fp)
  4716bc:	00c01234 	movhi	r3,72
  4716c0:	18e64a44 	addi	r3,r3,-26327
  4716c4:	1885883a 	add	r2,r3,r2
  4716c8:	10800003 	ldbu	r2,0(r2)
  4716cc:	10803fcc 	andi	r2,r2,255
  4716d0:	10000c1e 	bne	r2,zero,471704 <OSTaskSuspend+0x218>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
  4716d4:	e0bff617 	ldw	r2,-40(fp)
  4716d8:	10800d83 	ldbu	r2,54(r2)
  4716dc:	0084303a 	nor	r2,zero,r2
  4716e0:	1007883a 	mov	r3,r2
  4716e4:	00801234 	movhi	r2,72
  4716e8:	10a64a04 	addi	r2,r2,-26328
  4716ec:	10800003 	ldbu	r2,0(r2)
  4716f0:	1884703a 	and	r2,r3,r2
  4716f4:	1007883a 	mov	r3,r2
  4716f8:	00801234 	movhi	r2,72
  4716fc:	10a64a04 	addi	r2,r2,-26328
  471700:	10c00005 	stb	r3,0(r2)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
  471704:	e0bff617 	ldw	r2,-40(fp)
  471708:	10800c03 	ldbu	r2,48(r2)
  47170c:	10800214 	ori	r2,r2,8
  471710:	1007883a 	mov	r3,r2
  471714:	e0bff617 	ldw	r2,-40(fp)
  471718:	10c00c05 	stb	r3,48(r2)
  47171c:	e0bff517 	ldw	r2,-44(fp)
  471720:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  471724:	0005303a 	rdctl	r2,status
  471728:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  47172c:	e0fffe17 	ldw	r3,-8(fp)
  471730:	00bfff84 	movi	r2,-2
  471734:	1884703a 	and	r2,r3,r2
  471738:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  47173c:	e0bffd17 	ldw	r2,-12(fp)
  471740:	1080004c 	andi	r2,r2,1
  471744:	e0fffe17 	ldw	r3,-8(fp)
  471748:	1884b03a 	or	r2,r3,r2
  47174c:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
  471750:	e0bffe17 	ldw	r2,-8(fp)
  471754:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
  471758:	e0bff403 	ldbu	r2,-48(fp)
  47175c:	10800058 	cmpnei	r2,r2,1
  471760:	1000011e 	bne	r2,zero,471768 <OSTaskSuspend+0x27c>
        OS_Sched();                                             /* Find new highest priority task      */
  471764:	046a4980 	call	46a498 <OS_Sched>
    }
    return (OS_ERR_NONE);
  471768:	0005883a 	mov	r2,zero
}
  47176c:	e037883a 	mov	sp,fp
  471770:	dfc00117 	ldw	ra,4(sp)
  471774:	df000017 	ldw	fp,0(sp)
  471778:	dec00204 	addi	sp,sp,8
  47177c:	f800283a 	ret

00471780 <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
  471780:	defff304 	addi	sp,sp,-52
  471784:	dfc00c15 	stw	ra,48(sp)
  471788:	df000b15 	stw	fp,44(sp)
  47178c:	df000b04 	addi	fp,sp,44
  471790:	2005883a 	mov	r2,r4
  471794:	e17fff15 	stw	r5,-4(fp)
  471798:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
  47179c:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
  4717a0:	e0bffe03 	ldbu	r2,-8(fp)
  4717a4:	10800570 	cmpltui	r2,r2,21
  4717a8:	1000051e 	bne	r2,zero,4717c0 <OSTaskQuery+0x40>
        if (prio != OS_PRIO_SELF) {
  4717ac:	e0bffe03 	ldbu	r2,-8(fp)
  4717b0:	10803fe0 	cmpeqi	r2,r2,255
  4717b4:	1000021e 	bne	r2,zero,4717c0 <OSTaskQuery+0x40>
            return (OS_ERR_PRIO_INVALID);
  4717b8:	00800a84 	movi	r2,42
  4717bc:	00005706 	br	47191c <OSTaskQuery+0x19c>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
  4717c0:	e0bfff17 	ldw	r2,-4(fp)
  4717c4:	1000021e 	bne	r2,zero,4717d0 <OSTaskQuery+0x50>
        return (OS_ERR_PDATA_NULL);
  4717c8:	00800244 	movi	r2,9
  4717cc:	00005306 	br	47191c <OSTaskQuery+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  4717d0:	0005303a 	rdctl	r2,status
  4717d4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  4717d8:	e0fff717 	ldw	r3,-36(fp)
  4717dc:	00bfff84 	movi	r2,-2
  4717e0:	1884703a 	and	r2,r3,r2
  4717e4:	1001703a 	wrctl	status,r2
  
  return context;
  4717e8:	e0bff717 	ldw	r2,-36(fp)
    }
#endif
    OS_ENTER_CRITICAL();
  4717ec:	e0bff515 	stw	r2,-44(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
  4717f0:	e0bffe03 	ldbu	r2,-8(fp)
  4717f4:	10803fd8 	cmpnei	r2,r2,255
  4717f8:	1000051e 	bne	r2,zero,471810 <OSTaskQuery+0x90>
        prio = OSTCBCur->OSTCBPrio;
  4717fc:	00801234 	movhi	r2,72
  471800:	10a64d04 	addi	r2,r2,-26316
  471804:	10800017 	ldw	r2,0(r2)
  471808:	10800c83 	ldbu	r2,50(r2)
  47180c:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
  471810:	e0bffe03 	ldbu	r2,-8(fp)
  471814:	00c01234 	movhi	r3,72
  471818:	18f31404 	addi	r3,r3,-13232
  47181c:	1085883a 	add	r2,r2,r2
  471820:	1085883a 	add	r2,r2,r2
  471824:	1885883a 	add	r2,r3,r2
  471828:	10800017 	ldw	r2,0(r2)
  47182c:	e0bff615 	stw	r2,-40(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
  471830:	e0bff617 	ldw	r2,-40(fp)
  471834:	1000111e 	bne	r2,zero,47187c <OSTaskQuery+0xfc>
  471838:	e0bff517 	ldw	r2,-44(fp)
  47183c:	e0bff815 	stw	r2,-32(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  471840:	0005303a 	rdctl	r2,status
  471844:	e0bff915 	stw	r2,-28(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  471848:	e0fff917 	ldw	r3,-28(fp)
  47184c:	00bfff84 	movi	r2,-2
  471850:	1884703a 	and	r2,r3,r2
  471854:	e0bff915 	stw	r2,-28(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  471858:	e0bff817 	ldw	r2,-32(fp)
  47185c:	1080004c 	andi	r2,r2,1
  471860:	e0fff917 	ldw	r3,-28(fp)
  471864:	1884b03a 	or	r2,r3,r2
  471868:	e0bff915 	stw	r2,-28(fp)
  
  NIOS2_WRITE_STATUS (status);
  47186c:	e0bff917 	ldw	r2,-28(fp)
  471870:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
  471874:	00800a44 	movi	r2,41
  471878:	00002806 	br	47191c <OSTaskQuery+0x19c>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
  47187c:	e0bff617 	ldw	r2,-40(fp)
  471880:	10800058 	cmpnei	r2,r2,1
  471884:	1000111e 	bne	r2,zero,4718cc <OSTaskQuery+0x14c>
  471888:	e0bff517 	ldw	r2,-44(fp)
  47188c:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  471890:	0005303a 	rdctl	r2,status
  471894:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  471898:	e0fffb17 	ldw	r3,-20(fp)
  47189c:	00bfff84 	movi	r2,-2
  4718a0:	1884703a 	and	r2,r3,r2
  4718a4:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  4718a8:	e0bffa17 	ldw	r2,-24(fp)
  4718ac:	1080004c 	andi	r2,r2,1
  4718b0:	e0fffb17 	ldw	r3,-20(fp)
  4718b4:	1884b03a 	or	r2,r3,r2
  4718b8:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
  4718bc:	e0bffb17 	ldw	r2,-20(fp)
  4718c0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
  4718c4:	008010c4 	movi	r2,67
  4718c8:	00001406 	br	47191c <OSTaskQuery+0x19c>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
  4718cc:	e13fff17 	ldw	r4,-4(fp)
  4718d0:	e17ff617 	ldw	r5,-40(fp)
  4718d4:	01801b04 	movi	r6,108
  4718d8:	046a42c0 	call	46a42c <OS_MemCopy>
  4718dc:	e0bff517 	ldw	r2,-44(fp)
  4718e0:	e0bffc15 	stw	r2,-16(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  4718e4:	0005303a 	rdctl	r2,status
  4718e8:	e0bffd15 	stw	r2,-12(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  4718ec:	e0fffd17 	ldw	r3,-12(fp)
  4718f0:	00bfff84 	movi	r2,-2
  4718f4:	1884703a 	and	r2,r3,r2
  4718f8:	e0bffd15 	stw	r2,-12(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  4718fc:	e0bffc17 	ldw	r2,-16(fp)
  471900:	1080004c 	andi	r2,r2,1
  471904:	e0fffd17 	ldw	r3,-12(fp)
  471908:	1884b03a 	or	r2,r3,r2
  47190c:	e0bffd15 	stw	r2,-12(fp)
  
  NIOS2_WRITE_STATUS (status);
  471910:	e0bffd17 	ldw	r2,-12(fp)
  471914:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
  471918:	0005883a 	mov	r2,zero
}
  47191c:	e037883a 	mov	sp,fp
  471920:	dfc00117 	ldw	ra,4(sp)
  471924:	df000017 	ldw	fp,0(sp)
  471928:	dec00204 	addi	sp,sp,8
  47192c:	f800283a 	ret

00471930 <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
  471930:	defffc04 	addi	sp,sp,-16
  471934:	df000315 	stw	fp,12(sp)
  471938:	df000304 	addi	fp,sp,12
  47193c:	e13ffd15 	stw	r4,-12(fp)
  471940:	e17ffe15 	stw	r5,-8(fp)
  471944:	3005883a 	mov	r2,r6
  471948:	e0bfff0d 	sth	r2,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
  47194c:	e0bfff0b 	ldhu	r2,-4(fp)
  471950:	1080004c 	andi	r2,r2,1
  471954:	10000e26 	beq	r2,zero,471990 <OS_TaskStkClr+0x60>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
  471958:	e0bfff0b 	ldhu	r2,-4(fp)
  47195c:	1080008c 	andi	r2,r2,2
  471960:	10000b26 	beq	r2,zero,471990 <OS_TaskStkClr+0x60>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
  471964:	00000806 	br	471988 <OS_TaskStkClr+0x58>
                size--;
  471968:	e0bffe17 	ldw	r2,-8(fp)
  47196c:	10bfffc4 	addi	r2,r2,-1
  471970:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
  471974:	e0bffd17 	ldw	r2,-12(fp)
  471978:	10000015 	stw	zero,0(r2)
  47197c:	e0bffd17 	ldw	r2,-12(fp)
  471980:	10800104 	addi	r2,r2,4
  471984:	e0bffd15 	stw	r2,-12(fp)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
  471988:	e0bffe17 	ldw	r2,-8(fp)
  47198c:	103ff61e 	bne	r2,zero,471968 <OS_TaskStkClr+0x38>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
  471990:	e037883a 	mov	sp,fp
  471994:	df000017 	ldw	fp,0(sp)
  471998:	dec00104 	addi	sp,sp,4
  47199c:	f800283a 	ret

004719a0 <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
  4719a0:	defff804 	addi	sp,sp,-32
  4719a4:	dfc00715 	stw	ra,28(sp)
  4719a8:	df000615 	stw	fp,24(sp)
  4719ac:	df000604 	addi	fp,sp,24
  4719b0:	2005883a 	mov	r2,r4
  4719b4:	e0bfff0d 	sth	r2,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
  4719b8:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
  4719bc:	00801234 	movhi	r2,72
  4719c0:	10a64c04 	addi	r2,r2,-26320
  4719c4:	10800003 	ldbu	r2,0(r2)
  4719c8:	10803fcc 	andi	r2,r2,255
  4719cc:	10004b1e 	bne	r2,zero,471afc <OSTimeDly+0x15c>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
  4719d0:	e0bfff0b 	ldhu	r2,-4(fp)
  4719d4:	10004a26 	beq	r2,zero,471b00 <OSTimeDly+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  4719d8:	0005303a 	rdctl	r2,status
  4719dc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  4719e0:	e0fffc17 	ldw	r3,-16(fp)
  4719e4:	00bfff84 	movi	r2,-2
  4719e8:	1884703a 	and	r2,r3,r2
  4719ec:	1001703a 	wrctl	status,r2
  
  return context;
  4719f0:	e0bffc17 	ldw	r2,-16(fp)
        OS_ENTER_CRITICAL();
  4719f4:	e0bffa15 	stw	r2,-24(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
  4719f8:	00801234 	movhi	r2,72
  4719fc:	10a64d04 	addi	r2,r2,-26316
  471a00:	10800017 	ldw	r2,0(r2)
  471a04:	10800d03 	ldbu	r2,52(r2)
  471a08:	e0bffb05 	stb	r2,-20(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
  471a0c:	e0bffb03 	ldbu	r2,-20(fp)
  471a10:	e0fffb03 	ldbu	r3,-20(fp)
  471a14:	01001234 	movhi	r4,72
  471a18:	21264a44 	addi	r4,r4,-26327
  471a1c:	20c7883a 	add	r3,r4,r3
  471a20:	18c00003 	ldbu	r3,0(r3)
  471a24:	1809883a 	mov	r4,r3
  471a28:	00c01234 	movhi	r3,72
  471a2c:	18e64d04 	addi	r3,r3,-26316
  471a30:	18c00017 	ldw	r3,0(r3)
  471a34:	18c00d43 	ldbu	r3,53(r3)
  471a38:	00c6303a 	nor	r3,zero,r3
  471a3c:	20c6703a 	and	r3,r4,r3
  471a40:	01001234 	movhi	r4,72
  471a44:	21264a44 	addi	r4,r4,-26327
  471a48:	2085883a 	add	r2,r4,r2
  471a4c:	10c00005 	stb	r3,0(r2)
        if (OSRdyTbl[y] == 0) {
  471a50:	e0bffb03 	ldbu	r2,-20(fp)
  471a54:	00c01234 	movhi	r3,72
  471a58:	18e64a44 	addi	r3,r3,-26327
  471a5c:	1885883a 	add	r2,r3,r2
  471a60:	10800003 	ldbu	r2,0(r2)
  471a64:	10803fcc 	andi	r2,r2,255
  471a68:	10000e1e 	bne	r2,zero,471aa4 <OSTimeDly+0x104>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
  471a6c:	00801234 	movhi	r2,72
  471a70:	10a64d04 	addi	r2,r2,-26316
  471a74:	10800017 	ldw	r2,0(r2)
  471a78:	10800d83 	ldbu	r2,54(r2)
  471a7c:	0084303a 	nor	r2,zero,r2
  471a80:	1007883a 	mov	r3,r2
  471a84:	00801234 	movhi	r2,72
  471a88:	10a64a04 	addi	r2,r2,-26328
  471a8c:	10800003 	ldbu	r2,0(r2)
  471a90:	1884703a 	and	r2,r3,r2
  471a94:	1007883a 	mov	r3,r2
  471a98:	00801234 	movhi	r2,72
  471a9c:	10a64a04 	addi	r2,r2,-26328
  471aa0:	10c00005 	stb	r3,0(r2)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
  471aa4:	00801234 	movhi	r2,72
  471aa8:	10a64d04 	addi	r2,r2,-26316
  471aac:	10800017 	ldw	r2,0(r2)
  471ab0:	e0ffff0b 	ldhu	r3,-4(fp)
  471ab4:	10c00b8d 	sth	r3,46(r2)
  471ab8:	e0bffa17 	ldw	r2,-24(fp)
  471abc:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  471ac0:	0005303a 	rdctl	r2,status
  471ac4:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  471ac8:	e0fffe17 	ldw	r3,-8(fp)
  471acc:	00bfff84 	movi	r2,-2
  471ad0:	1884703a 	and	r2,r3,r2
  471ad4:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  471ad8:	e0bffd17 	ldw	r2,-12(fp)
  471adc:	1080004c 	andi	r2,r2,1
  471ae0:	e0fffe17 	ldw	r3,-8(fp)
  471ae4:	1884b03a 	or	r2,r3,r2
  471ae8:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
  471aec:	e0bffe17 	ldw	r2,-8(fp)
  471af0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
  471af4:	046a4980 	call	46a498 <OS_Sched>
  471af8:	00000106 	br	471b00 <OSTimeDly+0x160>
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        return;
  471afc:	0001883a 	nop
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
    }
}
  471b00:	e037883a 	mov	sp,fp
  471b04:	dfc00117 	ldw	ra,4(sp)
  471b08:	df000017 	ldw	fp,0(sp)
  471b0c:	dec00204 	addi	sp,sp,8
  471b10:	f800283a 	ret

00471b14 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
  471b14:	defff604 	addi	sp,sp,-40
  471b18:	dfc00915 	stw	ra,36(sp)
  471b1c:	df000815 	stw	fp,32(sp)
  471b20:	dc400715 	stw	r17,28(sp)
  471b24:	dc000615 	stw	r16,24(sp)
  471b28:	df000604 	addi	fp,sp,24
  471b2c:	2011883a 	mov	r8,r4
  471b30:	2809883a 	mov	r4,r5
  471b34:	3007883a 	mov	r3,r6
  471b38:	3805883a 	mov	r2,r7
  471b3c:	e23ffc05 	stb	r8,-16(fp)
  471b40:	e13ffd05 	stb	r4,-12(fp)
  471b44:	e0fffe05 	stb	r3,-8(fp)
  471b48:	e0bfff0d 	sth	r2,-4(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
  471b4c:	00801234 	movhi	r2,72
  471b50:	10a64c04 	addi	r2,r2,-26320
  471b54:	10800003 	ldbu	r2,0(r2)
  471b58:	10803fcc 	andi	r2,r2,255
  471b5c:	10000226 	beq	r2,zero,471b68 <OSTimeDlyHMSM+0x54>
        return (OS_ERR_TIME_DLY_ISR);
  471b60:	00801544 	movi	r2,85
  471b64:	00007506 	br	471d3c <OSTimeDlyHMSM+0x228>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
  471b68:	e0bffc03 	ldbu	r2,-16(fp)
  471b6c:	1000081e 	bne	r2,zero,471b90 <OSTimeDlyHMSM+0x7c>
        if (minutes == 0) {
  471b70:	e0bffd03 	ldbu	r2,-12(fp)
  471b74:	1000061e 	bne	r2,zero,471b90 <OSTimeDlyHMSM+0x7c>
            if (seconds == 0) {
  471b78:	e0bffe03 	ldbu	r2,-8(fp)
  471b7c:	1000041e 	bne	r2,zero,471b90 <OSTimeDlyHMSM+0x7c>
                if (ms == 0) {
  471b80:	e0bfff0b 	ldhu	r2,-4(fp)
  471b84:	1000021e 	bne	r2,zero,471b90 <OSTimeDlyHMSM+0x7c>
                    return (OS_ERR_TIME_ZERO_DLY);
  471b88:	00801504 	movi	r2,84
  471b8c:	00006b06 	br	471d3c <OSTimeDlyHMSM+0x228>
                }
            }
        }
    }
    if (minutes > 59) {
  471b90:	e0bffd03 	ldbu	r2,-12(fp)
  471b94:	10800f30 	cmpltui	r2,r2,60
  471b98:	1000021e 	bne	r2,zero,471ba4 <OSTimeDlyHMSM+0x90>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
  471b9c:	00801444 	movi	r2,81
  471ba0:	00006606 	br	471d3c <OSTimeDlyHMSM+0x228>
    }
    if (seconds > 59) {
  471ba4:	e0bffe03 	ldbu	r2,-8(fp)
  471ba8:	10800f30 	cmpltui	r2,r2,60
  471bac:	1000021e 	bne	r2,zero,471bb8 <OSTimeDlyHMSM+0xa4>
        return (OS_ERR_TIME_INVALID_SECONDS);
  471bb0:	00801484 	movi	r2,82
  471bb4:	00006106 	br	471d3c <OSTimeDlyHMSM+0x228>
    }
    if (ms > 999) {
  471bb8:	e0bfff0b 	ldhu	r2,-4(fp)
  471bbc:	1080fa30 	cmpltui	r2,r2,1000
  471bc0:	1000021e 	bne	r2,zero,471bcc <OSTimeDlyHMSM+0xb8>
        return (OS_ERR_TIME_INVALID_MS);
  471bc4:	008014c4 	movi	r2,83
  471bc8:	00005c06 	br	471d3c <OSTimeDlyHMSM+0x228>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
  471bcc:	e0bffc03 	ldbu	r2,-16(fp)
  471bd0:	1009883a 	mov	r4,r2
  471bd4:	01438404 	movi	r5,3600
  471bd8:	04675f00 	call	4675f0 <__mulsi3>
  471bdc:	1021883a 	mov	r16,r2
  471be0:	e0bffd03 	ldbu	r2,-12(fp)
  471be4:	1009883a 	mov	r4,r2
  471be8:	01400f04 	movi	r5,60
  471bec:	04675f00 	call	4675f0 <__mulsi3>
  471bf0:	8087883a 	add	r3,r16,r2
  471bf4:	e0bffe03 	ldbu	r2,-8(fp)
  471bf8:	1885883a 	add	r2,r3,r2
  471bfc:	1009883a 	mov	r4,r2
  471c00:	04756f80 	call	4756f8 <__floatunsidf>
  471c04:	100b883a 	mov	r5,r2
  471c08:	180d883a 	mov	r6,r3
  471c0c:	2809883a 	mov	r4,r5
  471c10:	300b883a 	mov	r5,r6
  471c14:	000d883a 	mov	r6,zero
  471c18:	01d01674 	movhi	r7,16473
  471c1c:	04751280 	call	475128 <__muldf3>
  471c20:	1009883a 	mov	r4,r2
  471c24:	180b883a 	mov	r5,r3
  471c28:	2021883a 	mov	r16,r4
  471c2c:	2823883a 	mov	r17,r5
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
  471c30:	e0bfff0b 	ldhu	r2,-4(fp)
  471c34:	1009883a 	mov	r4,r2
  471c38:	04756f80 	call	4756f8 <__floatunsidf>
  471c3c:	100b883a 	mov	r5,r2
  471c40:	180d883a 	mov	r6,r3
  471c44:	2809883a 	mov	r4,r5
  471c48:	300b883a 	mov	r5,r6
  471c4c:	000d883a 	mov	r6,zero
  471c50:	01d00534 	movhi	r7,16404
  471c54:	04750740 	call	475074 <__adddf3>
  471c58:	1009883a 	mov	r4,r2
  471c5c:	180b883a 	mov	r5,r3
  471c60:	2005883a 	mov	r2,r4
  471c64:	2807883a 	mov	r3,r5
  471c68:	1009883a 	mov	r4,r2
  471c6c:	180b883a 	mov	r5,r3
  471c70:	000d883a 	mov	r6,zero
  471c74:	01d01674 	movhi	r7,16473
  471c78:	04751280 	call	475128 <__muldf3>
  471c7c:	1009883a 	mov	r4,r2
  471c80:	180b883a 	mov	r5,r3
  471c84:	2005883a 	mov	r2,r4
  471c88:	2807883a 	mov	r3,r5
  471c8c:	1009883a 	mov	r4,r2
  471c90:	180b883a 	mov	r5,r3
  471c94:	000d883a 	mov	r6,zero
  471c98:	01d023f4 	movhi	r7,16527
  471c9c:	39d00004 	addi	r7,r7,16384
  471ca0:	047540c0 	call	47540c <__divdf3>
  471ca4:	1009883a 	mov	r4,r2
  471ca8:	180b883a 	mov	r5,r3
  471cac:	2005883a 	mov	r2,r4
  471cb0:	2807883a 	mov	r3,r5
  471cb4:	8009883a 	mov	r4,r16
  471cb8:	880b883a 	mov	r5,r17
  471cbc:	100d883a 	mov	r6,r2
  471cc0:	180f883a 	mov	r7,r3
  471cc4:	04750740 	call	475074 <__adddf3>
  471cc8:	1009883a 	mov	r4,r2
  471ccc:	180b883a 	mov	r5,r3
  471cd0:	2005883a 	mov	r2,r4
  471cd4:	2807883a 	mov	r3,r5
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
  471cd8:	1009883a 	mov	r4,r2
  471cdc:	180b883a 	mov	r5,r3
  471ce0:	0474c9c0 	call	474c9c <__fixunsdfsi>
  471ce4:	e0bffb15 	stw	r2,-20(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
  471ce8:	e0bffb17 	ldw	r2,-20(fp)
  471cec:	1004d43a 	srli	r2,r2,16
  471cf0:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
  471cf4:	e0bffb17 	ldw	r2,-20(fp)
  471cf8:	10bfffcc 	andi	r2,r2,65535
  471cfc:	e0bffb15 	stw	r2,-20(fp)
    OSTimeDly((INT16U)ticks);
  471d00:	e0bffb17 	ldw	r2,-20(fp)
  471d04:	10bfffcc 	andi	r2,r2,65535
  471d08:	1009883a 	mov	r4,r2
  471d0c:	04719a00 	call	4719a0 <OSTimeDly>
    while (loops > 0) {
  471d10:	00000706 	br	471d30 <OSTimeDlyHMSM+0x21c>
        OSTimeDly((INT16U)32768u);
  471d14:	01200014 	movui	r4,32768
  471d18:	04719a00 	call	4719a0 <OSTimeDly>
        OSTimeDly((INT16U)32768u);
  471d1c:	01200014 	movui	r4,32768
  471d20:	04719a00 	call	4719a0 <OSTimeDly>
        loops--;
  471d24:	e0bffa0b 	ldhu	r2,-24(fp)
  471d28:	10bfffc4 	addi	r2,r2,-1
  471d2c:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
  471d30:	e0bffa0b 	ldhu	r2,-24(fp)
  471d34:	103ff71e 	bne	r2,zero,471d14 <OSTimeDlyHMSM+0x200>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
  471d38:	0005883a 	mov	r2,zero
}
  471d3c:	e037883a 	mov	sp,fp
  471d40:	dfc00317 	ldw	ra,12(sp)
  471d44:	df000217 	ldw	fp,8(sp)
  471d48:	dc400117 	ldw	r17,4(sp)
  471d4c:	dc000017 	ldw	r16,0(sp)
  471d50:	dec00404 	addi	sp,sp,16
  471d54:	f800283a 	ret

00471d58 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
  471d58:	defff004 	addi	sp,sp,-64
  471d5c:	dfc00f15 	stw	ra,60(sp)
  471d60:	df000e15 	stw	fp,56(sp)
  471d64:	df000e04 	addi	fp,sp,56
  471d68:	2005883a 	mov	r2,r4
  471d6c:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
  471d70:	e03ff215 	stw	zero,-56(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
  471d74:	e0bfff03 	ldbu	r2,-4(fp)
  471d78:	10800530 	cmpltui	r2,r2,20
  471d7c:	1000021e 	bne	r2,zero,471d88 <OSTimeDlyResume+0x30>
        return (OS_ERR_PRIO_INVALID);
  471d80:	00800a84 	movi	r2,42
  471d84:	0000a106 	br	47200c <OSTimeDlyResume+0x2b4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  471d88:	0005303a 	rdctl	r2,status
  471d8c:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  471d90:	e0fff417 	ldw	r3,-48(fp)
  471d94:	00bfff84 	movi	r2,-2
  471d98:	1884703a 	and	r2,r3,r2
  471d9c:	1001703a 	wrctl	status,r2
  
  return context;
  471da0:	e0bff417 	ldw	r2,-48(fp)
    }
    OS_ENTER_CRITICAL();
  471da4:	e0bff215 	stw	r2,-56(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
  471da8:	e0bfff03 	ldbu	r2,-4(fp)
  471dac:	00c01234 	movhi	r3,72
  471db0:	18f31404 	addi	r3,r3,-13232
  471db4:	1085883a 	add	r2,r2,r2
  471db8:	1085883a 	add	r2,r2,r2
  471dbc:	1885883a 	add	r2,r3,r2
  471dc0:	10800017 	ldw	r2,0(r2)
  471dc4:	e0bff315 	stw	r2,-52(fp)
    if (ptcb == (OS_TCB *)0) {
  471dc8:	e0bff317 	ldw	r2,-52(fp)
  471dcc:	1000111e 	bne	r2,zero,471e14 <OSTimeDlyResume+0xbc>
  471dd0:	e0bff217 	ldw	r2,-56(fp)
  471dd4:	e0bff515 	stw	r2,-44(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  471dd8:	0005303a 	rdctl	r2,status
  471ddc:	e0bff615 	stw	r2,-40(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  471de0:	e0fff617 	ldw	r3,-40(fp)
  471de4:	00bfff84 	movi	r2,-2
  471de8:	1884703a 	and	r2,r3,r2
  471dec:	e0bff615 	stw	r2,-40(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  471df0:	e0bff517 	ldw	r2,-44(fp)
  471df4:	1080004c 	andi	r2,r2,1
  471df8:	e0fff617 	ldw	r3,-40(fp)
  471dfc:	1884b03a 	or	r2,r3,r2
  471e00:	e0bff615 	stw	r2,-40(fp)
  
  NIOS2_WRITE_STATUS (status);
  471e04:	e0bff617 	ldw	r2,-40(fp)
  471e08:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
  471e0c:	008010c4 	movi	r2,67
  471e10:	00007e06 	br	47200c <OSTimeDlyResume+0x2b4>
    }
    if (ptcb == OS_TCB_RESERVED) {
  471e14:	e0bff317 	ldw	r2,-52(fp)
  471e18:	10800058 	cmpnei	r2,r2,1
  471e1c:	1000111e 	bne	r2,zero,471e64 <OSTimeDlyResume+0x10c>
  471e20:	e0bff217 	ldw	r2,-56(fp)
  471e24:	e0bff715 	stw	r2,-36(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  471e28:	0005303a 	rdctl	r2,status
  471e2c:	e0bff815 	stw	r2,-32(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  471e30:	e0fff817 	ldw	r3,-32(fp)
  471e34:	00bfff84 	movi	r2,-2
  471e38:	1884703a 	and	r2,r3,r2
  471e3c:	e0bff815 	stw	r2,-32(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  471e40:	e0bff717 	ldw	r2,-36(fp)
  471e44:	1080004c 	andi	r2,r2,1
  471e48:	e0fff817 	ldw	r3,-32(fp)
  471e4c:	1884b03a 	or	r2,r3,r2
  471e50:	e0bff815 	stw	r2,-32(fp)
  
  NIOS2_WRITE_STATUS (status);
  471e54:	e0bff817 	ldw	r2,-32(fp)
  471e58:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
  471e5c:	008010c4 	movi	r2,67
  471e60:	00006a06 	br	47200c <OSTimeDlyResume+0x2b4>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
  471e64:	e0bff317 	ldw	r2,-52(fp)
  471e68:	10800b8b 	ldhu	r2,46(r2)
  471e6c:	10bfffcc 	andi	r2,r2,65535
  471e70:	1000111e 	bne	r2,zero,471eb8 <OSTimeDlyResume+0x160>
  471e74:	e0bff217 	ldw	r2,-56(fp)
  471e78:	e0bff915 	stw	r2,-28(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  471e7c:	0005303a 	rdctl	r2,status
  471e80:	e0bffa15 	stw	r2,-24(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  471e84:	e0fffa17 	ldw	r3,-24(fp)
  471e88:	00bfff84 	movi	r2,-2
  471e8c:	1884703a 	and	r2,r3,r2
  471e90:	e0bffa15 	stw	r2,-24(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  471e94:	e0bff917 	ldw	r2,-28(fp)
  471e98:	1080004c 	andi	r2,r2,1
  471e9c:	e0fffa17 	ldw	r3,-24(fp)
  471ea0:	1884b03a 	or	r2,r3,r2
  471ea4:	e0bffa15 	stw	r2,-24(fp)
  
  NIOS2_WRITE_STATUS (status);
  471ea8:	e0bffa17 	ldw	r2,-24(fp)
  471eac:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
  471eb0:	00801404 	movi	r2,80
  471eb4:	00005506 	br	47200c <OSTimeDlyResume+0x2b4>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
  471eb8:	e0bff317 	ldw	r2,-52(fp)
  471ebc:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
  471ec0:	e0bff317 	ldw	r2,-52(fp)
  471ec4:	10800c03 	ldbu	r2,48(r2)
  471ec8:	10803fcc 	andi	r2,r2,255
  471ecc:	10800dcc 	andi	r2,r2,55
  471ed0:	10000b26 	beq	r2,zero,471f00 <OSTimeDlyResume+0x1a8>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
  471ed4:	e0bff317 	ldw	r2,-52(fp)
  471ed8:	10c00c03 	ldbu	r3,48(r2)
  471edc:	00bff204 	movi	r2,-56
  471ee0:	1884703a 	and	r2,r3,r2
  471ee4:	1007883a 	mov	r3,r2
  471ee8:	e0bff317 	ldw	r2,-52(fp)
  471eec:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
  471ef0:	e0bff317 	ldw	r2,-52(fp)
  471ef4:	00c00044 	movi	r3,1
  471ef8:	10c00c45 	stb	r3,49(r2)
  471efc:	00000206 	br	471f08 <OSTimeDlyResume+0x1b0>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
  471f00:	e0bff317 	ldw	r2,-52(fp)
  471f04:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
  471f08:	e0bff317 	ldw	r2,-52(fp)
  471f0c:	10800c03 	ldbu	r2,48(r2)
  471f10:	10803fcc 	andi	r2,r2,255
  471f14:	1080020c 	andi	r2,r2,8
  471f18:	10002c1e 	bne	r2,zero,471fcc <OSTimeDlyResume+0x274>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
  471f1c:	e0bff317 	ldw	r2,-52(fp)
  471f20:	10c00d83 	ldbu	r3,54(r2)
  471f24:	00801234 	movhi	r2,72
  471f28:	10a64a04 	addi	r2,r2,-26328
  471f2c:	10800003 	ldbu	r2,0(r2)
  471f30:	1884b03a 	or	r2,r3,r2
  471f34:	1007883a 	mov	r3,r2
  471f38:	00801234 	movhi	r2,72
  471f3c:	10a64a04 	addi	r2,r2,-26328
  471f40:	10c00005 	stb	r3,0(r2)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
  471f44:	e0bff317 	ldw	r2,-52(fp)
  471f48:	10800d03 	ldbu	r2,52(r2)
  471f4c:	10803fcc 	andi	r2,r2,255
  471f50:	e0fff317 	ldw	r3,-52(fp)
  471f54:	18c00d03 	ldbu	r3,52(r3)
  471f58:	18c03fcc 	andi	r3,r3,255
  471f5c:	01001234 	movhi	r4,72
  471f60:	21264a44 	addi	r4,r4,-26327
  471f64:	20c7883a 	add	r3,r4,r3
  471f68:	19000003 	ldbu	r4,0(r3)
  471f6c:	e0fff317 	ldw	r3,-52(fp)
  471f70:	18c00d43 	ldbu	r3,53(r3)
  471f74:	20c6b03a 	or	r3,r4,r3
  471f78:	01001234 	movhi	r4,72
  471f7c:	21264a44 	addi	r4,r4,-26327
  471f80:	2085883a 	add	r2,r4,r2
  471f84:	10c00005 	stb	r3,0(r2)
  471f88:	e0bff217 	ldw	r2,-56(fp)
  471f8c:	e0bffb15 	stw	r2,-20(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  471f90:	0005303a 	rdctl	r2,status
  471f94:	e0bffc15 	stw	r2,-16(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  471f98:	e0fffc17 	ldw	r3,-16(fp)
  471f9c:	00bfff84 	movi	r2,-2
  471fa0:	1884703a 	and	r2,r3,r2
  471fa4:	e0bffc15 	stw	r2,-16(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  471fa8:	e0bffb17 	ldw	r2,-20(fp)
  471fac:	1080004c 	andi	r2,r2,1
  471fb0:	e0fffc17 	ldw	r3,-16(fp)
  471fb4:	1884b03a 	or	r2,r3,r2
  471fb8:	e0bffc15 	stw	r2,-16(fp)
  
  NIOS2_WRITE_STATUS (status);
  471fbc:	e0bffc17 	ldw	r2,-16(fp)
  471fc0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
  471fc4:	046a4980 	call	46a498 <OS_Sched>
  471fc8:	00000f06 	br	472008 <OSTimeDlyResume+0x2b0>
  471fcc:	e0bff217 	ldw	r2,-56(fp)
  471fd0:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  471fd4:	0005303a 	rdctl	r2,status
  471fd8:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  471fdc:	e0fffe17 	ldw	r3,-8(fp)
  471fe0:	00bfff84 	movi	r2,-2
  471fe4:	1884703a 	and	r2,r3,r2
  471fe8:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  471fec:	e0bffd17 	ldw	r2,-12(fp)
  471ff0:	1080004c 	andi	r2,r2,1
  471ff4:	e0fffe17 	ldw	r3,-8(fp)
  471ff8:	1884b03a 	or	r2,r3,r2
  471ffc:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
  472000:	e0bffe17 	ldw	r2,-8(fp)
  472004:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
  472008:	0005883a 	mov	r2,zero
}
  47200c:	e037883a 	mov	sp,fp
  472010:	dfc00117 	ldw	ra,4(sp)
  472014:	df000017 	ldw	fp,0(sp)
  472018:	dec00204 	addi	sp,sp,8
  47201c:	f800283a 	ret

00472020 <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
  472020:	defffa04 	addi	sp,sp,-24
  472024:	df000515 	stw	fp,20(sp)
  472028:	df000504 	addi	fp,sp,20
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
  47202c:	e03ffb15 	stw	zero,-20(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  472030:	0005303a 	rdctl	r2,status
  472034:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  472038:	e0fffd17 	ldw	r3,-12(fp)
  47203c:	00bfff84 	movi	r2,-2
  472040:	1884703a 	and	r2,r3,r2
  472044:	1001703a 	wrctl	status,r2
  
  return context;
  472048:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
  47204c:	e0bffb15 	stw	r2,-20(fp)
    ticks = OSTime;
  472050:	00801234 	movhi	r2,72
  472054:	10a64e04 	addi	r2,r2,-26312
  472058:	10800017 	ldw	r2,0(r2)
  47205c:	e0bffc15 	stw	r2,-16(fp)
  472060:	e0bffb17 	ldw	r2,-20(fp)
  472064:	e0bffe15 	stw	r2,-8(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  472068:	0005303a 	rdctl	r2,status
  47206c:	e0bfff15 	stw	r2,-4(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  472070:	e0ffff17 	ldw	r3,-4(fp)
  472074:	00bfff84 	movi	r2,-2
  472078:	1884703a 	and	r2,r3,r2
  47207c:	e0bfff15 	stw	r2,-4(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  472080:	e0bffe17 	ldw	r2,-8(fp)
  472084:	1080004c 	andi	r2,r2,1
  472088:	e0ffff17 	ldw	r3,-4(fp)
  47208c:	1884b03a 	or	r2,r3,r2
  472090:	e0bfff15 	stw	r2,-4(fp)
  
  NIOS2_WRITE_STATUS (status);
  472094:	e0bfff17 	ldw	r2,-4(fp)
  472098:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
  47209c:	e0bffc17 	ldw	r2,-16(fp)
}
  4720a0:	e037883a 	mov	sp,fp
  4720a4:	df000017 	ldw	fp,0(sp)
  4720a8:	dec00104 	addi	sp,sp,4
  4720ac:	f800283a 	ret

004720b0 <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
  4720b0:	defffa04 	addi	sp,sp,-24
  4720b4:	df000515 	stw	fp,20(sp)
  4720b8:	df000504 	addi	fp,sp,20
  4720bc:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
  4720c0:	e03ffb15 	stw	zero,-20(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  4720c4:	0005303a 	rdctl	r2,status
  4720c8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  4720cc:	e0fffc17 	ldw	r3,-16(fp)
  4720d0:	00bfff84 	movi	r2,-2
  4720d4:	1884703a 	and	r2,r3,r2
  4720d8:	1001703a 	wrctl	status,r2
  
  return context;
  4720dc:	e0bffc17 	ldw	r2,-16(fp)
#endif



    OS_ENTER_CRITICAL();
  4720e0:	e0bffb15 	stw	r2,-20(fp)
    OSTime = ticks;
  4720e4:	00801234 	movhi	r2,72
  4720e8:	10a64e04 	addi	r2,r2,-26312
  4720ec:	e0ffff17 	ldw	r3,-4(fp)
  4720f0:	10c00015 	stw	r3,0(r2)
  4720f4:	e0bffb17 	ldw	r2,-20(fp)
  4720f8:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  4720fc:	0005303a 	rdctl	r2,status
  472100:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  472104:	e0fffe17 	ldw	r3,-8(fp)
  472108:	00bfff84 	movi	r2,-2
  47210c:	1884703a 	and	r2,r3,r2
  472110:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  472114:	e0bffd17 	ldw	r2,-12(fp)
  472118:	1080004c 	andi	r2,r2,1
  47211c:	e0fffe17 	ldw	r3,-8(fp)
  472120:	1884b03a 	or	r2,r3,r2
  472124:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
  472128:	e0bffe17 	ldw	r2,-8(fp)
  47212c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
  472130:	e037883a 	mov	sp,fp
  472134:	df000017 	ldw	fp,0(sp)
  472138:	dec00104 	addi	sp,sp,4
  47213c:	f800283a 	ret

00472140 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
  472140:	defffd04 	addi	sp,sp,-12
  472144:	dfc00215 	stw	ra,8(sp)
  472148:	df000115 	stw	fp,4(sp)
  47214c:	df000104 	addi	fp,sp,4
  472150:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
  472154:	e13fff17 	ldw	r4,-4(fp)
  472158:	014011f4 	movhi	r5,71
  47215c:	295f3f04 	addi	r5,r5,31996
  472160:	04739940 	call	473994 <alt_dev_llist_insert>
}
  472164:	e037883a 	mov	sp,fp
  472168:	dfc00117 	ldw	ra,4(sp)
  47216c:	df000017 	ldw	fp,0(sp)
  472170:	dec00204 	addi	sp,sp,8
  472174:	f800283a 	ret

00472178 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  472178:	defffe04 	addi	sp,sp,-8
  47217c:	dfc00115 	stw	ra,4(sp)
  472180:	df000015 	stw	fp,0(sp)
  472184:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  472188:	008011f4 	movhi	r2,71
  47218c:	109f4204 	addi	r2,r2,32008
  472190:	10800017 	ldw	r2,0(r2)
  472194:	10000526 	beq	r2,zero,4721ac <alt_get_errno+0x34>
  472198:	008011f4 	movhi	r2,71
  47219c:	109f4204 	addi	r2,r2,32008
  4721a0:	10800017 	ldw	r2,0(r2)
  4721a4:	103ee83a 	callr	r2
  4721a8:	00000206 	br	4721b4 <alt_get_errno+0x3c>
  4721ac:	00801234 	movhi	r2,72
  4721b0:	10a63404 	addi	r2,r2,-26416
}
  4721b4:	e037883a 	mov	sp,fp
  4721b8:	dfc00117 	ldw	ra,4(sp)
  4721bc:	df000017 	ldw	fp,0(sp)
  4721c0:	dec00204 	addi	sp,sp,8
  4721c4:	f800283a 	ret

004721c8 <alt_avalon_mutex_reg>:
/*
 * Register a Mutex device
 */

static ALT_INLINE int alt_avalon_mutex_reg (alt_mutex_dev* dev)
{
  4721c8:	defffa04 	addi	sp,sp,-24
  4721cc:	dfc00515 	stw	ra,20(sp)
  4721d0:	df000415 	stw	fp,16(sp)
  4721d4:	df000404 	addi	fp,sp,16
  4721d8:	e13fff15 	stw	r4,-4(fp)
  int ret_code;
  extern alt_llist alt_mutex_list;
  ret_code = ALT_SEM_CREATE (&dev->lock, 1);
  4721dc:	e0bfff17 	ldw	r2,-4(fp)
  4721e0:	10800404 	addi	r2,r2,16
  4721e4:	e0bffd15 	stw	r2,-12(fp)
  4721e8:	00800044 	movi	r2,1
  4721ec:	e0bffe0d 	sth	r2,-8(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
  4721f0:	e0bffe0b 	ldhu	r2,-8(fp)
  4721f4:	1009883a 	mov	r4,r2
  4721f8:	046ec440 	call	46ec44 <OSSemCreate>
  4721fc:	e0fffd17 	ldw	r3,-12(fp)
  472200:	18800015 	stw	r2,0(r3)
  return *sem ? 0 : -1;
  472204:	e0bffd17 	ldw	r2,-12(fp)
  472208:	10800017 	ldw	r2,0(r2)
  47220c:	10000226 	beq	r2,zero,472218 <alt_avalon_mutex_reg+0x50>
  472210:	0005883a 	mov	r2,zero
  472214:	00000106 	br	47221c <alt_avalon_mutex_reg+0x54>
  472218:	00bfffc4 	movi	r2,-1
  47221c:	e0bffc15 	stw	r2,-16(fp)
  if (!ret_code)
  472220:	e0bffc17 	ldw	r2,-16(fp)
  472224:	1000061e 	bne	r2,zero,472240 <alt_avalon_mutex_reg+0x78>
  {
    ret_code = alt_dev_llist_insert((alt_dev_llist*) dev, &alt_mutex_list);
  472228:	e13fff17 	ldw	r4,-4(fp)
  47222c:	014011f4 	movhi	r5,71
  472230:	295f6404 	addi	r5,r5,32144
  472234:	04739940 	call	473994 <alt_dev_llist_insert>
  472238:	e0bffc15 	stw	r2,-16(fp)
  47223c:	00000506 	br	472254 <alt_avalon_mutex_reg+0x8c>
  }
  else
  {
    ALT_ERRNO = ENOMEM;
  472240:	04721780 	call	472178 <alt_get_errno>
  472244:	00c00304 	movi	r3,12
  472248:	10c00015 	stw	r3,0(r2)
    ret_code = -ENOMEM;
  47224c:	00bffd04 	movi	r2,-12
  472250:	e0bffc15 	stw	r2,-16(fp)
  }

  return ret_code;
  472254:	e0bffc17 	ldw	r2,-16(fp)
}
  472258:	e037883a 	mov	sp,fp
  47225c:	dfc00117 	ldw	ra,4(sp)
  472260:	df000017 	ldw	fp,0(sp)
  472264:	dec00204 	addi	sp,sp,8
  472268:	f800283a 	ret

0047226c <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
  47226c:	defffd04 	addi	sp,sp,-12
  472270:	dfc00215 	stw	ra,8(sp)
  472274:	df000115 	stw	fp,4(sp)
  472278:	df000104 	addi	fp,sp,4
  47227c:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( PROCESSOR0_0_CPU0, processor0_0_cpu0);
  472280:	04741640 	call	474164 <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
  472284:	00800044 	movi	r2,1
  472288:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
  47228c:	e037883a 	mov	sp,fp
  472290:	dfc00117 	ldw	ra,4(sp)
  472294:	df000017 	ldw	fp,0(sp)
  472298:	dec00204 	addi	sp,sp,8
  47229c:	f800283a 	ret

004722a0 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
  4722a0:	defffe04 	addi	sp,sp,-8
  4722a4:	dfc00115 	stw	ra,4(sp)
  4722a8:	df000015 	stw	fp,0(sp)
  4722ac:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( PROCESSOR0_0_TIMER, processor0_0_timer);
  4722b0:	01020034 	movhi	r4,2048
  4722b4:	21040804 	addi	r4,r4,4128
  4722b8:	000b883a 	mov	r5,zero
  4722bc:	000d883a 	mov	r6,zero
  4722c0:	01c01904 	movi	r7,100
  4722c4:	04734c40 	call	4734c4 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( PROCESSOR0_0_TIMESTAMP, processor0_0_timestamp);
  4722c8:	00801234 	movhi	r2,72
  4722cc:	10a65204 	addi	r2,r2,-26296
  4722d0:	00c20034 	movhi	r3,2048
  4722d4:	10c00015 	stw	r3,0(r2)
  4722d8:	00801234 	movhi	r2,72
  4722dc:	10a65304 	addi	r2,r2,-26292
  4722e0:	00c0bef4 	movhi	r3,763
  4722e4:	18fc2004 	addi	r3,r3,-3968
  4722e8:	10c00015 	stw	r3,0(r2)
    ALTERA_AVALON_JTAG_UART_INIT ( PROCESSOR0_0_JTAG_UART, processor0_0_jtag_uart);
  4722ec:	010011f4 	movhi	r4,71
  4722f0:	211b1d04 	addi	r4,r4,27764
  4722f4:	000b883a 	mov	r5,zero
  4722f8:	01800104 	movi	r6,4
  4722fc:	04724940 	call	472494 <altera_avalon_jtag_uart_init>
  472300:	010011f4 	movhi	r4,71
  472304:	211b1304 	addi	r4,r4,27724
  472308:	04721400 	call	472140 <alt_dev_reg>
    ALTERA_AVALON_MUTEX_INIT ( MUTEX_0, mutex_0);
  47230c:	010011f4 	movhi	r4,71
  472310:	211f2e04 	addi	r4,r4,31928
  472314:	04721c80 	call	4721c8 <alt_avalon_mutex_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYS_ID, sys_id);
  472318:	0001883a 	nop
}
  47231c:	e037883a 	mov	sp,fp
  472320:	dfc00117 	ldw	ra,4(sp)
  472324:	df000017 	ldw	fp,0(sp)
  472328:	dec00204 	addi	sp,sp,8
  47232c:	f800283a 	ret

00472330 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
  472330:	defffa04 	addi	sp,sp,-24
  472334:	dfc00515 	stw	ra,20(sp)
  472338:	df000415 	stw	fp,16(sp)
  47233c:	df000404 	addi	fp,sp,16
  472340:	e13ffd15 	stw	r4,-12(fp)
  472344:	e17ffe15 	stw	r5,-8(fp)
  472348:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  47234c:	e0bffd17 	ldw	r2,-12(fp)
  472350:	10800017 	ldw	r2,0(r2)
  472354:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
  472358:	e0bffc17 	ldw	r2,-16(fp)
  47235c:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
  472360:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
  472364:	10800217 	ldw	r2,8(r2)
  472368:	1809883a 	mov	r4,r3
  47236c:	e17ffe17 	ldw	r5,-8(fp)
  472370:	e1bfff17 	ldw	r6,-4(fp)
  472374:	100f883a 	mov	r7,r2
  472378:	0472ae40 	call	472ae4 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
  47237c:	e037883a 	mov	sp,fp
  472380:	dfc00117 	ldw	ra,4(sp)
  472384:	df000017 	ldw	fp,0(sp)
  472388:	dec00204 	addi	sp,sp,8
  47238c:	f800283a 	ret

00472390 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
  472390:	defffa04 	addi	sp,sp,-24
  472394:	dfc00515 	stw	ra,20(sp)
  472398:	df000415 	stw	fp,16(sp)
  47239c:	df000404 	addi	fp,sp,16
  4723a0:	e13ffd15 	stw	r4,-12(fp)
  4723a4:	e17ffe15 	stw	r5,-8(fp)
  4723a8:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  4723ac:	e0bffd17 	ldw	r2,-12(fp)
  4723b0:	10800017 	ldw	r2,0(r2)
  4723b4:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
  4723b8:	e0bffc17 	ldw	r2,-16(fp)
  4723bc:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
  4723c0:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
  4723c4:	10800217 	ldw	r2,8(r2)
  4723c8:	1809883a 	mov	r4,r3
  4723cc:	e17ffe17 	ldw	r5,-8(fp)
  4723d0:	e1bfff17 	ldw	r6,-4(fp)
  4723d4:	100f883a 	mov	r7,r2
  4723d8:	0472dd40 	call	472dd4 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
  4723dc:	e037883a 	mov	sp,fp
  4723e0:	dfc00117 	ldw	ra,4(sp)
  4723e4:	df000017 	ldw	fp,0(sp)
  4723e8:	dec00204 	addi	sp,sp,8
  4723ec:	f800283a 	ret

004723f0 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
  4723f0:	defffc04 	addi	sp,sp,-16
  4723f4:	dfc00315 	stw	ra,12(sp)
  4723f8:	df000215 	stw	fp,8(sp)
  4723fc:	df000204 	addi	fp,sp,8
  472400:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  472404:	e0bfff17 	ldw	r2,-4(fp)
  472408:	10800017 	ldw	r2,0(r2)
  47240c:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
  472410:	e0bffe17 	ldw	r2,-8(fp)
  472414:	10c00a04 	addi	r3,r2,40
  472418:	e0bfff17 	ldw	r2,-4(fp)
  47241c:	10800217 	ldw	r2,8(r2)
  472420:	1809883a 	mov	r4,r3
  472424:	100b883a 	mov	r5,r2
  472428:	04729880 	call	472988 <altera_avalon_jtag_uart_close>
}
  47242c:	e037883a 	mov	sp,fp
  472430:	dfc00117 	ldw	ra,4(sp)
  472434:	df000017 	ldw	fp,0(sp)
  472438:	dec00204 	addi	sp,sp,8
  47243c:	f800283a 	ret

00472440 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
  472440:	defffa04 	addi	sp,sp,-24
  472444:	dfc00515 	stw	ra,20(sp)
  472448:	df000415 	stw	fp,16(sp)
  47244c:	df000404 	addi	fp,sp,16
  472450:	e13ffd15 	stw	r4,-12(fp)
  472454:	e17ffe15 	stw	r5,-8(fp)
  472458:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
  47245c:	e0bffd17 	ldw	r2,-12(fp)
  472460:	10800017 	ldw	r2,0(r2)
  472464:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
  472468:	e0bffc17 	ldw	r2,-16(fp)
  47246c:	10800a04 	addi	r2,r2,40
  472470:	1009883a 	mov	r4,r2
  472474:	e17ffe17 	ldw	r5,-8(fp)
  472478:	e1bfff17 	ldw	r6,-4(fp)
  47247c:	04729f00 	call	4729f0 <altera_avalon_jtag_uart_ioctl>
}
  472480:	e037883a 	mov	sp,fp
  472484:	dfc00117 	ldw	ra,4(sp)
  472488:	df000017 	ldw	fp,0(sp)
  47248c:	dec00204 	addi	sp,sp,8
  472490:	f800283a 	ret

00472494 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
  472494:	defff404 	addi	sp,sp,-48
  472498:	dfc00b15 	stw	ra,44(sp)
  47249c:	df000a15 	stw	fp,40(sp)
  4724a0:	df000a04 	addi	fp,sp,40
  4724a4:	e13ffd15 	stw	r4,-12(fp)
  4724a8:	e17ffe15 	stw	r5,-8(fp)
  4724ac:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  4724b0:	e0bffd17 	ldw	r2,-12(fp)
  4724b4:	10800c04 	addi	r2,r2,48
  4724b8:	e0bff715 	stw	r2,-36(fp)
  4724bc:	e03ff80d 	sth	zero,-32(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
  4724c0:	e0fff80b 	ldhu	r3,-32(fp)
  4724c4:	e0bffc84 	addi	r2,fp,-14
  4724c8:	1809883a 	mov	r4,r3
  4724cc:	100b883a 	mov	r5,r2
  4724d0:	046b1e00 	call	46b1e0 <OSFlagCreate>
  4724d4:	e0fff717 	ldw	r3,-36(fp)
  4724d8:	18800015 	stw	r2,0(r3)
  ALT_SEM_CREATE(&sp->read_lock, 1);
  4724dc:	e0bffd17 	ldw	r2,-12(fp)
  4724e0:	10800a04 	addi	r2,r2,40
  4724e4:	e0bff915 	stw	r2,-28(fp)
  4724e8:	00800044 	movi	r2,1
  4724ec:	e0bffa0d 	sth	r2,-24(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
  4724f0:	e0bffa0b 	ldhu	r2,-24(fp)
  4724f4:	1009883a 	mov	r4,r2
  4724f8:	046ec440 	call	46ec44 <OSSemCreate>
  4724fc:	e0fff917 	ldw	r3,-28(fp)
  472500:	18800015 	stw	r2,0(r3)
  ALT_SEM_CREATE(&sp->write_lock, 1);
  472504:	e0bffd17 	ldw	r2,-12(fp)
  472508:	10800b04 	addi	r2,r2,44
  47250c:	e0bffb15 	stw	r2,-20(fp)
  472510:	00800044 	movi	r2,1
  472514:	e0bffc0d 	sth	r2,-16(fp)
  472518:	e0bffc0b 	ldhu	r2,-16(fp)
  47251c:	1009883a 	mov	r4,r2
  472520:	046ec440 	call	46ec44 <OSSemCreate>
  472524:	e0fffb17 	ldw	r3,-20(fp)
  472528:	18800015 	stw	r2,0(r3)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  47252c:	e0bffd17 	ldw	r2,-12(fp)
  472530:	00c00044 	movi	r3,1
  472534:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
  472538:	e0bffd17 	ldw	r2,-12(fp)
  47253c:	10800017 	ldw	r2,0(r2)
  472540:	10800104 	addi	r2,r2,4
  472544:	e0fffd17 	ldw	r3,-12(fp)
  472548:	18c00817 	ldw	r3,32(r3)
  47254c:	10c00035 	stwio	r3,0(r2)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
  472550:	e0fffe17 	ldw	r3,-8(fp)
  472554:	e0bfff17 	ldw	r2,-4(fp)
  472558:	d8000015 	stw	zero,0(sp)
  47255c:	1809883a 	mov	r4,r3
  472560:	100b883a 	mov	r5,r2
  472564:	018011f4 	movhi	r6,71
  472568:	31897404 	addi	r6,r6,9680
  47256c:	e1fffd17 	ldw	r7,-12(fp)
  472570:	04678600 	call	467860 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
  472574:	e0bffd17 	ldw	r2,-12(fp)
  472578:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
  47257c:	e0bffd17 	ldw	r2,-12(fp)
  472580:	10c00204 	addi	r3,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
  472584:	00801234 	movhi	r2,72
  472588:	10a65404 	addi	r2,r2,-26288
  47258c:	10800017 	ldw	r2,0(r2)
  472590:	1809883a 	mov	r4,r3
  472594:	100b883a 	mov	r5,r2
  472598:	018011f4 	movhi	r6,71
  47259c:	318a1f04 	addi	r6,r6,10364
  4725a0:	e1fffd17 	ldw	r7,-12(fp)
  4725a4:	04737bc0 	call	4737bc <alt_alarm_start>
  4725a8:	1000040e 	bge	r2,zero,4725bc <altera_avalon_jtag_uart_init+0x128>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
  4725ac:	e0bffd17 	ldw	r2,-12(fp)
  4725b0:	00e00034 	movhi	r3,32768
  4725b4:	18ffffc4 	addi	r3,r3,-1
  4725b8:	10c00115 	stw	r3,4(r2)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
  4725bc:	e037883a 	mov	sp,fp
  4725c0:	dfc00117 	ldw	ra,4(sp)
  4725c4:	df000017 	ldw	fp,0(sp)
  4725c8:	dec00204 	addi	sp,sp,8
  4725cc:	f800283a 	ret

004725d0 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
  4725d0:	defff204 	addi	sp,sp,-56
  4725d4:	dfc00d15 	stw	ra,52(sp)
  4725d8:	df000c15 	stw	fp,48(sp)
  4725dc:	df000c04 	addi	fp,sp,48
  4725e0:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
  4725e4:	e0bfff17 	ldw	r2,-4(fp)
  4725e8:	e0bff615 	stw	r2,-40(fp)
  unsigned int base = sp->base;
  4725ec:	e0bff617 	ldw	r2,-40(fp)
  4725f0:	10800017 	ldw	r2,0(r2)
  4725f4:	e0bff715 	stw	r2,-36(fp)
  4725f8:	00000106 	br	472600 <altera_avalon_jtag_uart_irq+0x30>
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
  4725fc:	0001883a 	nop
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  472600:	e0bff717 	ldw	r2,-36(fp)
  472604:	10800104 	addi	r2,r2,4
  472608:	10800037 	ldwio	r2,0(r2)
  47260c:	e0bff815 	stw	r2,-32(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
  472610:	e0bff817 	ldw	r2,-32(fp)
  472614:	1080c00c 	andi	r2,r2,768
  472618:	10009226 	beq	r2,zero,472864 <altera_avalon_jtag_uart_irq+0x294>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
  47261c:	e0bff817 	ldw	r2,-32(fp)
  472620:	1080400c 	andi	r2,r2,256
  472624:	10004826 	beq	r2,zero,472748 <altera_avalon_jtag_uart_irq+0x178>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
  472628:	00800074 	movhi	r2,1
  47262c:	e0bff415 	stw	r2,-48(fp)
  472630:	00000106 	br	472638 <altera_avalon_jtag_uart_irq+0x68>
        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
  472634:	0001883a 	nop
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  472638:	e0bff617 	ldw	r2,-40(fp)
  47263c:	10800d17 	ldw	r2,52(r2)
  472640:	10800044 	addi	r2,r2,1
  472644:	1081ffcc 	andi	r2,r2,2047
  472648:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
  47264c:	e0bff617 	ldw	r2,-40(fp)
  472650:	10c00e17 	ldw	r3,56(r2)
  472654:	e0bff917 	ldw	r2,-28(fp)
  472658:	18802726 	beq	r3,r2,4726f8 <altera_avalon_jtag_uart_irq+0x128>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
  47265c:	e0bff717 	ldw	r2,-36(fp)
  472660:	10800037 	ldwio	r2,0(r2)
  472664:	e0bff415 	stw	r2,-48(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
  472668:	e0bff417 	ldw	r2,-48(fp)
  47266c:	10a0000c 	andi	r2,r2,32768
  472670:	10002326 	beq	r2,zero,472700 <altera_avalon_jtag_uart_irq+0x130>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
  472674:	e0bff617 	ldw	r2,-40(fp)
  472678:	10800d17 	ldw	r2,52(r2)
  47267c:	e0fff417 	ldw	r3,-48(fp)
  472680:	e13ff617 	ldw	r4,-40(fp)
  472684:	2085883a 	add	r2,r4,r2
  472688:	10801104 	addi	r2,r2,68
  47268c:	10c00005 	stb	r3,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  472690:	e0bff617 	ldw	r2,-40(fp)
  472694:	10800d17 	ldw	r2,52(r2)
  472698:	10800044 	addi	r2,r2,1
  47269c:	10c1ffcc 	andi	r3,r2,2047
  4726a0:	e0bff617 	ldw	r2,-40(fp)
  4726a4:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
  4726a8:	e0bff617 	ldw	r2,-40(fp)
  4726ac:	10800c17 	ldw	r2,48(r2)
  4726b0:	e0bffa15 	stw	r2,-24(fp)
  4726b4:	00800044 	movi	r2,1
  4726b8:	e0bffb0d 	sth	r2,-20(fp)
  4726bc:	00800044 	movi	r2,1
  4726c0:	e0bffb85 	stb	r2,-18(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
  4726c4:	00801234 	movhi	r2,72
  4726c8:	10a63e44 	addi	r2,r2,-26375
  4726cc:	10800003 	ldbu	r2,0(r2)
  4726d0:	10803fcc 	andi	r2,r2,255
  4726d4:	103fd726 	beq	r2,zero,472634 <altera_avalon_jtag_uart_irq+0x64>
  {
    OSFlagPost (group, flags, opt, &err);
  4726d8:	e17ffb0b 	ldhu	r5,-20(fp)
  4726dc:	e0fffb83 	ldbu	r3,-18(fp)
  4726e0:	e0bffdc4 	addi	r2,fp,-9
  4726e4:	e13ffa17 	ldw	r4,-24(fp)
  4726e8:	180d883a 	mov	r6,r3
  4726ec:	100f883a 	mov	r7,r2
  4726f0:	046c2840 	call	46c284 <OSFlagPost>
      }
  4726f4:	003fcf06 	br	472634 <altera_avalon_jtag_uart_irq+0x64>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
  4726f8:	0001883a 	nop
  4726fc:	00000106 	br	472704 <altera_avalon_jtag_uart_irq+0x134>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
  472700:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
  472704:	e0bff417 	ldw	r2,-48(fp)
  472708:	10bfffec 	andhi	r2,r2,65535
  47270c:	10000e26 	beq	r2,zero,472748 <altera_avalon_jtag_uart_irq+0x178>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  472710:	e0bff617 	ldw	r2,-40(fp)
  472714:	10c00817 	ldw	r3,32(r2)
  472718:	00bfff84 	movi	r2,-2
  47271c:	1886703a 	and	r3,r3,r2
  472720:	e0bff617 	ldw	r2,-40(fp)
  472724:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
  472728:	e0bff717 	ldw	r2,-36(fp)
  47272c:	10800104 	addi	r2,r2,4
  472730:	e0fff617 	ldw	r3,-40(fp)
  472734:	18c00817 	ldw	r3,32(r3)
  472738:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  47273c:	e0bff717 	ldw	r2,-36(fp)
  472740:	10800104 	addi	r2,r2,4
  472744:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
  472748:	e0bff817 	ldw	r2,-32(fp)
  47274c:	1080800c 	andi	r2,r2,512
  472750:	103faa26 	beq	r2,zero,4725fc <altera_avalon_jtag_uart_irq+0x2c>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
  472754:	e0bff817 	ldw	r2,-32(fp)
  472758:	1004d43a 	srli	r2,r2,16
  47275c:	e0bff515 	stw	r2,-44(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
  472760:	00002706 	br	472800 <altera_avalon_jtag_uart_irq+0x230>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
  472764:	e0bff717 	ldw	r2,-36(fp)
  472768:	e0fff617 	ldw	r3,-40(fp)
  47276c:	18c01017 	ldw	r3,64(r3)
  472770:	e13ff617 	ldw	r4,-40(fp)
  472774:	20c7883a 	add	r3,r4,r3
  472778:	18c21104 	addi	r3,r3,2116
  47277c:	18c00003 	ldbu	r3,0(r3)
  472780:	18c03fcc 	andi	r3,r3,255
  472784:	18c0201c 	xori	r3,r3,128
  472788:	18ffe004 	addi	r3,r3,-128
  47278c:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  472790:	e0bff617 	ldw	r2,-40(fp)
  472794:	10801017 	ldw	r2,64(r2)
  472798:	10800044 	addi	r2,r2,1
  47279c:	10c1ffcc 	andi	r3,r2,2047
  4727a0:	e0bff617 	ldw	r2,-40(fp)
  4727a4:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
  4727a8:	e0bff617 	ldw	r2,-40(fp)
  4727ac:	10800c17 	ldw	r2,48(r2)
  4727b0:	e0bffc15 	stw	r2,-16(fp)
  4727b4:	00800084 	movi	r2,2
  4727b8:	e0bffd0d 	sth	r2,-12(fp)
  4727bc:	00800044 	movi	r2,1
  4727c0:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
  4727c4:	00801234 	movhi	r2,72
  4727c8:	10a63e44 	addi	r2,r2,-26375
  4727cc:	10800003 	ldbu	r2,0(r2)
  4727d0:	10803fcc 	andi	r2,r2,255
  4727d4:	10000726 	beq	r2,zero,4727f4 <altera_avalon_jtag_uart_irq+0x224>
  {
    OSFlagPost (group, flags, opt, &err);
  4727d8:	e17ffd0b 	ldhu	r5,-12(fp)
  4727dc:	e0fffd83 	ldbu	r3,-10(fp)
  4727e0:	e0bffe04 	addi	r2,fp,-8
  4727e4:	e13ffc17 	ldw	r4,-16(fp)
  4727e8:	180d883a 	mov	r6,r3
  4727ec:	100f883a 	mov	r7,r2
  4727f0:	046c2840 	call	46c284 <OSFlagPost>

        space--;
  4727f4:	e0bff517 	ldw	r2,-44(fp)
  4727f8:	10bfffc4 	addi	r2,r2,-1
  4727fc:	e0bff515 	stw	r2,-44(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
  472800:	e0bff517 	ldw	r2,-44(fp)
  472804:	10000526 	beq	r2,zero,47281c <altera_avalon_jtag_uart_irq+0x24c>
  472808:	e0bff617 	ldw	r2,-40(fp)
  47280c:	10c01017 	ldw	r3,64(r2)
  472810:	e0bff617 	ldw	r2,-40(fp)
  472814:	10800f17 	ldw	r2,60(r2)
  472818:	18bfd21e 	bne	r3,r2,472764 <altera_avalon_jtag_uart_irq+0x194>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
  47281c:	e0bff517 	ldw	r2,-44(fp)
  472820:	103f7626 	beq	r2,zero,4725fc <altera_avalon_jtag_uart_irq+0x2c>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
  472824:	e0bff617 	ldw	r2,-40(fp)
  472828:	10c00817 	ldw	r3,32(r2)
  47282c:	00bfff44 	movi	r2,-3
  472830:	1886703a 	and	r3,r3,r2
  472834:	e0bff617 	ldw	r2,-40(fp)
  472838:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  47283c:	e0bff617 	ldw	r2,-40(fp)
  472840:	10800017 	ldw	r2,0(r2)
  472844:	10800104 	addi	r2,r2,4
  472848:	e0fff617 	ldw	r3,-40(fp)
  47284c:	18c00817 	ldw	r3,32(r3)
  472850:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  472854:	e0bff717 	ldw	r2,-36(fp)
  472858:	10800104 	addi	r2,r2,4
  47285c:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
  472860:	003f6606 	br	4725fc <altera_avalon_jtag_uart_irq+0x2c>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
  472864:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
  472868:	e037883a 	mov	sp,fp
  47286c:	dfc00117 	ldw	ra,4(sp)
  472870:	df000017 	ldw	fp,0(sp)
  472874:	dec00204 	addi	sp,sp,8
  472878:	f800283a 	ret

0047287c <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
  47287c:	defff904 	addi	sp,sp,-28
  472880:	dfc00615 	stw	ra,24(sp)
  472884:	df000515 	stw	fp,20(sp)
  472888:	df000504 	addi	fp,sp,20
  47288c:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
  472890:	e0bfff17 	ldw	r2,-4(fp)
  472894:	e0bffb15 	stw	r2,-20(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
  472898:	e0bffb17 	ldw	r2,-20(fp)
  47289c:	10800017 	ldw	r2,0(r2)
  4728a0:	10800104 	addi	r2,r2,4
  4728a4:	10800037 	ldwio	r2,0(r2)
  4728a8:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
  4728ac:	e0bffc17 	ldw	r2,-16(fp)
  4728b0:	1081000c 	andi	r2,r2,1024
  4728b4:	10000a26 	beq	r2,zero,4728e0 <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
  4728b8:	e0bffb17 	ldw	r2,-20(fp)
  4728bc:	10800017 	ldw	r2,0(r2)
  4728c0:	10800104 	addi	r2,r2,4
  4728c4:	e0fffb17 	ldw	r3,-20(fp)
  4728c8:	18c00817 	ldw	r3,32(r3)
  4728cc:	18c10014 	ori	r3,r3,1024
  4728d0:	10c00035 	stwio	r3,0(r2)
    sp->host_inactive = 0;
  4728d4:	e0bffb17 	ldw	r2,-20(fp)
  4728d8:	10000915 	stw	zero,36(r2)
  4728dc:	00002206 	br	472968 <altera_avalon_jtag_uart_timeout+0xec>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
  4728e0:	e0bffb17 	ldw	r2,-20(fp)
  4728e4:	10800917 	ldw	r2,36(r2)
  4728e8:	00e00034 	movhi	r3,32768
  4728ec:	18ffff04 	addi	r3,r3,-4
  4728f0:	18801d36 	bltu	r3,r2,472968 <altera_avalon_jtag_uart_timeout+0xec>
    sp->host_inactive++;
  4728f4:	e0bffb17 	ldw	r2,-20(fp)
  4728f8:	10800917 	ldw	r2,36(r2)
  4728fc:	10c00044 	addi	r3,r2,1
  472900:	e0bffb17 	ldw	r2,-20(fp)
  472904:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
  472908:	e0bffb17 	ldw	r2,-20(fp)
  47290c:	10c00917 	ldw	r3,36(r2)
  472910:	e0bffb17 	ldw	r2,-20(fp)
  472914:	10800117 	ldw	r2,4(r2)
  472918:	18801336 	bltu	r3,r2,472968 <altera_avalon_jtag_uart_timeout+0xec>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
  47291c:	e0bffb17 	ldw	r2,-20(fp)
  472920:	10800c17 	ldw	r2,48(r2)
  472924:	e0bffd15 	stw	r2,-12(fp)
  472928:	00800104 	movi	r2,4
  47292c:	e0bffe0d 	sth	r2,-8(fp)
  472930:	00800044 	movi	r2,1
  472934:	e0bffe85 	stb	r2,-6(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
  472938:	00801234 	movhi	r2,72
  47293c:	10a63e44 	addi	r2,r2,-26375
  472940:	10800003 	ldbu	r2,0(r2)
  472944:	10803fcc 	andi	r2,r2,255
  472948:	10000726 	beq	r2,zero,472968 <altera_avalon_jtag_uart_timeout+0xec>
  {
    OSFlagPost (group, flags, opt, &err);
  47294c:	e17ffe0b 	ldhu	r5,-8(fp)
  472950:	e0fffe83 	ldbu	r3,-6(fp)
  472954:	e0bffec4 	addi	r2,fp,-5
  472958:	e13ffd17 	ldw	r4,-12(fp)
  47295c:	180d883a 	mov	r6,r3
  472960:	100f883a 	mov	r7,r2
  472964:	046c2840 	call	46c284 <OSFlagPost>
  472968:	00801234 	movhi	r2,72
  47296c:	10a65404 	addi	r2,r2,-26288
  472970:	10800017 	ldw	r2,0(r2)
    }
  }

  return alt_ticks_per_second();
}
  472974:	e037883a 	mov	sp,fp
  472978:	dfc00117 	ldw	ra,4(sp)
  47297c:	df000017 	ldw	fp,0(sp)
  472980:	dec00204 	addi	sp,sp,8
  472984:	f800283a 	ret

00472988 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
  472988:	defffd04 	addi	sp,sp,-12
  47298c:	df000215 	stw	fp,8(sp)
  472990:	df000204 	addi	fp,sp,8
  472994:	e13ffe15 	stw	r4,-8(fp)
  472998:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
  47299c:	00000506 	br	4729b4 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
  4729a0:	e0bfff17 	ldw	r2,-4(fp)
  4729a4:	1090000c 	andi	r2,r2,16384
  4729a8:	10000226 	beq	r2,zero,4729b4 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
  4729ac:	00bffd44 	movi	r2,-11
  4729b0:	00000b06 	br	4729e0 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
  4729b4:	e0bffe17 	ldw	r2,-8(fp)
  4729b8:	10c01017 	ldw	r3,64(r2)
  4729bc:	e0bffe17 	ldw	r2,-8(fp)
  4729c0:	10800f17 	ldw	r2,60(r2)
  4729c4:	18800526 	beq	r3,r2,4729dc <altera_avalon_jtag_uart_close+0x54>
  4729c8:	e0bffe17 	ldw	r2,-8(fp)
  4729cc:	10c00917 	ldw	r3,36(r2)
  4729d0:	e0bffe17 	ldw	r2,-8(fp)
  4729d4:	10800117 	ldw	r2,4(r2)
  4729d8:	18bff136 	bltu	r3,r2,4729a0 <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
  4729dc:	0005883a 	mov	r2,zero
}
  4729e0:	e037883a 	mov	sp,fp
  4729e4:	df000017 	ldw	fp,0(sp)
  4729e8:	dec00104 	addi	sp,sp,4
  4729ec:	f800283a 	ret

004729f0 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
  4729f0:	defffa04 	addi	sp,sp,-24
  4729f4:	df000515 	stw	fp,20(sp)
  4729f8:	df000504 	addi	fp,sp,20
  4729fc:	e13ffd15 	stw	r4,-12(fp)
  472a00:	e17ffe15 	stw	r5,-8(fp)
  472a04:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
  472a08:	00bff9c4 	movi	r2,-25
  472a0c:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
  472a10:	e0bffe17 	ldw	r2,-8(fp)
  472a14:	10da8060 	cmpeqi	r3,r2,27137
  472a18:	1800031e 	bne	r3,zero,472a28 <altera_avalon_jtag_uart_ioctl+0x38>
  472a1c:	109a80a0 	cmpeqi	r2,r2,27138
  472a20:	1000181e 	bne	r2,zero,472a84 <altera_avalon_jtag_uart_ioctl+0x94>
  472a24:	00002606 	br	472ac0 <altera_avalon_jtag_uart_ioctl+0xd0>
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
  472a28:	e0bffd17 	ldw	r2,-12(fp)
  472a2c:	10c00117 	ldw	r3,4(r2)
  472a30:	00a00034 	movhi	r2,32768
  472a34:	10bfffc4 	addi	r2,r2,-1
  472a38:	18802226 	beq	r3,r2,472ac4 <altera_avalon_jtag_uart_ioctl+0xd4>
    {
      int timeout = *((int *)arg);
  472a3c:	e0bfff17 	ldw	r2,-4(fp)
  472a40:	10800017 	ldw	r2,0(r2)
  472a44:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
  472a48:	e0bffc17 	ldw	r2,-16(fp)
  472a4c:	10800090 	cmplti	r2,r2,2
  472a50:	1000061e 	bne	r2,zero,472a6c <altera_avalon_jtag_uart_ioctl+0x7c>
  472a54:	e0fffc17 	ldw	r3,-16(fp)
  472a58:	00a00034 	movhi	r2,32768
  472a5c:	10bfffc4 	addi	r2,r2,-1
  472a60:	18800226 	beq	r3,r2,472a6c <altera_avalon_jtag_uart_ioctl+0x7c>
  472a64:	e0bffc17 	ldw	r2,-16(fp)
  472a68:	00000206 	br	472a74 <altera_avalon_jtag_uart_ioctl+0x84>
  472a6c:	00a00034 	movhi	r2,32768
  472a70:	10bfff84 	addi	r2,r2,-2
  472a74:	e0fffd17 	ldw	r3,-12(fp)
  472a78:	18800115 	stw	r2,4(r3)
      rc = 0;
  472a7c:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
  472a80:	00001006 	br	472ac4 <altera_avalon_jtag_uart_ioctl+0xd4>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
  472a84:	e0bffd17 	ldw	r2,-12(fp)
  472a88:	10c00117 	ldw	r3,4(r2)
  472a8c:	00a00034 	movhi	r2,32768
  472a90:	10bfffc4 	addi	r2,r2,-1
  472a94:	18800d26 	beq	r3,r2,472acc <altera_avalon_jtag_uart_ioctl+0xdc>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
  472a98:	e0bffd17 	ldw	r2,-12(fp)
  472a9c:	10c00917 	ldw	r3,36(r2)
  472aa0:	e0bffd17 	ldw	r2,-12(fp)
  472aa4:	10800117 	ldw	r2,4(r2)
  472aa8:	1885803a 	cmpltu	r2,r3,r2
  472aac:	10c03fcc 	andi	r3,r2,255
  472ab0:	e0bfff17 	ldw	r2,-4(fp)
  472ab4:	10c00015 	stw	r3,0(r2)
      rc = 0;
  472ab8:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
  472abc:	00000306 	br	472acc <altera_avalon_jtag_uart_ioctl+0xdc>

  default:
    break;
  472ac0:	00000306 	br	472ad0 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
  472ac4:	0001883a 	nop
  472ac8:	00000106 	br	472ad0 <altera_avalon_jtag_uart_ioctl+0xe0>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
  472acc:	0001883a 	nop

  default:
    break;
  }

  return rc;
  472ad0:	e0bffb17 	ldw	r2,-20(fp)
}
  472ad4:	e037883a 	mov	sp,fp
  472ad8:	df000017 	ldw	fp,0(sp)
  472adc:	dec00104 	addi	sp,sp,4
  472ae0:	f800283a 	ret

00472ae4 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
  472ae4:	deffeb04 	addi	sp,sp,-84
  472ae8:	dfc01415 	stw	ra,80(sp)
  472aec:	df001315 	stw	fp,76(sp)
  472af0:	df001304 	addi	fp,sp,76
  472af4:	e13ffc15 	stw	r4,-16(fp)
  472af8:	e17ffd15 	stw	r5,-12(fp)
  472afc:	e1bffe15 	stw	r6,-8(fp)
  472b00:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
  472b04:	e0bffd17 	ldw	r2,-12(fp)
  472b08:	e0bfee15 	stw	r2,-72(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
  472b0c:	e0bffc17 	ldw	r2,-16(fp)
  472b10:	10800a17 	ldw	r2,40(r2)
  472b14:	e0bff315 	stw	r2,-52(fp)
  472b18:	e03ff40d 	sth	zero,-48(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
  472b1c:	e0fff40b 	ldhu	r3,-48(fp)
  472b20:	e0bffb04 	addi	r2,fp,-20
  472b24:	e13ff317 	ldw	r4,-52(fp)
  472b28:	180b883a 	mov	r5,r3
  472b2c:	100d883a 	mov	r6,r2
  472b30:	046f0900 	call	46f090 <OSSemPend>

  while (space > 0)
  472b34:	00006406 	br	472cc8 <altera_avalon_jtag_uart_read+0x1e4>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
  472b38:	e0bffc17 	ldw	r2,-16(fp)
  472b3c:	10800d17 	ldw	r2,52(r2)
  472b40:	e0bff015 	stw	r2,-64(fp)
      out = sp->rx_out;
  472b44:	e0bffc17 	ldw	r2,-16(fp)
  472b48:	10800e17 	ldw	r2,56(r2)
  472b4c:	e0bff115 	stw	r2,-60(fp)

      if (in >= out)
  472b50:	e0fff017 	ldw	r3,-64(fp)
  472b54:	e0bff117 	ldw	r2,-60(fp)
  472b58:	18800536 	bltu	r3,r2,472b70 <altera_avalon_jtag_uart_read+0x8c>
        n = in - out;
  472b5c:	e0fff017 	ldw	r3,-64(fp)
  472b60:	e0bff117 	ldw	r2,-60(fp)
  472b64:	1885c83a 	sub	r2,r3,r2
  472b68:	e0bfef15 	stw	r2,-68(fp)
  472b6c:	00000406 	br	472b80 <altera_avalon_jtag_uart_read+0x9c>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
  472b70:	00c20004 	movi	r3,2048
  472b74:	e0bff117 	ldw	r2,-60(fp)
  472b78:	1885c83a 	sub	r2,r3,r2
  472b7c:	e0bfef15 	stw	r2,-68(fp)

      if (n == 0)
  472b80:	e0bfef17 	ldw	r2,-68(fp)
  472b84:	10001e26 	beq	r2,zero,472c00 <altera_avalon_jtag_uart_read+0x11c>
        break; /* No more data available */

      if (n > space)
  472b88:	e0fffe17 	ldw	r3,-8(fp)
  472b8c:	e0bfef17 	ldw	r2,-68(fp)
  472b90:	1880022e 	bgeu	r3,r2,472b9c <altera_avalon_jtag_uart_read+0xb8>
        n = space;
  472b94:	e0bffe17 	ldw	r2,-8(fp)
  472b98:	e0bfef15 	stw	r2,-68(fp)

      memcpy(ptr, sp->rx_buf + out, n);
  472b9c:	e0bff117 	ldw	r2,-60(fp)
  472ba0:	10801104 	addi	r2,r2,68
  472ba4:	e0fffc17 	ldw	r3,-16(fp)
  472ba8:	1885883a 	add	r2,r3,r2
  472bac:	e13fee17 	ldw	r4,-72(fp)
  472bb0:	100b883a 	mov	r5,r2
  472bb4:	e1bfef17 	ldw	r6,-68(fp)
  472bb8:	04659580 	call	465958 <memcpy>
      ptr   += n;
  472bbc:	e0ffee17 	ldw	r3,-72(fp)
  472bc0:	e0bfef17 	ldw	r2,-68(fp)
  472bc4:	1885883a 	add	r2,r3,r2
  472bc8:	e0bfee15 	stw	r2,-72(fp)
      space -= n;
  472bcc:	e0fffe17 	ldw	r3,-8(fp)
  472bd0:	e0bfef17 	ldw	r2,-68(fp)
  472bd4:	1885c83a 	sub	r2,r3,r2
  472bd8:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  472bdc:	e0fff117 	ldw	r3,-60(fp)
  472be0:	e0bfef17 	ldw	r2,-68(fp)
  472be4:	1885883a 	add	r2,r3,r2
  472be8:	10c1ffcc 	andi	r3,r2,2047
  472bec:	e0bffc17 	ldw	r2,-16(fp)
  472bf0:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
  472bf4:	e0bffe17 	ldw	r2,-8(fp)
  472bf8:	00bfcf16 	blt	zero,r2,472b38 <altera_avalon_jtag_uart_read+0x54>
  472bfc:	00000106 	br	472c04 <altera_avalon_jtag_uart_read+0x120>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
  472c00:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
  472c04:	e0ffee17 	ldw	r3,-72(fp)
  472c08:	e0bffd17 	ldw	r2,-12(fp)
  472c0c:	1880311e 	bne	r3,r2,472cd4 <altera_avalon_jtag_uart_read+0x1f0>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
  472c10:	e0bfff17 	ldw	r2,-4(fp)
  472c14:	1090000c 	andi	r2,r2,16384
  472c18:	1000301e 	bne	r2,zero,472cdc <altera_avalon_jtag_uart_read+0x1f8>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
  472c1c:	00801234 	movhi	r2,72
  472c20:	10a63e44 	addi	r2,r2,-26375
  472c24:	10800003 	ldbu	r2,0(r2)
  472c28:	10803fcc 	andi	r2,r2,255
  472c2c:	10800058 	cmpnei	r2,r2,1
  472c30:	1000171e 	bne	r2,zero,472c90 <altera_avalon_jtag_uart_read+0x1ac>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
  472c34:	e0bffc17 	ldw	r2,-16(fp)
  472c38:	10800c17 	ldw	r2,48(r2)
  472c3c:	e0bff515 	stw	r2,-44(fp)
  472c40:	00800144 	movi	r2,5
  472c44:	e0bff60d 	sth	r2,-40(fp)
  472c48:	00bfe0c4 	movi	r2,-125
  472c4c:	e0bff685 	stb	r2,-38(fp)
  472c50:	e03ff70d 	sth	zero,-36(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
  472c54:	00801234 	movhi	r2,72
  472c58:	10a63e44 	addi	r2,r2,-26375
  472c5c:	10800003 	ldbu	r2,0(r2)
  472c60:	10803fcc 	andi	r2,r2,255
  472c64:	10001426 	beq	r2,zero,472cb8 <altera_avalon_jtag_uart_read+0x1d4>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
  472c68:	e17ff60b 	ldhu	r5,-40(fp)
  472c6c:	e0fff683 	ldbu	r3,-38(fp)
  472c70:	e0bff70b 	ldhu	r2,-36(fp)
  472c74:	e13ffb44 	addi	r4,fp,-19
  472c78:	d9000015 	stw	r4,0(sp)
  472c7c:	e13ff517 	ldw	r4,-44(fp)
  472c80:	180d883a 	mov	r6,r3
  472c84:	100f883a 	mov	r7,r2
  472c88:	046b9e00 	call	46b9e0 <OSFlagPend>
  472c8c:	00000a06 	br	472cb8 <altera_avalon_jtag_uart_read+0x1d4>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
  472c90:	0001883a 	nop
  472c94:	e0bffc17 	ldw	r2,-16(fp)
  472c98:	10c00d17 	ldw	r3,52(r2)
  472c9c:	e0bff017 	ldw	r2,-64(fp)
  472ca0:	1880051e 	bne	r3,r2,472cb8 <altera_avalon_jtag_uart_read+0x1d4>
  472ca4:	e0bffc17 	ldw	r2,-16(fp)
  472ca8:	10c00917 	ldw	r3,36(r2)
  472cac:	e0bffc17 	ldw	r2,-16(fp)
  472cb0:	10800117 	ldw	r2,4(r2)
  472cb4:	18bff736 	bltu	r3,r2,472c94 <altera_avalon_jtag_uart_read+0x1b0>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
  472cb8:	e0bffc17 	ldw	r2,-16(fp)
  472cbc:	10c00d17 	ldw	r3,52(r2)
  472cc0:	e0bff017 	ldw	r2,-64(fp)
  472cc4:	18800726 	beq	r3,r2,472ce4 <altera_avalon_jtag_uart_read+0x200>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
  472cc8:	e0bffe17 	ldw	r2,-8(fp)
  472ccc:	00bf9a16 	blt	zero,r2,472b38 <altera_avalon_jtag_uart_read+0x54>
  472cd0:	00000506 	br	472ce8 <altera_avalon_jtag_uart_read+0x204>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
  472cd4:	0001883a 	nop
  472cd8:	00000306 	br	472ce8 <altera_avalon_jtag_uart_read+0x204>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
  472cdc:	0001883a 	nop
  472ce0:	00000106 	br	472ce8 <altera_avalon_jtag_uart_read+0x204>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
  472ce4:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
  472ce8:	e0bffc17 	ldw	r2,-16(fp)
  472cec:	10800a17 	ldw	r2,40(r2)
  472cf0:	1009883a 	mov	r4,r2
  472cf4:	046f54c0 	call	46f54c <OSSemPost>

  if (ptr != buffer)
  472cf8:	e0ffee17 	ldw	r3,-72(fp)
  472cfc:	e0bffd17 	ldw	r2,-12(fp)
  472d00:	18802226 	beq	r3,r2,472d8c <altera_avalon_jtag_uart_read+0x2a8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  472d04:	0005303a 	rdctl	r2,status
  472d08:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  472d0c:	e0fff817 	ldw	r3,-32(fp)
  472d10:	00bfff84 	movi	r2,-2
  472d14:	1884703a 	and	r2,r3,r2
  472d18:	1001703a 	wrctl	status,r2
  
  return context;
  472d1c:	e0bff817 	ldw	r2,-32(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
  472d20:	e0bff215 	stw	r2,-56(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  472d24:	e0bffc17 	ldw	r2,-16(fp)
  472d28:	10800817 	ldw	r2,32(r2)
  472d2c:	10c00054 	ori	r3,r2,1
  472d30:	e0bffc17 	ldw	r2,-16(fp)
  472d34:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  472d38:	e0bffc17 	ldw	r2,-16(fp)
  472d3c:	10800017 	ldw	r2,0(r2)
  472d40:	10800104 	addi	r2,r2,4
  472d44:	e0fffc17 	ldw	r3,-16(fp)
  472d48:	18c00817 	ldw	r3,32(r3)
  472d4c:	10c00035 	stwio	r3,0(r2)
  472d50:	e0bff217 	ldw	r2,-56(fp)
  472d54:	e0bff915 	stw	r2,-28(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  472d58:	0005303a 	rdctl	r2,status
  472d5c:	e0bffa15 	stw	r2,-24(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  472d60:	e0fffa17 	ldw	r3,-24(fp)
  472d64:	00bfff84 	movi	r2,-2
  472d68:	1884703a 	and	r2,r3,r2
  472d6c:	e0bffa15 	stw	r2,-24(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  472d70:	e0bff917 	ldw	r2,-28(fp)
  472d74:	1080004c 	andi	r2,r2,1
  472d78:	e0fffa17 	ldw	r3,-24(fp)
  472d7c:	1884b03a 	or	r2,r3,r2
  472d80:	e0bffa15 	stw	r2,-24(fp)
  
  NIOS2_WRITE_STATUS (status);
  472d84:	e0bffa17 	ldw	r2,-24(fp)
  472d88:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
  472d8c:	e0ffee17 	ldw	r3,-72(fp)
  472d90:	e0bffd17 	ldw	r2,-12(fp)
  472d94:	18800426 	beq	r3,r2,472da8 <altera_avalon_jtag_uart_read+0x2c4>
    return ptr - buffer;
  472d98:	e0ffee17 	ldw	r3,-72(fp)
  472d9c:	e0bffd17 	ldw	r2,-12(fp)
  472da0:	1885c83a 	sub	r2,r3,r2
  472da4:	00000606 	br	472dc0 <altera_avalon_jtag_uart_read+0x2dc>
  else if (flags & O_NONBLOCK)
  472da8:	e0bfff17 	ldw	r2,-4(fp)
  472dac:	1090000c 	andi	r2,r2,16384
  472db0:	10000226 	beq	r2,zero,472dbc <altera_avalon_jtag_uart_read+0x2d8>
    return -EWOULDBLOCK;
  472db4:	00bffd44 	movi	r2,-11
  472db8:	00000106 	br	472dc0 <altera_avalon_jtag_uart_read+0x2dc>
  else
    return -EIO;
  472dbc:	00bffec4 	movi	r2,-5
}
  472dc0:	e037883a 	mov	sp,fp
  472dc4:	dfc00117 	ldw	ra,4(sp)
  472dc8:	df000017 	ldw	fp,0(sp)
  472dcc:	dec00204 	addi	sp,sp,8
  472dd0:	f800283a 	ret

00472dd4 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  472dd4:	deffec04 	addi	sp,sp,-80
  472dd8:	dfc01315 	stw	ra,76(sp)
  472ddc:	df001215 	stw	fp,72(sp)
  472de0:	df001204 	addi	fp,sp,72
  472de4:	e13ffc15 	stw	r4,-16(fp)
  472de8:	e17ffd15 	stw	r5,-12(fp)
  472dec:	e1bffe15 	stw	r6,-8(fp)
  472df0:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
  472df4:	e03fef15 	stw	zero,-68(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
  472df8:	e0bffd17 	ldw	r2,-12(fp)
  472dfc:	e0bff115 	stw	r2,-60(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
  472e00:	e0bffc17 	ldw	r2,-16(fp)
  472e04:	10800b17 	ldw	r2,44(r2)
  472e08:	e0bff415 	stw	r2,-48(fp)
  472e0c:	e03ff50d 	sth	zero,-44(fp)
  472e10:	e0fff50b 	ldhu	r3,-44(fp)
  472e14:	e0bffbc4 	addi	r2,fp,-17
  472e18:	e13ff417 	ldw	r4,-48(fp)
  472e1c:	180b883a 	mov	r5,r3
  472e20:	100d883a 	mov	r6,r2
  472e24:	046f0900 	call	46f090 <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
  472e28:	00003706 	br	472f08 <altera_avalon_jtag_uart_write+0x134>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
  472e2c:	e0bffc17 	ldw	r2,-16(fp)
  472e30:	10800f17 	ldw	r2,60(r2)
  472e34:	e0bff215 	stw	r2,-56(fp)
      out = sp->tx_out;
  472e38:	e0bffc17 	ldw	r2,-16(fp)
  472e3c:	10801017 	ldw	r2,64(r2)
  472e40:	e0bfef15 	stw	r2,-68(fp)

      if (in < out)
  472e44:	e0fff217 	ldw	r3,-56(fp)
  472e48:	e0bfef17 	ldw	r2,-68(fp)
  472e4c:	1880062e 	bgeu	r3,r2,472e68 <altera_avalon_jtag_uart_write+0x94>
        n = out - 1 - in;
  472e50:	e0ffef17 	ldw	r3,-68(fp)
  472e54:	e0bff217 	ldw	r2,-56(fp)
  472e58:	1885c83a 	sub	r2,r3,r2
  472e5c:	10bfffc4 	addi	r2,r2,-1
  472e60:	e0bff015 	stw	r2,-64(fp)
  472e64:	00000b06 	br	472e94 <altera_avalon_jtag_uart_write+0xc0>
      else if (out > 0)
  472e68:	e0bfef17 	ldw	r2,-68(fp)
  472e6c:	10000526 	beq	r2,zero,472e84 <altera_avalon_jtag_uart_write+0xb0>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
  472e70:	00c20004 	movi	r3,2048
  472e74:	e0bff217 	ldw	r2,-56(fp)
  472e78:	1885c83a 	sub	r2,r3,r2
  472e7c:	e0bff015 	stw	r2,-64(fp)
  472e80:	00000406 	br	472e94 <altera_avalon_jtag_uart_write+0xc0>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
  472e84:	00c1ffc4 	movi	r3,2047
  472e88:	e0bff217 	ldw	r2,-56(fp)
  472e8c:	1885c83a 	sub	r2,r3,r2
  472e90:	e0bff015 	stw	r2,-64(fp)

      if (n == 0)
  472e94:	e0bff017 	ldw	r2,-64(fp)
  472e98:	10001e26 	beq	r2,zero,472f14 <altera_avalon_jtag_uart_write+0x140>
        break;

      if (n > count)
  472e9c:	e0fffe17 	ldw	r3,-8(fp)
  472ea0:	e0bff017 	ldw	r2,-64(fp)
  472ea4:	1880022e 	bgeu	r3,r2,472eb0 <altera_avalon_jtag_uart_write+0xdc>
        n = count;
  472ea8:	e0bffe17 	ldw	r2,-8(fp)
  472eac:	e0bff015 	stw	r2,-64(fp)

      memcpy(sp->tx_buf + in, ptr, n);
  472eb0:	e0bff217 	ldw	r2,-56(fp)
  472eb4:	10821104 	addi	r2,r2,2116
  472eb8:	e0fffc17 	ldw	r3,-16(fp)
  472ebc:	1885883a 	add	r2,r3,r2
  472ec0:	1009883a 	mov	r4,r2
  472ec4:	e17ffd17 	ldw	r5,-12(fp)
  472ec8:	e1bff017 	ldw	r6,-64(fp)
  472ecc:	04659580 	call	465958 <memcpy>
      ptr   += n;
  472ed0:	e0fffd17 	ldw	r3,-12(fp)
  472ed4:	e0bff017 	ldw	r2,-64(fp)
  472ed8:	1885883a 	add	r2,r3,r2
  472edc:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
  472ee0:	e0fffe17 	ldw	r3,-8(fp)
  472ee4:	e0bff017 	ldw	r2,-64(fp)
  472ee8:	1885c83a 	sub	r2,r3,r2
  472eec:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  472ef0:	e0fff217 	ldw	r3,-56(fp)
  472ef4:	e0bff017 	ldw	r2,-64(fp)
  472ef8:	1885883a 	add	r2,r3,r2
  472efc:	10c1ffcc 	andi	r3,r2,2047
  472f00:	e0bffc17 	ldw	r2,-16(fp)
  472f04:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
  472f08:	e0bffe17 	ldw	r2,-8(fp)
  472f0c:	00bfc716 	blt	zero,r2,472e2c <altera_avalon_jtag_uart_write+0x58>
  472f10:	00000106 	br	472f18 <altera_avalon_jtag_uart_write+0x144>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
  472f14:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  472f18:	0005303a 	rdctl	r2,status
  472f1c:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  472f20:	e0fff617 	ldw	r3,-40(fp)
  472f24:	00bfff84 	movi	r2,-2
  472f28:	1884703a 	and	r2,r3,r2
  472f2c:	1001703a 	wrctl	status,r2
  
  return context;
  472f30:	e0bff617 	ldw	r2,-40(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
  472f34:	e0bff315 	stw	r2,-52(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
  472f38:	e0bffc17 	ldw	r2,-16(fp)
  472f3c:	10800817 	ldw	r2,32(r2)
  472f40:	10c00094 	ori	r3,r2,2
  472f44:	e0bffc17 	ldw	r2,-16(fp)
  472f48:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  472f4c:	e0bffc17 	ldw	r2,-16(fp)
  472f50:	10800017 	ldw	r2,0(r2)
  472f54:	10800104 	addi	r2,r2,4
  472f58:	e0fffc17 	ldw	r3,-16(fp)
  472f5c:	18c00817 	ldw	r3,32(r3)
  472f60:	10c00035 	stwio	r3,0(r2)
  472f64:	e0bff317 	ldw	r2,-52(fp)
  472f68:	e0bff715 	stw	r2,-36(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  472f6c:	0005303a 	rdctl	r2,status
  472f70:	e0bff815 	stw	r2,-32(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  472f74:	e0fff817 	ldw	r3,-32(fp)
  472f78:	00bfff84 	movi	r2,-2
  472f7c:	1884703a 	and	r2,r3,r2
  472f80:	e0bff815 	stw	r2,-32(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  472f84:	e0bff717 	ldw	r2,-36(fp)
  472f88:	1080004c 	andi	r2,r2,1
  472f8c:	e0fff817 	ldw	r3,-32(fp)
  472f90:	1884b03a 	or	r2,r3,r2
  472f94:	e0bff815 	stw	r2,-32(fp)
  
  NIOS2_WRITE_STATUS (status);
  472f98:	e0bff817 	ldw	r2,-32(fp)
  472f9c:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
  472fa0:	e0bffe17 	ldw	r2,-8(fp)
  472fa4:	00802e0e 	bge	zero,r2,473060 <altera_avalon_jtag_uart_write+0x28c>
    {
      if (flags & O_NONBLOCK)
  472fa8:	e0bfff17 	ldw	r2,-4(fp)
  472fac:	1090000c 	andi	r2,r2,16384
  472fb0:	10002e1e 	bne	r2,zero,47306c <altera_avalon_jtag_uart_write+0x298>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
  472fb4:	00801234 	movhi	r2,72
  472fb8:	10a63e44 	addi	r2,r2,-26375
  472fbc:	10800003 	ldbu	r2,0(r2)
  472fc0:	10803fcc 	andi	r2,r2,255
  472fc4:	10800058 	cmpnei	r2,r2,1
  472fc8:	1000171e 	bne	r2,zero,473028 <altera_avalon_jtag_uart_write+0x254>
         * more profitable elsewhere.
         */
#ifdef ALTERA_AVALON_JTAG_UART_IGNORE_FIFO_FULL_ERROR
        if(!sp->host_inactive)
#endif
        ALT_FLAG_PEND (sp->events,
  472fcc:	e0bffc17 	ldw	r2,-16(fp)
  472fd0:	10800c17 	ldw	r2,48(r2)
  472fd4:	e0bff915 	stw	r2,-28(fp)
  472fd8:	00800184 	movi	r2,6
  472fdc:	e0bffa0d 	sth	r2,-24(fp)
  472fe0:	00bfe0c4 	movi	r2,-125
  472fe4:	e0bffa85 	stb	r2,-22(fp)
  472fe8:	e03ffb0d 	sth	zero,-20(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
  472fec:	00801234 	movhi	r2,72
  472ff0:	10a63e44 	addi	r2,r2,-26375
  472ff4:	10800003 	ldbu	r2,0(r2)
  472ff8:	10803fcc 	andi	r2,r2,255
  472ffc:	10001426 	beq	r2,zero,473050 <altera_avalon_jtag_uart_write+0x27c>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
  473000:	e17ffa0b 	ldhu	r5,-24(fp)
  473004:	e0fffa83 	ldbu	r3,-22(fp)
  473008:	e0bffb0b 	ldhu	r2,-20(fp)
  47300c:	e13ffb84 	addi	r4,fp,-18
  473010:	d9000015 	stw	r4,0(sp)
  473014:	e13ff917 	ldw	r4,-28(fp)
  473018:	180d883a 	mov	r6,r3
  47301c:	100f883a 	mov	r7,r2
  473020:	046b9e00 	call	46b9e0 <OSFlagPend>
  473024:	00000a06 	br	473050 <altera_avalon_jtag_uart_write+0x27c>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
  473028:	0001883a 	nop
  47302c:	e0bffc17 	ldw	r2,-16(fp)
  473030:	10c01017 	ldw	r3,64(r2)
  473034:	e0bfef17 	ldw	r2,-68(fp)
  473038:	1880051e 	bne	r3,r2,473050 <altera_avalon_jtag_uart_write+0x27c>
  47303c:	e0bffc17 	ldw	r2,-16(fp)
  473040:	10c00917 	ldw	r3,36(r2)
  473044:	e0bffc17 	ldw	r2,-16(fp)
  473048:	10800117 	ldw	r2,4(r2)
  47304c:	18bff736 	bltu	r3,r2,47302c <altera_avalon_jtag_uart_write+0x258>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
  473050:	e0bffc17 	ldw	r2,-16(fp)
  473054:	10c01017 	ldw	r3,64(r2)
  473058:	e0bfef17 	ldw	r2,-68(fp)
  47305c:	18800526 	beq	r3,r2,473074 <altera_avalon_jtag_uart_write+0x2a0>
         break;
    }
  }
  while (count > 0);
  473060:	e0bffe17 	ldw	r2,-8(fp)
  473064:	00bfa816 	blt	zero,r2,472f08 <altera_avalon_jtag_uart_write+0x134>
  473068:	00000306 	br	473078 <altera_avalon_jtag_uart_write+0x2a4>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
  47306c:	0001883a 	nop
  473070:	00000106 	br	473078 <altera_avalon_jtag_uart_write+0x2a4>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
         break;
  473074:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
  473078:	e0bffc17 	ldw	r2,-16(fp)
  47307c:	10800b17 	ldw	r2,44(r2)
  473080:	1009883a 	mov	r4,r2
  473084:	046f54c0 	call	46f54c <OSSemPost>

  if (ptr != start)
  473088:	e0fffd17 	ldw	r3,-12(fp)
  47308c:	e0bff117 	ldw	r2,-60(fp)
  473090:	18800426 	beq	r3,r2,4730a4 <altera_avalon_jtag_uart_write+0x2d0>
    return ptr - start;
  473094:	e0fffd17 	ldw	r3,-12(fp)
  473098:	e0bff117 	ldw	r2,-60(fp)
  47309c:	1885c83a 	sub	r2,r3,r2
  4730a0:	00000606 	br	4730bc <altera_avalon_jtag_uart_write+0x2e8>
  else if (flags & O_NONBLOCK)
  4730a4:	e0bfff17 	ldw	r2,-4(fp)
  4730a8:	1090000c 	andi	r2,r2,16384
  4730ac:	10000226 	beq	r2,zero,4730b8 <altera_avalon_jtag_uart_write+0x2e4>
    return -EWOULDBLOCK;
  4730b0:	00bffd44 	movi	r2,-11
  4730b4:	00000106 	br	4730bc <altera_avalon_jtag_uart_write+0x2e8>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
  4730b8:	00bffec4 	movi	r2,-5
}
  4730bc:	e037883a 	mov	sp,fp
  4730c0:	dfc00117 	ldw	ra,4(sp)
  4730c4:	df000017 	ldw	fp,0(sp)
  4730c8:	dec00204 	addi	sp,sp,8
  4730cc:	f800283a 	ret

004730d0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  4730d0:	defffe04 	addi	sp,sp,-8
  4730d4:	dfc00115 	stw	ra,4(sp)
  4730d8:	df000015 	stw	fp,0(sp)
  4730dc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  4730e0:	008011f4 	movhi	r2,71
  4730e4:	109f4204 	addi	r2,r2,32008
  4730e8:	10800017 	ldw	r2,0(r2)
  4730ec:	10000526 	beq	r2,zero,473104 <alt_get_errno+0x34>
  4730f0:	008011f4 	movhi	r2,71
  4730f4:	109f4204 	addi	r2,r2,32008
  4730f8:	10800017 	ldw	r2,0(r2)
  4730fc:	103ee83a 	callr	r2
  473100:	00000206 	br	47310c <alt_get_errno+0x3c>
  473104:	00801234 	movhi	r2,72
  473108:	10a63404 	addi	r2,r2,-26416
}
  47310c:	e037883a 	mov	sp,fp
  473110:	dfc00117 	ldw	ra,4(sp)
  473114:	df000017 	ldw	fp,0(sp)
  473118:	dec00204 	addi	sp,sp,8
  47311c:	f800283a 	ret

00473120 <alt_mutex_trylock>:
 *
 * returns 0 on success -1 otherwise
 *
 */
static int alt_mutex_trylock( alt_mutex_dev* dev, alt_u32 value )
{
  473120:	defff904 	addi	sp,sp,-28
  473124:	df000615 	stw	fp,24(sp)
  473128:	df000604 	addi	fp,sp,24
  47312c:	e13ffe15 	stw	r4,-8(fp)
  473130:	e17fff15 	stw	r5,-4(fp)
  alt_u32 id, data, check;
  int ret_code = -1;
  473134:	00bfffc4 	movi	r2,-1
  473138:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_READ_CPUID(id);
  47313c:	0005317a 	rdctl	r2,cpuid
  473140:	e0bffb15 	stw	r2,-20(fp)

  /* the data we want the mutex to hold */
  data = (id << ALTERA_AVALON_MUTEX_MUTEX_OWNER_OFST) | value;
  473144:	e0bffb17 	ldw	r2,-20(fp)
  473148:	1006943a 	slli	r3,r2,16
  47314c:	e0bfff17 	ldw	r2,-4(fp)
  473150:	1884b03a 	or	r2,r3,r2
  473154:	e0bffc15 	stw	r2,-16(fp)

  /* attempt to write to the mutex */
  IOWR_ALTERA_AVALON_MUTEX_MUTEX(dev->mutex_base, data);
  473158:	e0bffe17 	ldw	r2,-8(fp)
  47315c:	10800317 	ldw	r2,12(r2)
  473160:	e0fffc17 	ldw	r3,-16(fp)
  473164:	10c00035 	stwio	r3,0(r2)
  
  check = IORD_ALTERA_AVALON_MUTEX_MUTEX(dev->mutex_base);
  473168:	e0bffe17 	ldw	r2,-8(fp)
  47316c:	10800317 	ldw	r2,12(r2)
  473170:	10800037 	ldwio	r2,0(r2)
  473174:	e0bffd15 	stw	r2,-12(fp)

  if ( check == data)
  473178:	e0fffd17 	ldw	r3,-12(fp)
  47317c:	e0bffc17 	ldw	r2,-16(fp)
  473180:	1880011e 	bne	r3,r2,473188 <alt_mutex_trylock+0x68>
  {
    ret_code = 0;
  473184:	e03ffa15 	stw	zero,-24(fp)
  }

  return ret_code;
  473188:	e0bffa17 	ldw	r2,-24(fp)
}
  47318c:	e037883a 	mov	sp,fp
  473190:	df000017 	ldw	fp,0(sp)
  473194:	dec00104 	addi	sp,sp,4
  473198:	f800283a 	ret

0047319c <altera_avalon_mutex_open>:
 * Search the list of registered mutexes for one with the supplied name.
 *
 * The return value will be NULL on failure, and non-NULL otherwise.
 */
alt_mutex_dev* altera_avalon_mutex_open (const char* name)
{
  47319c:	defffc04 	addi	sp,sp,-16
  4731a0:	dfc00315 	stw	ra,12(sp)
  4731a4:	df000215 	stw	fp,8(sp)
  4731a8:	df000204 	addi	fp,sp,8
  4731ac:	e13fff15 	stw	r4,-4(fp)
  alt_mutex_dev* dev;

  dev = (alt_mutex_dev*) alt_find_dev (name, &alt_mutex_list);
  4731b0:	e13fff17 	ldw	r4,-4(fp)
  4731b4:	d1603104 	addi	r5,gp,-32572
  4731b8:	0473aec0 	call	473aec <alt_find_dev>
  4731bc:	e0bffe15 	stw	r2,-8(fp)

  if (NULL == dev)
  4731c0:	e0bffe17 	ldw	r2,-8(fp)
  4731c4:	1000031e 	bne	r2,zero,4731d4 <altera_avalon_mutex_open+0x38>
  {
    ALT_ERRNO = ENODEV;
  4731c8:	04730d00 	call	4730d0 <alt_get_errno>
  4731cc:	00c004c4 	movi	r3,19
  4731d0:	10c00015 	stw	r3,0(r2)
  }

  return dev;
  4731d4:	e0bffe17 	ldw	r2,-8(fp)
}
  4731d8:	e037883a 	mov	sp,fp
  4731dc:	dfc00117 	ldw	ra,4(sp)
  4731e0:	df000017 	ldw	fp,0(sp)
  4731e4:	dec00204 	addi	sp,sp,8
  4731e8:	f800283a 	ret

004731ec <altera_avalon_mutex_close>:
 * altera_avalon_mutex_close - Does nothing at the moment, but included for 
 * completeness
 *
 */
void altera_avalon_mutex_close (alt_mutex_dev* dev)
{
  4731ec:	defffe04 	addi	sp,sp,-8
  4731f0:	df000115 	stw	fp,4(sp)
  4731f4:	df000104 	addi	fp,sp,4
  4731f8:	e13fff15 	stw	r4,-4(fp)
  return;
  4731fc:	0001883a 	nop
}
  473200:	e037883a 	mov	sp,fp
  473204:	df000017 	ldw	fp,0(sp)
  473208:	dec00104 	addi	sp,sp,4
  47320c:	f800283a 	ret

00473210 <altera_avalon_mutex_lock>:
/*
 * altera_avalon_mutex_lock - Lock the hardware mutex
 *
 */
void altera_avalon_mutex_lock( alt_mutex_dev* dev, alt_u32 value )
{
  473210:	defffa04 	addi	sp,sp,-24
  473214:	dfc00515 	stw	ra,20(sp)
  473218:	df000415 	stw	fp,16(sp)
  47321c:	df000404 	addi	fp,sp,16
  473220:	e13ffe15 	stw	r4,-8(fp)
  473224:	e17fff15 	stw	r5,-4(fp)
  /*
   * When running in a multi threaded environment, obtain the "lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */

  ALT_SEM_PEND (dev->lock, 0);
  473228:	e0bffe17 	ldw	r2,-8(fp)
  47322c:	10800417 	ldw	r2,16(r2)
  473230:	e0bffc15 	stw	r2,-16(fp)
  473234:	e03ffd0d 	sth	zero,-12(fp)
  473238:	e0fffd0b 	ldhu	r3,-12(fp)
  47323c:	e0bffd84 	addi	r2,fp,-10
  473240:	e13ffc17 	ldw	r4,-16(fp)
  473244:	180b883a 	mov	r5,r3
  473248:	100d883a 	mov	r6,r2
  47324c:	046f0900 	call	46f090 <OSSemPend>

  while ( alt_mutex_trylock( dev, value ) != 0);
  473250:	0001883a 	nop
  473254:	e13ffe17 	ldw	r4,-8(fp)
  473258:	e17fff17 	ldw	r5,-4(fp)
  47325c:	04731200 	call	473120 <alt_mutex_trylock>
  473260:	103ffc1e 	bne	r2,zero,473254 <altera_avalon_mutex_lock+0x44>
}
  473264:	e037883a 	mov	sp,fp
  473268:	dfc00117 	ldw	ra,4(sp)
  47326c:	df000017 	ldw	fp,0(sp)
  473270:	dec00204 	addi	sp,sp,8
  473274:	f800283a 	ret

00473278 <altera_avalon_mutex_trylock>:
 *
 * returns 0 on success -1 otherwise
 *
 */
int altera_avalon_mutex_trylock( alt_mutex_dev* dev, alt_u32 value )
{
  473278:	defff904 	addi	sp,sp,-28
  47327c:	dfc00615 	stw	ra,24(sp)
  473280:	df000515 	stw	fp,20(sp)
  473284:	df000504 	addi	fp,sp,20
  473288:	e13ffe15 	stw	r4,-8(fp)
  47328c:	e17fff15 	stw	r5,-4(fp)
  int ret_code;

  ALT_SEM_PEND (dev->lock, 0);
  473290:	e0bffe17 	ldw	r2,-8(fp)
  473294:	10800417 	ldw	r2,16(r2)
  473298:	e0bffc15 	stw	r2,-16(fp)
  47329c:	e03ffd0d 	sth	zero,-12(fp)
  4732a0:	e0fffd0b 	ldhu	r3,-12(fp)
  4732a4:	e0bffd84 	addi	r2,fp,-10
  4732a8:	e13ffc17 	ldw	r4,-16(fp)
  4732ac:	180b883a 	mov	r5,r3
  4732b0:	100d883a 	mov	r6,r2
  4732b4:	046f0900 	call	46f090 <OSSemPend>

  ret_code = alt_mutex_trylock( dev, value);
  4732b8:	e13ffe17 	ldw	r4,-8(fp)
  4732bc:	e17fff17 	ldw	r5,-4(fp)
  4732c0:	04731200 	call	473120 <alt_mutex_trylock>
  4732c4:	e0bffb15 	stw	r2,-20(fp)

  /*
  * If the try failed then release the thread Mutex  
  */
  if (ret_code)
  4732c8:	e0bffb17 	ldw	r2,-20(fp)
  4732cc:	10000426 	beq	r2,zero,4732e0 <altera_avalon_mutex_trylock+0x68>
  {
    ALT_SEM_POST (dev->lock);
  4732d0:	e0bffe17 	ldw	r2,-8(fp)
  4732d4:	10800417 	ldw	r2,16(r2)
  4732d8:	1009883a 	mov	r4,r2
  4732dc:	046f54c0 	call	46f54c <OSSemPost>
  }

  return ret_code;
  4732e0:	e0bffb17 	ldw	r2,-20(fp)
}
  4732e4:	e037883a 	mov	sp,fp
  4732e8:	dfc00117 	ldw	ra,4(sp)
  4732ec:	df000017 	ldw	fp,0(sp)
  4732f0:	dec00204 	addi	sp,sp,8
  4732f4:	f800283a 	ret

004732f8 <altera_avalon_mutex_unlock>:
 * This function does not check that you own the Mutex if you try to release
 * a Mutex you do not own the behaviour is undefined
 *
 */
void altera_avalon_mutex_unlock( alt_mutex_dev* dev )
{
  4732f8:	defffc04 	addi	sp,sp,-16
  4732fc:	dfc00315 	stw	ra,12(sp)
  473300:	df000215 	stw	fp,8(sp)
  473304:	df000204 	addi	fp,sp,8
  473308:	e13fff15 	stw	r4,-4(fp)
  alt_u32 id;
  NIOS2_READ_CPUID(id);
  47330c:	0005317a 	rdctl	r2,cpuid
  473310:	e0bffe15 	stw	r2,-8(fp)

  /*
  * This Mutex has been claimed and released since Reset so clear the Reset bit
  * This MUST happen before we release the MUTEX
  */
  IOWR_ALTERA_AVALON_MUTEX_RESET(dev->mutex_base, 
  473314:	e0bfff17 	ldw	r2,-4(fp)
  473318:	10800317 	ldw	r2,12(r2)
  47331c:	10800104 	addi	r2,r2,4
  473320:	00c00044 	movi	r3,1
  473324:	10c00035 	stwio	r3,0(r2)
                                  ALTERA_AVALON_MUTEX_RESET_RESET_MSK);
  IOWR_ALTERA_AVALON_MUTEX_MUTEX(dev->mutex_base, 
  473328:	e0bfff17 	ldw	r2,-4(fp)
  47332c:	10800317 	ldw	r2,12(r2)
  473330:	e0fffe17 	ldw	r3,-8(fp)
  473334:	1806943a 	slli	r3,r3,16
  473338:	10c00035 	stwio	r3,0(r2)
                                  id << ALTERA_AVALON_MUTEX_MUTEX_OWNER_OFST);

  /*
  * Now that access to the hardware Mutex is complete, release the thread lock
  */
  ALT_SEM_POST (dev->lock);
  47333c:	e0bfff17 	ldw	r2,-4(fp)
  473340:	10800417 	ldw	r2,16(r2)
  473344:	1009883a 	mov	r4,r2
  473348:	046f54c0 	call	46f54c <OSSemPost>
}
  47334c:	e037883a 	mov	sp,fp
  473350:	dfc00117 	ldw	ra,4(sp)
  473354:	df000017 	ldw	fp,0(sp)
  473358:	dec00204 	addi	sp,sp,8
  47335c:	f800283a 	ret

00473360 <altera_avalon_mutex_is_mine>:
 * altera_avalon_mutex_is_mine - Do I own the Mutex?
 *
 *  returns non zero if the mutex is owned by this CPU
 */
int altera_avalon_mutex_is_mine( alt_mutex_dev* dev )
{
  473360:	defff904 	addi	sp,sp,-28
  473364:	df000615 	stw	fp,24(sp)
  473368:	df000604 	addi	fp,sp,24
  47336c:	e13fff15 	stw	r4,-4(fp)
  alt_u32 id, data, owner, value;
  int ret_code = 0;
  473370:	e03ffa15 	stw	zero,-24(fp)

  NIOS2_READ_CPUID(id);
  473374:	0005317a 	rdctl	r2,cpuid
  473378:	e0bffb15 	stw	r2,-20(fp)

  /* retrieve the contents of the mutex */
  data = IORD_ALTERA_AVALON_MUTEX_MUTEX(dev->mutex_base);
  47337c:	e0bfff17 	ldw	r2,-4(fp)
  473380:	10800317 	ldw	r2,12(r2)
  473384:	10800037 	ldwio	r2,0(r2)
  473388:	e0bffc15 	stw	r2,-16(fp)
  owner = (data & ALTERA_AVALON_MUTEX_MUTEX_OWNER_MSK) >> 
  47338c:	e0bffc17 	ldw	r2,-16(fp)
  473390:	1004d43a 	srli	r2,r2,16
  473394:	e0bffd15 	stw	r2,-12(fp)
              ALTERA_AVALON_MUTEX_MUTEX_OWNER_OFST;

  if (owner == id) 
  473398:	e0fffd17 	ldw	r3,-12(fp)
  47339c:	e0bffb17 	ldw	r2,-20(fp)
  4733a0:	1880071e 	bne	r3,r2,4733c0 <altera_avalon_mutex_is_mine+0x60>
  {
    value = (data & ALTERA_AVALON_MUTEX_MUTEX_VALUE_MSK) >> 
  4733a4:	e0bffc17 	ldw	r2,-16(fp)
  4733a8:	10bfffcc 	andi	r2,r2,65535
  4733ac:	e0bffe15 	stw	r2,-8(fp)
                  ALTERA_AVALON_MUTEX_MUTEX_VALUE_OFST;
    if (value != 0)
  4733b0:	e0bffe17 	ldw	r2,-8(fp)
  4733b4:	10000226 	beq	r2,zero,4733c0 <altera_avalon_mutex_is_mine+0x60>
    {
      ret_code = 1;
  4733b8:	00800044 	movi	r2,1
  4733bc:	e0bffa15 	stw	r2,-24(fp)
    }
  }

  return ret_code;
  4733c0:	e0bffa17 	ldw	r2,-24(fp)
}
  4733c4:	e037883a 	mov	sp,fp
  4733c8:	df000017 	ldw	fp,0(sp)
  4733cc:	dec00104 	addi	sp,sp,4
  4733d0:	f800283a 	ret

004733d4 <altera_avalon_mutex_first_lock>:
 *
 * Has this Mutex been released since reset if not return 1
 * otherwise return 0
 */
int altera_avalon_mutex_first_lock( alt_mutex_dev* dev )
{
  4733d4:	defffc04 	addi	sp,sp,-16
  4733d8:	df000315 	stw	fp,12(sp)
  4733dc:	df000304 	addi	fp,sp,12
  4733e0:	e13fff15 	stw	r4,-4(fp)
  alt_u32 data;
  int ret_code = 0;
  4733e4:	e03ffd15 	stw	zero,-12(fp)

  data = IORD_ALTERA_AVALON_MUTEX_RESET(dev->mutex_base);
  4733e8:	e0bfff17 	ldw	r2,-4(fp)
  4733ec:	10800317 	ldw	r2,12(r2)
  4733f0:	10800104 	addi	r2,r2,4
  4733f4:	10800037 	ldwio	r2,0(r2)
  4733f8:	e0bffe15 	stw	r2,-8(fp)

  if (data & ALTERA_AVALON_MUTEX_RESET_RESET_MSK) 
  4733fc:	e0bffe17 	ldw	r2,-8(fp)
  473400:	1080004c 	andi	r2,r2,1
  473404:	10000226 	beq	r2,zero,473410 <altera_avalon_mutex_first_lock+0x3c>
  {
    ret_code = 1;
  473408:	00800044 	movi	r2,1
  47340c:	e0bffd15 	stw	r2,-12(fp)
  }

  return ret_code;
  473410:	e0bffd17 	ldw	r2,-12(fp)
}
  473414:	e037883a 	mov	sp,fp
  473418:	df000017 	ldw	fp,0(sp)
  47341c:	dec00104 	addi	sp,sp,4
  473420:	f800283a 	ret

00473424 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
  473424:	defff904 	addi	sp,sp,-28
  473428:	dfc00615 	stw	ra,24(sp)
  47342c:	df000515 	stw	fp,20(sp)
  473430:	df000504 	addi	fp,sp,20
  473434:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
  473438:	0007883a 	mov	r3,zero
  47343c:	e0bfff17 	ldw	r2,-4(fp)
  473440:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
  473444:	e0bfff17 	ldw	r2,-4(fp)
  473448:	10800104 	addi	r2,r2,4
  47344c:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  473450:	0005303a 	rdctl	r2,status
  473454:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  473458:	e0fffc17 	ldw	r3,-16(fp)
  47345c:	00bfff84 	movi	r2,-2
  473460:	1884703a 	and	r2,r3,r2
  473464:	1001703a 	wrctl	status,r2
  
  return context;
  473468:	e0bffc17 	ldw	r2,-16(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
  47346c:	e0bffb15 	stw	r2,-20(fp)
  alt_tick ();
  473470:	04740600 	call	474060 <alt_tick>
  473474:	e0bffb17 	ldw	r2,-20(fp)
  473478:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  47347c:	0005303a 	rdctl	r2,status
  473480:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  473484:	e0fffe17 	ldw	r3,-8(fp)
  473488:	00bfff84 	movi	r2,-2
  47348c:	1884703a 	and	r2,r3,r2
  473490:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  473494:	e0bffd17 	ldw	r2,-12(fp)
  473498:	1080004c 	andi	r2,r2,1
  47349c:	e0fffe17 	ldw	r3,-8(fp)
  4734a0:	1884b03a 	or	r2,r3,r2
  4734a4:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
  4734a8:	e0bffe17 	ldw	r2,-8(fp)
  4734ac:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
  4734b0:	e037883a 	mov	sp,fp
  4734b4:	dfc00117 	ldw	ra,4(sp)
  4734b8:	df000017 	ldw	fp,0(sp)
  4734bc:	dec00204 	addi	sp,sp,8
  4734c0:	f800283a 	ret

004734c4 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
  4734c4:	defff804 	addi	sp,sp,-32
  4734c8:	dfc00715 	stw	ra,28(sp)
  4734cc:	df000615 	stw	fp,24(sp)
  4734d0:	df000604 	addi	fp,sp,24
  4734d4:	e13ffc15 	stw	r4,-16(fp)
  4734d8:	e17ffd15 	stw	r5,-12(fp)
  4734dc:	e1bffe15 	stw	r6,-8(fp)
  4734e0:	e1ffff15 	stw	r7,-4(fp)
  4734e4:	e0bfff17 	ldw	r2,-4(fp)
  4734e8:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
  4734ec:	00801234 	movhi	r2,72
  4734f0:	10a65404 	addi	r2,r2,-26288
  4734f4:	10800017 	ldw	r2,0(r2)
  4734f8:	1000041e 	bne	r2,zero,47350c <alt_avalon_timer_sc_init+0x48>
  {
    _alt_tick_rate = nticks;
  4734fc:	00801234 	movhi	r2,72
  473500:	10a65404 	addi	r2,r2,-26288
  473504:	e0fffb17 	ldw	r3,-20(fp)
  473508:	10c00015 	stw	r3,0(r2)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
  47350c:	e0bffc17 	ldw	r2,-16(fp)
  473510:	10800104 	addi	r2,r2,4
  473514:	00c001c4 	movi	r3,7
  473518:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
  47351c:	d8000015 	stw	zero,0(sp)
  473520:	e13ffd17 	ldw	r4,-12(fp)
  473524:	e17ffe17 	ldw	r5,-8(fp)
  473528:	018011f4 	movhi	r6,71
  47352c:	318d0904 	addi	r6,r6,13348
  473530:	e1fffc17 	ldw	r7,-16(fp)
  473534:	04678600 	call	467860 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
  473538:	e037883a 	mov	sp,fp
  47353c:	dfc00117 	ldw	ra,4(sp)
  473540:	df000017 	ldw	fp,0(sp)
  473544:	dec00204 	addi	sp,sp,8
  473548:	f800283a 	ret

0047354c <alt_timestamp_start>:
 * The return value of this function is 0 upon sucess and -1 if in timestamp
 * device has not been registered. 
 */

int alt_timestamp_start(void)
{
  47354c:	defffe04 	addi	sp,sp,-8
  473550:	df000115 	stw	fp,4(sp)
  473554:	df000104 	addi	fp,sp,4
  void* base = altera_avalon_timer_ts_base;
  473558:	00801234 	movhi	r2,72
  47355c:	10a65204 	addi	r2,r2,-26296
  473560:	10800017 	ldw	r2,0(r2)
  473564:	e0bfff15 	stw	r2,-4(fp)

  if (!altera_avalon_timer_ts_freq)
  473568:	00801234 	movhi	r2,72
  47356c:	10a65304 	addi	r2,r2,-26292
  473570:	10800017 	ldw	r2,0(r2)
  473574:	1000021e 	bne	r2,zero,473580 <alt_timestamp_start+0x34>
  {
    return -1;
  473578:	00bfffc4 	movi	r2,-1
  47357c:	00001906 	br	4735e4 <alt_timestamp_start+0x98>
  }
  else
  {
    if(ALT_TIMESTAMP_COUNTER_SIZE == 64) {
        IOWR_ALTERA_AVALON_TIMER_CONTROL (base,ALTERA_AVALON_TIMER_CONTROL_STOP_MSK);
  473580:	e0bfff17 	ldw	r2,-4(fp)
  473584:	10800104 	addi	r2,r2,4
  473588:	00c00204 	movi	r3,8
  47358c:	10c00035 	stwio	r3,0(r2)
        IOWR_ALTERA_AVALON_TIMER_PERIOD_0 (base, 0xFFFF);
  473590:	e0bfff17 	ldw	r2,-4(fp)
  473594:	10800204 	addi	r2,r2,8
  473598:	00ffffd4 	movui	r3,65535
  47359c:	10c00035 	stwio	r3,0(r2)
        IOWR_ALTERA_AVALON_TIMER_PERIOD_1 (base, 0xFFFF);;
  4735a0:	e0bfff17 	ldw	r2,-4(fp)
  4735a4:	10800304 	addi	r2,r2,12
  4735a8:	00ffffd4 	movui	r3,65535
  4735ac:	10c00035 	stwio	r3,0(r2)
        IOWR_ALTERA_AVALON_TIMER_PERIOD_2 (base, 0xFFFF);
  4735b0:	e0bfff17 	ldw	r2,-4(fp)
  4735b4:	10800404 	addi	r2,r2,16
  4735b8:	00ffffd4 	movui	r3,65535
  4735bc:	10c00035 	stwio	r3,0(r2)
        IOWR_ALTERA_AVALON_TIMER_PERIOD_3 (base, 0xFFFF);
  4735c0:	e0bfff17 	ldw	r2,-4(fp)
  4735c4:	10800504 	addi	r2,r2,20
  4735c8:	00ffffd4 	movui	r3,65535
  4735cc:	10c00035 	stwio	r3,0(r2)
        IOWR_ALTERA_AVALON_TIMER_CONTROL (base, ALTERA_AVALON_TIMER_CONTROL_START_MSK);
  4735d0:	e0bfff17 	ldw	r2,-4(fp)
  4735d4:	10800104 	addi	r2,r2,4
  4735d8:	00c00104 	movi	r3,4
  4735dc:	10c00035 	stwio	r3,0(r2)
        IOWR_ALTERA_AVALON_TIMER_PERIODL (base, 0xFFFF);
        IOWR_ALTERA_AVALON_TIMER_PERIODH (base, 0xFFFF);
        IOWR_ALTERA_AVALON_TIMER_CONTROL (base, ALTERA_AVALON_TIMER_CONTROL_START_MSK); 
    } 
  }
  return 0;
  4735e0:	0005883a 	mov	r2,zero
}
  4735e4:	e037883a 	mov	sp,fp
  4735e8:	df000017 	ldw	fp,0(sp)
  4735ec:	dec00104 	addi	sp,sp,4
  4735f0:	f800283a 	ret

004735f4 <alt_timestamp>:
 * The returned timestamp counts up from the last time the period register
 * was reset. 
 */

alt_timestamp_type alt_timestamp(void)
{
  4735f4:	deffec04 	addi	sp,sp,-80
  4735f8:	df001315 	stw	fp,76(sp)
  4735fc:	ddc01215 	stw	r23,72(sp)
  473600:	dd801115 	stw	r22,68(sp)
  473604:	dd401015 	stw	r21,64(sp)
  473608:	dd000f15 	stw	r20,60(sp)
  47360c:	dcc00e15 	stw	r19,56(sp)
  473610:	dc800d15 	stw	r18,52(sp)
  473614:	dc400c15 	stw	r17,48(sp)
  473618:	dc000b15 	stw	r16,44(sp)
  47361c:	df000b04 	addi	fp,sp,44

  void* base = altera_avalon_timer_ts_base;
  473620:	00801234 	movhi	r2,72
  473624:	10a65204 	addi	r2,r2,-26296
  473628:	10800017 	ldw	r2,0(r2)
  47362c:	e0bff515 	stw	r2,-44(fp)

  if (!altera_avalon_timer_ts_freq)
  473630:	00801234 	movhi	r2,72
  473634:	10a65304 	addi	r2,r2,-26292
  473638:	10800017 	ldw	r2,0(r2)
  47363c:	1000031e 	bne	r2,zero,47364c <alt_timestamp+0x58>
  {
	if(ALT_TIMESTAMP_COUNTER_SIZE == 64) {
        return 0xFFFFFFFFFFFFFFFFULL;
  473640:	017fffc4 	movi	r5,-1
  473644:	01bfffc4 	movi	r6,-1
  473648:	00004206 	br	473754 <alt_timestamp+0x160>
    }
  }
  else
  {
    if(ALT_TIMESTAMP_COUNTER_SIZE == 64) {
        IOWR_ALTERA_AVALON_TIMER_SNAP_0 (base, 0);
  47364c:	e0bff517 	ldw	r2,-44(fp)
  473650:	15c00604 	addi	r23,r2,24
  473654:	0005883a 	mov	r2,zero
  473658:	b8800035 	stwio	r2,0(r23)
        alt_timestamp_type snap_0 = IORD_ALTERA_AVALON_TIMER_SNAP_0(base) & ALTERA_AVALON_TIMER_SNAP_0_MSK;
  47365c:	e0bff517 	ldw	r2,-44(fp)
  473660:	10800604 	addi	r2,r2,24
  473664:	10800037 	ldwio	r2,0(r2)
  473668:	e0bffe15 	stw	r2,-8(fp)
  47366c:	0005883a 	mov	r2,zero
  473670:	e0bfff15 	stw	r2,-4(fp)
  473674:	e0fffe17 	ldw	r3,-8(fp)
  473678:	18bfffcc 	andi	r2,r3,65535
  47367c:	e0bff615 	stw	r2,-40(fp)
  473680:	e0ffff17 	ldw	r3,-4(fp)
  473684:	1804703a 	and	r2,r3,zero
  473688:	e0bff715 	stw	r2,-36(fp)
        alt_timestamp_type snap_1 = IORD_ALTERA_AVALON_TIMER_SNAP_1(base) & ALTERA_AVALON_TIMER_SNAP_1_MSK;
  47368c:	e0bff517 	ldw	r2,-44(fp)
  473690:	10800704 	addi	r2,r2,28
  473694:	10800037 	ldwio	r2,0(r2)
  473698:	102b883a 	mov	r21,r2
  47369c:	002d883a 	mov	r22,zero
  4736a0:	a8bfffcc 	andi	r2,r21,65535
  4736a4:	e0bff815 	stw	r2,-32(fp)
  4736a8:	b004703a 	and	r2,r22,zero
  4736ac:	e0bff915 	stw	r2,-28(fp)
        alt_timestamp_type snap_2 = IORD_ALTERA_AVALON_TIMER_SNAP_2(base) & ALTERA_AVALON_TIMER_SNAP_2_MSK;
  4736b0:	e0bff517 	ldw	r2,-44(fp)
  4736b4:	10800804 	addi	r2,r2,32
  4736b8:	10800037 	ldwio	r2,0(r2)
  4736bc:	1027883a 	mov	r19,r2
  4736c0:	0029883a 	mov	r20,zero
  4736c4:	98bfffcc 	andi	r2,r19,65535
  4736c8:	e0bffa15 	stw	r2,-24(fp)
  4736cc:	a004703a 	and	r2,r20,zero
  4736d0:	e0bffb15 	stw	r2,-20(fp)
        alt_timestamp_type snap_3 = IORD_ALTERA_AVALON_TIMER_SNAP_3(base) & ALTERA_AVALON_TIMER_SNAP_3_MSK;
  4736d4:	e0bff517 	ldw	r2,-44(fp)
  4736d8:	10800904 	addi	r2,r2,36
  4736dc:	10800037 	ldwio	r2,0(r2)
  4736e0:	1023883a 	mov	r17,r2
  4736e4:	0025883a 	mov	r18,zero
  4736e8:	88bfffcc 	andi	r2,r17,65535
  4736ec:	e0bffc15 	stw	r2,-16(fp)
  4736f0:	9004703a 	and	r2,r18,zero
  4736f4:	e0bffd15 	stw	r2,-12(fp)
        
        return (0xFFFFFFFFFFFFFFFFULL - ( (snap_3 << 48) | (snap_2 << 32) | (snap_1 << 16) | (snap_0) ));
  4736f8:	e0bffc17 	ldw	r2,-16(fp)
  4736fc:	1020943a 	slli	r16,r2,16
  473700:	001f883a 	mov	r15,zero
  473704:	e0bffa17 	ldw	r2,-24(fp)
  473708:	1008983a 	sll	r4,r2,zero
  47370c:	0007883a 	mov	r3,zero
  473710:	78dab03a 	or	r13,r15,r3
  473714:	811cb03a 	or	r14,r16,r4
  473718:	e0bff817 	ldw	r2,-32(fp)
  47371c:	1004d43a 	srli	r2,r2,16
  473720:	e0fff917 	ldw	r3,-28(fp)
  473724:	1810943a 	slli	r8,r3,16
  473728:	1210b03a 	or	r8,r2,r8
  47372c:	e0bff817 	ldw	r2,-32(fp)
  473730:	100e943a 	slli	r7,r2,16
  473734:	69d6b03a 	or	r11,r13,r7
  473738:	7218b03a 	or	r12,r14,r8
  47373c:	e0bff617 	ldw	r2,-40(fp)
  473740:	12d2b03a 	or	r9,r2,r11
  473744:	e0bff717 	ldw	r2,-36(fp)
  473748:	1314b03a 	or	r10,r2,r12
  47374c:	024a303a 	nor	r5,zero,r9
  473750:	028c303a 	nor	r6,zero,r10
  473754:	2807883a 	mov	r3,r5
  473758:	3009883a 	mov	r4,r6
        alt_timestamp_type upper = IORD_ALTERA_AVALON_TIMER_SNAPH(base) & ALTERA_AVALON_TIMER_SNAPH_MSK;
        
        return (0xFFFFFFFF - ((upper << 16) | lower)); 
    }  
  }
}
  47375c:	1805883a 	mov	r2,r3
  473760:	2007883a 	mov	r3,r4
  473764:	e037883a 	mov	sp,fp
  473768:	df000817 	ldw	fp,32(sp)
  47376c:	ddc00717 	ldw	r23,28(sp)
  473770:	dd800617 	ldw	r22,24(sp)
  473774:	dd400517 	ldw	r21,20(sp)
  473778:	dd000417 	ldw	r20,16(sp)
  47377c:	dcc00317 	ldw	r19,12(sp)
  473780:	dc800217 	ldw	r18,8(sp)
  473784:	dc400117 	ldw	r17,4(sp)
  473788:	dc000017 	ldw	r16,0(sp)
  47378c:	dec00904 	addi	sp,sp,36
  473790:	f800283a 	ret

00473794 <alt_timestamp_freq>:
 * Return the number of timestamp ticks per second. This will be 0 if no
 * timestamp device has been registered.
 */

alt_u32 alt_timestamp_freq(void)
{
  473794:	deffff04 	addi	sp,sp,-4
  473798:	df000015 	stw	fp,0(sp)
  47379c:	d839883a 	mov	fp,sp
  return altera_avalon_timer_ts_freq;
  4737a0:	00801234 	movhi	r2,72
  4737a4:	10a65304 	addi	r2,r2,-26292
  4737a8:	10800017 	ldw	r2,0(r2)
}
  4737ac:	e037883a 	mov	sp,fp
  4737b0:	df000017 	ldw	fp,0(sp)
  4737b4:	dec00104 	addi	sp,sp,4
  4737b8:	f800283a 	ret

004737bc <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
  4737bc:	defff404 	addi	sp,sp,-48
  4737c0:	df000b15 	stw	fp,44(sp)
  4737c4:	df000b04 	addi	fp,sp,44
  4737c8:	e13ffc15 	stw	r4,-16(fp)
  4737cc:	e17ffd15 	stw	r5,-12(fp)
  4737d0:	e1bffe15 	stw	r6,-8(fp)
  4737d4:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
  4737d8:	e03ff515 	stw	zero,-44(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
  4737dc:	00801234 	movhi	r2,72
  4737e0:	10a65404 	addi	r2,r2,-26288
  4737e4:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
  4737e8:	10004a26 	beq	r2,zero,473914 <alt_alarm_start+0x158>
  {
    if (alarm)
  4737ec:	e0bffc17 	ldw	r2,-16(fp)
  4737f0:	10004626 	beq	r2,zero,47390c <alt_alarm_start+0x150>
    {
      alarm->callback = callback;
  4737f4:	e0bffc17 	ldw	r2,-16(fp)
  4737f8:	e0fffe17 	ldw	r3,-8(fp)
  4737fc:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
  473800:	e0bffc17 	ldw	r2,-16(fp)
  473804:	e0ffff17 	ldw	r3,-4(fp)
  473808:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  47380c:	0005303a 	rdctl	r2,status
  473810:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  473814:	e0fff717 	ldw	r3,-36(fp)
  473818:	00bfff84 	movi	r2,-2
  47381c:	1884703a 	and	r2,r3,r2
  473820:	1001703a 	wrctl	status,r2
  
  return context;
  473824:	e0bff717 	ldw	r2,-36(fp)
 
      irq_context = alt_irq_disable_all ();
  473828:	e0bff615 	stw	r2,-40(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
  47382c:	00801234 	movhi	r2,72
  473830:	10a65504 	addi	r2,r2,-26284
  473834:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
  473838:	e0bff515 	stw	r2,-44(fp)
      
      alarm->time = nticks + current_nticks + 1; 
  47383c:	e0fffd17 	ldw	r3,-12(fp)
  473840:	e0bff517 	ldw	r2,-44(fp)
  473844:	1885883a 	add	r2,r3,r2
  473848:	10c00044 	addi	r3,r2,1
  47384c:	e0bffc17 	ldw	r2,-16(fp)
  473850:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
  473854:	e0bffc17 	ldw	r2,-16(fp)
  473858:	10c00217 	ldw	r3,8(r2)
  47385c:	e0bff517 	ldw	r2,-44(fp)
  473860:	1880042e 	bgeu	r3,r2,473874 <alt_alarm_start+0xb8>
      {
        alarm->rollover = 1;
  473864:	e0bffc17 	ldw	r2,-16(fp)
  473868:	00c00044 	movi	r3,1
  47386c:	10c00405 	stb	r3,16(r2)
  473870:	00000206 	br	47387c <alt_alarm_start+0xc0>
      }
      else
      {
        alarm->rollover = 0;
  473874:	e0bffc17 	ldw	r2,-16(fp)
  473878:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
  47387c:	e0bffc17 	ldw	r2,-16(fp)
  473880:	00c011f4 	movhi	r3,71
  473884:	18df6604 	addi	r3,r3,32152
  473888:	e0fff815 	stw	r3,-32(fp)
  47388c:	e0bff915 	stw	r2,-28(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  473890:	e0bff917 	ldw	r2,-28(fp)
  473894:	e0fff817 	ldw	r3,-32(fp)
  473898:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
  47389c:	e0bff817 	ldw	r2,-32(fp)
  4738a0:	10c00017 	ldw	r3,0(r2)
  4738a4:	e0bff917 	ldw	r2,-28(fp)
  4738a8:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
  4738ac:	e0bff817 	ldw	r2,-32(fp)
  4738b0:	10800017 	ldw	r2,0(r2)
  4738b4:	e0fff917 	ldw	r3,-28(fp)
  4738b8:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
  4738bc:	e0bff817 	ldw	r2,-32(fp)
  4738c0:	e0fff917 	ldw	r3,-28(fp)
  4738c4:	10c00015 	stw	r3,0(r2)
  4738c8:	e0bff617 	ldw	r2,-40(fp)
  4738cc:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  4738d0:	0005303a 	rdctl	r2,status
  4738d4:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  4738d8:	e0fffb17 	ldw	r3,-20(fp)
  4738dc:	00bfff84 	movi	r2,-2
  4738e0:	1884703a 	and	r2,r3,r2
  4738e4:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  4738e8:	e0bffa17 	ldw	r2,-24(fp)
  4738ec:	1080004c 	andi	r2,r2,1
  4738f0:	e0fffb17 	ldw	r3,-20(fp)
  4738f4:	1884b03a 	or	r2,r3,r2
  4738f8:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
  4738fc:	e0bffb17 	ldw	r2,-20(fp)
  473900:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
  473904:	0005883a 	mov	r2,zero
  473908:	00000306 	br	473918 <alt_alarm_start+0x15c>
    }
    else
    {
      return -EINVAL;
  47390c:	00bffa84 	movi	r2,-22
  473910:	00000106 	br	473918 <alt_alarm_start+0x15c>
    }
  }
  else
  {
    return -ENOTSUP;
  473914:	00bfde84 	movi	r2,-134
  }
}
  473918:	e037883a 	mov	sp,fp
  47391c:	df000017 	ldw	fp,0(sp)
  473920:	dec00104 	addi	sp,sp,4
  473924:	f800283a 	ret

00473928 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
  473928:	deffff04 	addi	sp,sp,-4
  47392c:	df000015 	stw	fp,0(sp)
  473930:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
  473934:	e037883a 	mov	sp,fp
  473938:	df000017 	ldw	fp,0(sp)
  47393c:	dec00104 	addi	sp,sp,4
  473940:	f800283a 	ret

00473944 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  473944:	defffe04 	addi	sp,sp,-8
  473948:	dfc00115 	stw	ra,4(sp)
  47394c:	df000015 	stw	fp,0(sp)
  473950:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  473954:	008011f4 	movhi	r2,71
  473958:	109f4204 	addi	r2,r2,32008
  47395c:	10800017 	ldw	r2,0(r2)
  473960:	10000526 	beq	r2,zero,473978 <alt_get_errno+0x34>
  473964:	008011f4 	movhi	r2,71
  473968:	109f4204 	addi	r2,r2,32008
  47396c:	10800017 	ldw	r2,0(r2)
  473970:	103ee83a 	callr	r2
  473974:	00000206 	br	473980 <alt_get_errno+0x3c>
  473978:	00801234 	movhi	r2,72
  47397c:	10a63404 	addi	r2,r2,-26416
}
  473980:	e037883a 	mov	sp,fp
  473984:	dfc00117 	ldw	ra,4(sp)
  473988:	df000017 	ldw	fp,0(sp)
  47398c:	dec00204 	addi	sp,sp,8
  473990:	f800283a 	ret

00473994 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
  473994:	defffa04 	addi	sp,sp,-24
  473998:	dfc00515 	stw	ra,20(sp)
  47399c:	df000415 	stw	fp,16(sp)
  4739a0:	df000404 	addi	fp,sp,16
  4739a4:	e13ffe15 	stw	r4,-8(fp)
  4739a8:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  4739ac:	e0bffe17 	ldw	r2,-8(fp)
  4739b0:	10000326 	beq	r2,zero,4739c0 <alt_dev_llist_insert+0x2c>
  4739b4:	e0bffe17 	ldw	r2,-8(fp)
  4739b8:	10800217 	ldw	r2,8(r2)
  4739bc:	1000051e 	bne	r2,zero,4739d4 <alt_dev_llist_insert+0x40>
  {
    ALT_ERRNO = EINVAL;
  4739c0:	04739440 	call	473944 <alt_get_errno>
  4739c4:	00c00584 	movi	r3,22
  4739c8:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
  4739cc:	00bffa84 	movi	r2,-22
  4739d0:	00001306 	br	473a20 <alt_dev_llist_insert+0x8c>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
  4739d4:	e0bffe17 	ldw	r2,-8(fp)
  4739d8:	e0ffff17 	ldw	r3,-4(fp)
  4739dc:	e0fffc15 	stw	r3,-16(fp)
  4739e0:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  4739e4:	e0bffd17 	ldw	r2,-12(fp)
  4739e8:	e0fffc17 	ldw	r3,-16(fp)
  4739ec:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
  4739f0:	e0bffc17 	ldw	r2,-16(fp)
  4739f4:	10c00017 	ldw	r3,0(r2)
  4739f8:	e0bffd17 	ldw	r2,-12(fp)
  4739fc:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
  473a00:	e0bffc17 	ldw	r2,-16(fp)
  473a04:	10800017 	ldw	r2,0(r2)
  473a08:	e0fffd17 	ldw	r3,-12(fp)
  473a0c:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
  473a10:	e0bffc17 	ldw	r2,-16(fp)
  473a14:	e0fffd17 	ldw	r3,-12(fp)
  473a18:	10c00015 	stw	r3,0(r2)

  return 0;  
  473a1c:	0005883a 	mov	r2,zero
}
  473a20:	e037883a 	mov	sp,fp
  473a24:	dfc00117 	ldw	ra,4(sp)
  473a28:	df000017 	ldw	fp,0(sp)
  473a2c:	dec00204 	addi	sp,sp,8
  473a30:	f800283a 	ret

00473a34 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
  473a34:	defffd04 	addi	sp,sp,-12
  473a38:	dfc00215 	stw	ra,8(sp)
  473a3c:	df000115 	stw	fp,4(sp)
  473a40:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
  473a44:	008011f4 	movhi	r2,71
  473a48:	1097f004 	addi	r2,r2,24512
  473a4c:	e0bfff15 	stw	r2,-4(fp)
  473a50:	00000606 	br	473a6c <_do_ctors+0x38>
        (*ctor) (); 
  473a54:	e0bfff17 	ldw	r2,-4(fp)
  473a58:	10800017 	ldw	r2,0(r2)
  473a5c:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
  473a60:	e0bfff17 	ldw	r2,-4(fp)
  473a64:	10bfff04 	addi	r2,r2,-4
  473a68:	e0bfff15 	stw	r2,-4(fp)
  473a6c:	e0ffff17 	ldw	r3,-4(fp)
  473a70:	008011f4 	movhi	r2,71
  473a74:	1097f104 	addi	r2,r2,24516
  473a78:	18bff62e 	bgeu	r3,r2,473a54 <_do_ctors+0x20>
        (*ctor) (); 
}
  473a7c:	e037883a 	mov	sp,fp
  473a80:	dfc00117 	ldw	ra,4(sp)
  473a84:	df000017 	ldw	fp,0(sp)
  473a88:	dec00204 	addi	sp,sp,8
  473a8c:	f800283a 	ret

00473a90 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
  473a90:	defffd04 	addi	sp,sp,-12
  473a94:	dfc00215 	stw	ra,8(sp)
  473a98:	df000115 	stw	fp,4(sp)
  473a9c:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
  473aa0:	008011f4 	movhi	r2,71
  473aa4:	1097f004 	addi	r2,r2,24512
  473aa8:	e0bfff15 	stw	r2,-4(fp)
  473aac:	00000606 	br	473ac8 <_do_dtors+0x38>
        (*dtor) (); 
  473ab0:	e0bfff17 	ldw	r2,-4(fp)
  473ab4:	10800017 	ldw	r2,0(r2)
  473ab8:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
  473abc:	e0bfff17 	ldw	r2,-4(fp)
  473ac0:	10bfff04 	addi	r2,r2,-4
  473ac4:	e0bfff15 	stw	r2,-4(fp)
  473ac8:	e0ffff17 	ldw	r3,-4(fp)
  473acc:	008011f4 	movhi	r2,71
  473ad0:	1097f104 	addi	r2,r2,24516
  473ad4:	18bff62e 	bgeu	r3,r2,473ab0 <_do_dtors+0x20>
        (*dtor) (); 
}
  473ad8:	e037883a 	mov	sp,fp
  473adc:	dfc00117 	ldw	ra,4(sp)
  473ae0:	df000017 	ldw	fp,0(sp)
  473ae4:	dec00204 	addi	sp,sp,8
  473ae8:	f800283a 	ret

00473aec <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
  473aec:	defffa04 	addi	sp,sp,-24
  473af0:	dfc00515 	stw	ra,20(sp)
  473af4:	df000415 	stw	fp,16(sp)
  473af8:	df000404 	addi	fp,sp,16
  473afc:	e13ffe15 	stw	r4,-8(fp)
  473b00:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
  473b04:	e0bfff17 	ldw	r2,-4(fp)
  473b08:	10800017 	ldw	r2,0(r2)
  473b0c:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
  473b10:	e13ffe17 	ldw	r4,-8(fp)
  473b14:	0464b6c0 	call	464b6c <strlen>
  473b18:	10800044 	addi	r2,r2,1
  473b1c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  473b20:	00000d06 	br	473b58 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
  473b24:	e0bffc17 	ldw	r2,-16(fp)
  473b28:	10c00217 	ldw	r3,8(r2)
  473b2c:	e0bffd17 	ldw	r2,-12(fp)
  473b30:	1809883a 	mov	r4,r3
  473b34:	e17ffe17 	ldw	r5,-8(fp)
  473b38:	100d883a 	mov	r6,r2
  473b3c:	04749500 	call	474950 <memcmp>
  473b40:	1000021e 	bne	r2,zero,473b4c <alt_find_dev+0x60>
    {
      /* match found */

      return next;
  473b44:	e0bffc17 	ldw	r2,-16(fp)
  473b48:	00000706 	br	473b68 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
  473b4c:	e0bffc17 	ldw	r2,-16(fp)
  473b50:	10800017 	ldw	r2,0(r2)
  473b54:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  473b58:	e0fffc17 	ldw	r3,-16(fp)
  473b5c:	e0bfff17 	ldw	r2,-4(fp)
  473b60:	18bff01e 	bne	r3,r2,473b24 <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
  473b64:	0005883a 	mov	r2,zero
}
  473b68:	e037883a 	mov	sp,fp
  473b6c:	dfc00117 	ldw	ra,4(sp)
  473b70:	df000017 	ldw	fp,0(sp)
  473b74:	dec00204 	addi	sp,sp,8
  473b78:	f800283a 	ret

00473b7c <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
  473b7c:	defffe04 	addi	sp,sp,-8
  473b80:	dfc00115 	stw	ra,4(sp)
  473b84:	df000015 	stw	fp,0(sp)
  473b88:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
  473b8c:	0009883a 	mov	r4,zero
  473b90:	01410004 	movi	r5,1024
  473b94:	04748780 	call	474878 <alt_icache_flush>
#endif
}
  473b98:	e037883a 	mov	sp,fp
  473b9c:	dfc00117 	ldw	ra,4(sp)
  473ba0:	df000017 	ldw	fp,0(sp)
  473ba4:	dec00204 	addi	sp,sp,8
  473ba8:	f800283a 	ret

00473bac <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
  473bac:	defff804 	addi	sp,sp,-32
  473bb0:	dfc00715 	stw	ra,28(sp)
  473bb4:	df000615 	stw	fp,24(sp)
  473bb8:	dc000515 	stw	r16,20(sp)
  473bbc:	df000504 	addi	fp,sp,20
  473bc0:	e13ffc15 	stw	r4,-16(fp)
  473bc4:	e17ffd15 	stw	r5,-12(fp)
  473bc8:	e1bffe15 	stw	r6,-8(fp)
  473bcc:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
  473bd0:	e13ffd17 	ldw	r4,-12(fp)
  473bd4:	e17ffe17 	ldw	r5,-8(fp)
  473bd8:	e1bfff17 	ldw	r6,-4(fp)
  473bdc:	0473e440 	call	473e44 <open>
  473be0:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
  473be4:	e0bffb17 	ldw	r2,-20(fp)
  473be8:	10002216 	blt	r2,zero,473c74 <alt_open_fd+0xc8>
  {
    fd->dev      = alt_fd_list[old].dev;
  473bec:	040011f4 	movhi	r16,71
  473bf0:	841ab304 	addi	r16,r16,27340
  473bf4:	e0bffb17 	ldw	r2,-20(fp)
  473bf8:	1009883a 	mov	r4,r2
  473bfc:	01400304 	movi	r5,12
  473c00:	04675f00 	call	4675f0 <__mulsi3>
  473c04:	8085883a 	add	r2,r16,r2
  473c08:	10c00017 	ldw	r3,0(r2)
  473c0c:	e0bffc17 	ldw	r2,-16(fp)
  473c10:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
  473c14:	040011f4 	movhi	r16,71
  473c18:	841ab304 	addi	r16,r16,27340
  473c1c:	e0bffb17 	ldw	r2,-20(fp)
  473c20:	1009883a 	mov	r4,r2
  473c24:	01400304 	movi	r5,12
  473c28:	04675f00 	call	4675f0 <__mulsi3>
  473c2c:	8085883a 	add	r2,r16,r2
  473c30:	10800104 	addi	r2,r2,4
  473c34:	10c00017 	ldw	r3,0(r2)
  473c38:	e0bffc17 	ldw	r2,-16(fp)
  473c3c:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
  473c40:	040011f4 	movhi	r16,71
  473c44:	841ab304 	addi	r16,r16,27340
  473c48:	e0bffb17 	ldw	r2,-20(fp)
  473c4c:	1009883a 	mov	r4,r2
  473c50:	01400304 	movi	r5,12
  473c54:	04675f00 	call	4675f0 <__mulsi3>
  473c58:	8085883a 	add	r2,r16,r2
  473c5c:	10800204 	addi	r2,r2,8
  473c60:	10c00017 	ldw	r3,0(r2)
  473c64:	e0bffc17 	ldw	r2,-16(fp)
  473c68:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
  473c6c:	e13ffb17 	ldw	r4,-20(fp)
  473c70:	04680c00 	call	4680c0 <alt_release_fd>
  }
} 
  473c74:	e037883a 	mov	sp,fp
  473c78:	dfc00217 	ldw	ra,8(sp)
  473c7c:	df000117 	ldw	fp,4(sp)
  473c80:	dc000017 	ldw	r16,0(sp)
  473c84:	dec00304 	addi	sp,sp,12
  473c88:	f800283a 	ret

00473c8c <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
  473c8c:	defffb04 	addi	sp,sp,-20
  473c90:	dfc00415 	stw	ra,16(sp)
  473c94:	df000315 	stw	fp,12(sp)
  473c98:	df000304 	addi	fp,sp,12
  473c9c:	e13ffd15 	stw	r4,-12(fp)
  473ca0:	e17ffe15 	stw	r5,-8(fp)
  473ca4:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
  473ca8:	010011f4 	movhi	r4,71
  473cac:	211ab604 	addi	r4,r4,27352
  473cb0:	e17ffd17 	ldw	r5,-12(fp)
  473cb4:	01800044 	movi	r6,1
  473cb8:	01c07fc4 	movi	r7,511
  473cbc:	0473bac0 	call	473bac <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
  473cc0:	010011f4 	movhi	r4,71
  473cc4:	211ab304 	addi	r4,r4,27340
  473cc8:	e17ffe17 	ldw	r5,-8(fp)
  473ccc:	000d883a 	mov	r6,zero
  473cd0:	01c07fc4 	movi	r7,511
  473cd4:	0473bac0 	call	473bac <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
  473cd8:	010011f4 	movhi	r4,71
  473cdc:	211ab904 	addi	r4,r4,27364
  473ce0:	e17fff17 	ldw	r5,-4(fp)
  473ce4:	01800044 	movi	r6,1
  473ce8:	01c07fc4 	movi	r7,511
  473cec:	0473bac0 	call	473bac <alt_open_fd>
}  
  473cf0:	e037883a 	mov	sp,fp
  473cf4:	dfc00117 	ldw	ra,4(sp)
  473cf8:	df000017 	ldw	fp,0(sp)
  473cfc:	dec00204 	addi	sp,sp,8
  473d00:	f800283a 	ret

00473d04 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  473d04:	defffe04 	addi	sp,sp,-8
  473d08:	dfc00115 	stw	ra,4(sp)
  473d0c:	df000015 	stw	fp,0(sp)
  473d10:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  473d14:	008011f4 	movhi	r2,71
  473d18:	109f4204 	addi	r2,r2,32008
  473d1c:	10800017 	ldw	r2,0(r2)
  473d20:	10000526 	beq	r2,zero,473d38 <alt_get_errno+0x34>
  473d24:	008011f4 	movhi	r2,71
  473d28:	109f4204 	addi	r2,r2,32008
  473d2c:	10800017 	ldw	r2,0(r2)
  473d30:	103ee83a 	callr	r2
  473d34:	00000206 	br	473d40 <alt_get_errno+0x3c>
  473d38:	00801234 	movhi	r2,72
  473d3c:	10a63404 	addi	r2,r2,-26416
}
  473d40:	e037883a 	mov	sp,fp
  473d44:	dfc00117 	ldw	ra,4(sp)
  473d48:	df000017 	ldw	fp,0(sp)
  473d4c:	dec00204 	addi	sp,sp,8
  473d50:	f800283a 	ret

00473d54 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
  473d54:	defffb04 	addi	sp,sp,-20
  473d58:	dfc00415 	stw	ra,16(sp)
  473d5c:	df000315 	stw	fp,12(sp)
  473d60:	dc000215 	stw	r16,8(sp)
  473d64:	df000204 	addi	fp,sp,8
  473d68:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
  473d6c:	e0bfff17 	ldw	r2,-4(fp)
  473d70:	10800217 	ldw	r2,8(r2)
  473d74:	10d00034 	orhi	r3,r2,16384
  473d78:	e0bfff17 	ldw	r2,-4(fp)
  473d7c:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  473d80:	e03ffe15 	stw	zero,-8(fp)
  473d84:	00002206 	br	473e10 <alt_file_locked+0xbc>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
  473d88:	040011f4 	movhi	r16,71
  473d8c:	841ab304 	addi	r16,r16,27340
  473d90:	e0bffe17 	ldw	r2,-8(fp)
  473d94:	1009883a 	mov	r4,r2
  473d98:	01400304 	movi	r5,12
  473d9c:	04675f00 	call	4675f0 <__mulsi3>
  473da0:	8085883a 	add	r2,r16,r2
  473da4:	10c00017 	ldw	r3,0(r2)
  473da8:	e0bfff17 	ldw	r2,-4(fp)
  473dac:	10800017 	ldw	r2,0(r2)
  473db0:	1880141e 	bne	r3,r2,473e04 <alt_file_locked+0xb0>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
  473db4:	040011f4 	movhi	r16,71
  473db8:	841ab304 	addi	r16,r16,27340
  473dbc:	e0bffe17 	ldw	r2,-8(fp)
  473dc0:	1009883a 	mov	r4,r2
  473dc4:	01400304 	movi	r5,12
  473dc8:	04675f00 	call	4675f0 <__mulsi3>
  473dcc:	8085883a 	add	r2,r16,r2
  473dd0:	10800204 	addi	r2,r2,8
  473dd4:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
  473dd8:	10000a0e 	bge	r2,zero,473e04 <alt_file_locked+0xb0>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
  473ddc:	e13ffe17 	ldw	r4,-8(fp)
  473de0:	01400304 	movi	r5,12
  473de4:	04675f00 	call	4675f0 <__mulsi3>
  473de8:	00c011f4 	movhi	r3,71
  473dec:	18dab304 	addi	r3,r3,27340
  473df0:	10c7883a 	add	r3,r2,r3
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
  473df4:	e0bfff17 	ldw	r2,-4(fp)
  473df8:	18800226 	beq	r3,r2,473e04 <alt_file_locked+0xb0>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
  473dfc:	00bffcc4 	movi	r2,-13
  473e00:	00000a06 	br	473e2c <alt_file_locked+0xd8>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  473e04:	e0bffe17 	ldw	r2,-8(fp)
  473e08:	10800044 	addi	r2,r2,1
  473e0c:	e0bffe15 	stw	r2,-8(fp)
  473e10:	008011f4 	movhi	r2,71
  473e14:	109f4104 	addi	r2,r2,32004
  473e18:	10800017 	ldw	r2,0(r2)
  473e1c:	1007883a 	mov	r3,r2
  473e20:	e0bffe17 	ldw	r2,-8(fp)
  473e24:	18bfd82e 	bgeu	r3,r2,473d88 <alt_file_locked+0x34>
    }
  }
  
  /* The device is not locked */
 
  return 0;
  473e28:	0005883a 	mov	r2,zero
}
  473e2c:	e037883a 	mov	sp,fp
  473e30:	dfc00217 	ldw	ra,8(sp)
  473e34:	df000117 	ldw	fp,4(sp)
  473e38:	dc000017 	ldw	r16,0(sp)
  473e3c:	dec00304 	addi	sp,sp,12
  473e40:	f800283a 	ret

00473e44 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
  473e44:	defff604 	addi	sp,sp,-40
  473e48:	dfc00915 	stw	ra,36(sp)
  473e4c:	df000815 	stw	fp,32(sp)
  473e50:	df000804 	addi	fp,sp,32
  473e54:	e13ffd15 	stw	r4,-12(fp)
  473e58:	e17ffe15 	stw	r5,-8(fp)
  473e5c:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
  473e60:	00bfffc4 	movi	r2,-1
  473e64:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
  473e68:	00bffb44 	movi	r2,-19
  473e6c:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
  473e70:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
  473e74:	e13ffd17 	ldw	r4,-12(fp)
  473e78:	014011f4 	movhi	r5,71
  473e7c:	295f3f04 	addi	r5,r5,31996
  473e80:	0473aec0 	call	473aec <alt_find_dev>
  473e84:	e0bff815 	stw	r2,-32(fp)
  473e88:	e0bff817 	ldw	r2,-32(fp)
  473e8c:	1000051e 	bne	r2,zero,473ea4 <open+0x60>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
  473e90:	e13ffd17 	ldw	r4,-12(fp)
  473e94:	04746500 	call	474650 <alt_find_file>
  473e98:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
  473e9c:	00800044 	movi	r2,1
  473ea0:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
  473ea4:	e0bff817 	ldw	r2,-32(fp)
  473ea8:	10002a26 	beq	r2,zero,473f54 <open+0x110>
  {
    if ((index = alt_get_fd (dev)) < 0)
  473eac:	e13ff817 	ldw	r4,-32(fp)
  473eb0:	04747640 	call	474764 <alt_get_fd>
  473eb4:	e0bff915 	stw	r2,-28(fp)
  473eb8:	e0bff917 	ldw	r2,-28(fp)
  473ebc:	1000030e 	bge	r2,zero,473ecc <open+0x88>
    {
      status = index;
  473ec0:	e0bff917 	ldw	r2,-28(fp)
  473ec4:	e0bffa15 	stw	r2,-24(fp)
  473ec8:	00002406 	br	473f5c <open+0x118>
    }
    else
    {
      fd = &alt_fd_list[index];
  473ecc:	e13ff917 	ldw	r4,-28(fp)
  473ed0:	01400304 	movi	r5,12
  473ed4:	04675f00 	call	4675f0 <__mulsi3>
  473ed8:	00c011f4 	movhi	r3,71
  473edc:	18dab304 	addi	r3,r3,27340
  473ee0:	10c5883a 	add	r2,r2,r3
  473ee4:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
  473ee8:	e0fffe17 	ldw	r3,-8(fp)
  473eec:	00900034 	movhi	r2,16384
  473ef0:	10bfffc4 	addi	r2,r2,-1
  473ef4:	1886703a 	and	r3,r3,r2
  473ef8:	e0bffc17 	ldw	r2,-16(fp)
  473efc:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
  473f00:	e0bffb17 	ldw	r2,-20(fp)
  473f04:	1000051e 	bne	r2,zero,473f1c <open+0xd8>
  473f08:	e13ffc17 	ldw	r4,-16(fp)
  473f0c:	0473d540 	call	473d54 <alt_file_locked>
  473f10:	e0bffa15 	stw	r2,-24(fp)
  473f14:	e0bffa17 	ldw	r2,-24(fp)
  473f18:	10001016 	blt	r2,zero,473f5c <open+0x118>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
  473f1c:	e0bff817 	ldw	r2,-32(fp)
  473f20:	10800317 	ldw	r2,12(r2)
  473f24:	10000826 	beq	r2,zero,473f48 <open+0x104>
  473f28:	e0bff817 	ldw	r2,-32(fp)
  473f2c:	10800317 	ldw	r2,12(r2)
  473f30:	e13ffc17 	ldw	r4,-16(fp)
  473f34:	e17ffd17 	ldw	r5,-12(fp)
  473f38:	e1bffe17 	ldw	r6,-8(fp)
  473f3c:	e1ffff17 	ldw	r7,-4(fp)
  473f40:	103ee83a 	callr	r2
  473f44:	00000106 	br	473f4c <open+0x108>
  473f48:	0005883a 	mov	r2,zero
  473f4c:	e0bffa15 	stw	r2,-24(fp)
  473f50:	00000206 	br	473f5c <open+0x118>
      }
    }
  }
  else
  {
    status = -ENODEV;
  473f54:	00bffb44 	movi	r2,-19
  473f58:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
  473f5c:	e0bffa17 	ldw	r2,-24(fp)
  473f60:	1000080e 	bge	r2,zero,473f84 <open+0x140>
  {
    alt_release_fd (index);  
  473f64:	e13ff917 	ldw	r4,-28(fp)
  473f68:	04680c00 	call	4680c0 <alt_release_fd>
    ALT_ERRNO = -status;
  473f6c:	0473d040 	call	473d04 <alt_get_errno>
  473f70:	e0fffa17 	ldw	r3,-24(fp)
  473f74:	00c7c83a 	sub	r3,zero,r3
  473f78:	10c00015 	stw	r3,0(r2)
    return -1;
  473f7c:	00bfffc4 	movi	r2,-1
  473f80:	00000106 	br	473f88 <open+0x144>
  }
  
  /* return the reference upon success */

  return index;
  473f84:	e0bff917 	ldw	r2,-28(fp)
}
  473f88:	e037883a 	mov	sp,fp
  473f8c:	dfc00117 	ldw	ra,4(sp)
  473f90:	df000017 	ldw	fp,0(sp)
  473f94:	dec00204 	addi	sp,sp,8
  473f98:	f800283a 	ret

00473f9c <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
  473f9c:	defff904 	addi	sp,sp,-28
  473fa0:	df000615 	stw	fp,24(sp)
  473fa4:	df000604 	addi	fp,sp,24
  473fa8:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  473fac:	0005303a 	rdctl	r2,status
  473fb0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  473fb4:	e0fffb17 	ldw	r3,-20(fp)
  473fb8:	00bfff84 	movi	r2,-2
  473fbc:	1884703a 	and	r2,r3,r2
  473fc0:	1001703a 	wrctl	status,r2
  
  return context;
  473fc4:	e0bffb17 	ldw	r2,-20(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
  473fc8:	e0bffa15 	stw	r2,-24(fp)
  alt_llist_remove (&alarm->llist);
  473fcc:	e0bfff17 	ldw	r2,-4(fp)
  473fd0:	e0bffc15 	stw	r2,-16(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
  473fd4:	e0bffc17 	ldw	r2,-16(fp)
  473fd8:	10800017 	ldw	r2,0(r2)
  473fdc:	e0fffc17 	ldw	r3,-16(fp)
  473fe0:	18c00117 	ldw	r3,4(r3)
  473fe4:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
  473fe8:	e0bffc17 	ldw	r2,-16(fp)
  473fec:	10800117 	ldw	r2,4(r2)
  473ff0:	e0fffc17 	ldw	r3,-16(fp)
  473ff4:	18c00017 	ldw	r3,0(r3)
  473ff8:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
  473ffc:	e0bffc17 	ldw	r2,-16(fp)
  474000:	e0fffc17 	ldw	r3,-16(fp)
  474004:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
  474008:	e0bffc17 	ldw	r2,-16(fp)
  47400c:	e0fffc17 	ldw	r3,-16(fp)
  474010:	10c00015 	stw	r3,0(r2)
  474014:	e0bffa17 	ldw	r2,-24(fp)
  474018:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
  47401c:	0005303a 	rdctl	r2,status
  474020:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
  474024:	e0fffe17 	ldw	r3,-8(fp)
  474028:	00bfff84 	movi	r2,-2
  47402c:	1884703a 	and	r2,r3,r2
  474030:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
  474034:	e0bffd17 	ldw	r2,-12(fp)
  474038:	1080004c 	andi	r2,r2,1
  47403c:	e0fffe17 	ldw	r3,-8(fp)
  474040:	1884b03a 	or	r2,r3,r2
  474044:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
  474048:	e0bffe17 	ldw	r2,-8(fp)
  47404c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
  474050:	e037883a 	mov	sp,fp
  474054:	df000017 	ldw	fp,0(sp)
  474058:	dec00104 	addi	sp,sp,4
  47405c:	f800283a 	ret

00474060 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
  474060:	defffb04 	addi	sp,sp,-20
  474064:	dfc00415 	stw	ra,16(sp)
  474068:	df000315 	stw	fp,12(sp)
  47406c:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
  474070:	d0a03317 	ldw	r2,-32564(gp)
  474074:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
  474078:	d0a72217 	ldw	r2,-25464(gp)
  47407c:	10800044 	addi	r2,r2,1
  474080:	d0a72215 	stw	r2,-25464(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  474084:	00002e06 	br	474140 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
  474088:	e0bffd17 	ldw	r2,-12(fp)
  47408c:	10800017 	ldw	r2,0(r2)
  474090:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
  474094:	e0bffd17 	ldw	r2,-12(fp)
  474098:	10800403 	ldbu	r2,16(r2)
  47409c:	10803fcc 	andi	r2,r2,255
  4740a0:	10000426 	beq	r2,zero,4740b4 <alt_tick+0x54>
  4740a4:	d0a72217 	ldw	r2,-25464(gp)
  4740a8:	1000021e 	bne	r2,zero,4740b4 <alt_tick+0x54>
    {
      alarm->rollover = 0;
  4740ac:	e0bffd17 	ldw	r2,-12(fp)
  4740b0:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
  4740b4:	e0bffd17 	ldw	r2,-12(fp)
  4740b8:	10800217 	ldw	r2,8(r2)
  4740bc:	d0e72217 	ldw	r3,-25464(gp)
  4740c0:	18801d36 	bltu	r3,r2,474138 <alt_tick+0xd8>
  4740c4:	e0bffd17 	ldw	r2,-12(fp)
  4740c8:	10800403 	ldbu	r2,16(r2)
  4740cc:	10803fcc 	andi	r2,r2,255
  4740d0:	1000191e 	bne	r2,zero,474138 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
  4740d4:	e0bffd17 	ldw	r2,-12(fp)
  4740d8:	10c00317 	ldw	r3,12(r2)
  4740dc:	e0bffd17 	ldw	r2,-12(fp)
  4740e0:	10800517 	ldw	r2,20(r2)
  4740e4:	1009883a 	mov	r4,r2
  4740e8:	183ee83a 	callr	r3
  4740ec:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
  4740f0:	e0bfff17 	ldw	r2,-4(fp)
  4740f4:	1000031e 	bne	r2,zero,474104 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
  4740f8:	e13ffd17 	ldw	r4,-12(fp)
  4740fc:	0473f9c0 	call	473f9c <alt_alarm_stop>
  474100:	00000d06 	br	474138 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
  474104:	e0bffd17 	ldw	r2,-12(fp)
  474108:	10c00217 	ldw	r3,8(r2)
  47410c:	e0bfff17 	ldw	r2,-4(fp)
  474110:	1887883a 	add	r3,r3,r2
  474114:	e0bffd17 	ldw	r2,-12(fp)
  474118:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
  47411c:	e0bffd17 	ldw	r2,-12(fp)
  474120:	10c00217 	ldw	r3,8(r2)
  474124:	d0a72217 	ldw	r2,-25464(gp)
  474128:	1880032e 	bgeu	r3,r2,474138 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
  47412c:	e0bffd17 	ldw	r2,-12(fp)
  474130:	00c00044 	movi	r3,1
  474134:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
  474138:	e0bffe17 	ldw	r2,-8(fp)
  47413c:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  474140:	e0fffd17 	ldw	r3,-12(fp)
  474144:	d0a03304 	addi	r2,gp,-32564
  474148:	18bfcf1e 	bne	r3,r2,474088 <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
  47414c:	04697c80 	call	4697c8 <OSTimeTick>
}
  474150:	e037883a 	mov	sp,fp
  474154:	dfc00117 	ldw	ra,4(sp)
  474158:	df000017 	ldw	fp,0(sp)
  47415c:	dec00204 	addi	sp,sp,8
  474160:	f800283a 	ret

00474164 <altera_nios2_qsys_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
  474164:	deffff04 	addi	sp,sp,-4
  474168:	df000015 	stw	fp,0(sp)
  47416c:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
  474170:	000170fa 	wrctl	ienable,zero
}
  474174:	e037883a 	mov	sp,fp
  474178:	df000017 	ldw	fp,0(sp)
  47417c:	dec00104 	addi	sp,sp,4
  474180:	f800283a 	ret

00474184 <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
  474184:	defff504 	addi	sp,sp,-44
      bltu  sp, et, .Lstack_overflow

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
  474188:	d0e00717 	ldw	r3,-32740(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
  47418c:	d1271a17 	ldw	r4,-25496(gp)

      stw ra,  0(sp)
  474190:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
  474194:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
  474198:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
  47419c:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
  4741a0:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
  4741a4:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
  4741a8:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
  4741ac:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
  4741b0:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
  4741b4:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
  4741b8:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
  4741bc:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
  4741c0:	04745880 	call	474588 <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
  4741c4:	d1271517 	ldw	r4,-25516(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
  4741c8:	d1670d07 	ldb	r5,-25548(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
  4741cc:	d1271a15 	stw	r4,-25496(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
  4741d0:	d1670d45 	stb	r5,-25547(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
  4741d4:	26c00017 	ldw	sp,0(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
  4741d8:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
  4741dc:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
  4741e0:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
  4741e4:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
  4741e8:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
  4741ec:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
  4741f0:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
  4741f4:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
  4741f8:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
  4741fc:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
  474200:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
  474204:	d0e00715 	stw	r3,-32740(gp)

      stw et, %gprel(alt_stack_limit_value)(gp)

#endif

      addi sp, sp, 44
  474208:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
  47420c:	f800283a 	ret

00474210 <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
  474210:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
  474214:	047fff84 	movi	r17,-2
      and   r18, r18, r17
  474218:	9464703a 	and	r18,r18,r17
      wrctl status, r18
  47421c:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
  474220:	04745880 	call	474588 <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
  474224:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
  474228:	d4a70b45 	stb	r18,-25555(gp)

      /*
       * start execution of the new task.
       */

      br 9b
  47422c:	003fe506 	br	4741c4 <OSCtxSw+0x40>

00474230 <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
  474230:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
  474234:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
  474238:	10800054 	ori	r2,r2,1
      wrctl status, r2
  47423c:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
  474240:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
  474244:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
  474248:	dec00204 	addi	sp,sp,8

      callr r2
  47424c:	103ee83a 	callr	r2

      nop
  474250:	0001883a 	nop

00474254 <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
  474254:	defff704 	addi	sp,sp,-36
  474258:	dfc00815 	stw	ra,32(sp)
  47425c:	df000715 	stw	fp,28(sp)
  474260:	df000704 	addi	fp,sp,28
  474264:	e13ffc15 	stw	r4,-16(fp)
  474268:	e17ffd15 	stw	r5,-12(fp)
  47426c:	e1bffe15 	stw	r6,-8(fp)
  474270:	3805883a 	mov	r2,r7
  474274:	e0bfff0d 	sth	r2,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
  474278:	e0fffe17 	ldw	r3,-8(fp)
  47427c:	00bfff04 	movi	r2,-4
  474280:	1884703a 	and	r2,r3,r2
  474284:	10bf0004 	addi	r2,r2,-1024
  474288:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
  47428c:	e0bff917 	ldw	r2,-28(fp)
  474290:	10000015 	stw	zero,0(r2)
  474294:	e0bff917 	ldw	r2,-28(fp)
  474298:	10c0bb04 	addi	r3,r2,748
  47429c:	e0bff917 	ldw	r2,-28(fp)
  4742a0:	10c00115 	stw	r3,4(r2)
  4742a4:	e0bff917 	ldw	r2,-28(fp)
  4742a8:	10c0d204 	addi	r3,r2,840
  4742ac:	e0bff917 	ldw	r2,-28(fp)
  4742b0:	10c00215 	stw	r3,8(r2)
  4742b4:	e0bff917 	ldw	r2,-28(fp)
  4742b8:	10c0e904 	addi	r3,r2,932
  4742bc:	e0bff917 	ldw	r2,-28(fp)
  4742c0:	10c00315 	stw	r3,12(r2)
  4742c4:	e0bff917 	ldw	r2,-28(fp)
  4742c8:	10000415 	stw	zero,16(r2)
  4742cc:	e0bff917 	ldw	r2,-28(fp)
  4742d0:	10800504 	addi	r2,r2,20
  4742d4:	1009883a 	mov	r4,r2
  4742d8:	000b883a 	mov	r5,zero
  4742dc:	01800644 	movi	r6,25
  4742e0:	04670100 	call	467010 <memset>
  4742e4:	e0bff917 	ldw	r2,-28(fp)
  4742e8:	10000c15 	stw	zero,48(r2)
  4742ec:	e0bff917 	ldw	r2,-28(fp)
  4742f0:	00c011f4 	movhi	r3,71
  4742f4:	18d86104 	addi	r3,r3,24964
  4742f8:	10c00d15 	stw	r3,52(r2)
  4742fc:	e0bff917 	ldw	r2,-28(fp)
  474300:	10000e15 	stw	zero,56(r2)
  474304:	e0bff917 	ldw	r2,-28(fp)
  474308:	10000f15 	stw	zero,60(r2)
  47430c:	e0bff917 	ldw	r2,-28(fp)
  474310:	10001015 	stw	zero,64(r2)
  474314:	e0bff917 	ldw	r2,-28(fp)
  474318:	10001115 	stw	zero,68(r2)
  47431c:	e0bff917 	ldw	r2,-28(fp)
  474320:	10001215 	stw	zero,72(r2)
  474324:	e0bff917 	ldw	r2,-28(fp)
  474328:	10001315 	stw	zero,76(r2)
  47432c:	e0bff917 	ldw	r2,-28(fp)
  474330:	10001415 	stw	zero,80(r2)
  474334:	e0bff917 	ldw	r2,-28(fp)
  474338:	10001515 	stw	zero,84(r2)
  47433c:	e0bff917 	ldw	r2,-28(fp)
  474340:	10001615 	stw	zero,88(r2)
  474344:	e0bff917 	ldw	r2,-28(fp)
  474348:	10001715 	stw	zero,92(r2)
  47434c:	e0bff917 	ldw	r2,-28(fp)
  474350:	10001805 	stb	zero,96(r2)
  474354:	e0bff917 	ldw	r2,-28(fp)
  474358:	10801f04 	addi	r2,r2,124
  47435c:	1009883a 	mov	r4,r2
  474360:	000b883a 	mov	r5,zero
  474364:	01800904 	movi	r6,36
  474368:	04670100 	call	467010 <memset>
  47436c:	e0bff917 	ldw	r2,-28(fp)
  474370:	10002815 	stw	zero,160(r2)
  474374:	e0bff917 	ldw	r2,-28(fp)
  474378:	00c00044 	movi	r3,1
  47437c:	10c02915 	stw	r3,164(r2)
  474380:	10002a15 	stw	zero,168(r2)
  474384:	e0bff917 	ldw	r2,-28(fp)
  474388:	00ccc384 	movi	r3,13070
  47438c:	10c02b0d 	sth	r3,172(r2)
  474390:	e0bff917 	ldw	r2,-28(fp)
  474394:	00eaf344 	movi	r3,-21555
  474398:	10c02b8d 	sth	r3,174(r2)
  47439c:	e0bff917 	ldw	r2,-28(fp)
  4743a0:	00c48d04 	movi	r3,4660
  4743a4:	10c02c0d 	sth	r3,176(r2)
  4743a8:	e0bff917 	ldw	r2,-28(fp)
  4743ac:	00f99b44 	movi	r3,-6547
  4743b0:	10c02c8d 	sth	r3,178(r2)
  4743b4:	e0bff917 	ldw	r2,-28(fp)
  4743b8:	00f7bb04 	movi	r3,-8468
  4743bc:	10c02d0d 	sth	r3,180(r2)
  4743c0:	e0bff917 	ldw	r2,-28(fp)
  4743c4:	00c00144 	movi	r3,5
  4743c8:	10c02d8d 	sth	r3,182(r2)
  4743cc:	e0bff917 	ldw	r2,-28(fp)
  4743d0:	00c002c4 	movi	r3,11
  4743d4:	10c02e0d 	sth	r3,184(r2)
  4743d8:	e0bff917 	ldw	r2,-28(fp)
  4743dc:	10002f15 	stw	zero,188(r2)
  4743e0:	e0bff917 	ldw	r2,-28(fp)
  4743e4:	10003015 	stw	zero,192(r2)
  4743e8:	e0bff917 	ldw	r2,-28(fp)
  4743ec:	10003115 	stw	zero,196(r2)
  4743f0:	e0bff917 	ldw	r2,-28(fp)
  4743f4:	10003215 	stw	zero,200(r2)
  4743f8:	e0bff917 	ldw	r2,-28(fp)
  4743fc:	10003315 	stw	zero,204(r2)
  474400:	e0bff917 	ldw	r2,-28(fp)
  474404:	10003415 	stw	zero,208(r2)
  474408:	e0bff917 	ldw	r2,-28(fp)
  47440c:	10003e15 	stw	zero,248(r2)
  474410:	e0bff917 	ldw	r2,-28(fp)
  474414:	10003f15 	stw	zero,252(r2)
  474418:	e0bff917 	ldw	r2,-28(fp)
  47441c:	10004015 	stw	zero,256(r2)
  474420:	e0bff917 	ldw	r2,-28(fp)
  474424:	10004115 	stw	zero,260(r2)
  474428:	e0bff917 	ldw	r2,-28(fp)
  47442c:	10004215 	stw	zero,264(r2)
  474430:	e0bff917 	ldw	r2,-28(fp)
  474434:	10004315 	stw	zero,268(r2)
  474438:	e0bff917 	ldw	r2,-28(fp)
  47443c:	10004415 	stw	zero,272(r2)
  474440:	e0bff917 	ldw	r2,-28(fp)
  474444:	10004515 	stw	zero,276(r2)
  474448:	e0bff917 	ldw	r2,-28(fp)
  47444c:	10004615 	stw	zero,280(r2)
  474450:	e0bff917 	ldw	r2,-28(fp)
  474454:	10004715 	stw	zero,284(r2)
  474458:	e0bff917 	ldw	r2,-28(fp)
  47445c:	10003505 	stb	zero,212(r2)
  474460:	e0bff917 	ldw	r2,-28(fp)
  474464:	10003705 	stb	zero,220(r2)
  474468:	e0bff917 	ldw	r2,-28(fp)
  47446c:	10003d15 	stw	zero,244(r2)
  474470:	e0bff917 	ldw	r2,-28(fp)
  474474:	10005215 	stw	zero,328(r2)
  474478:	e0bff917 	ldw	r2,-28(fp)
  47447c:	10005315 	stw	zero,332(r2)
  474480:	e0bff917 	ldw	r2,-28(fp)
  474484:	10005415 	stw	zero,336(r2)
  474488:	e0bff917 	ldw	r2,-28(fp)
  47448c:	10005515 	stw	zero,340(r2)
  474490:	e0bff917 	ldw	r2,-28(fp)
  474494:	1000b515 	stw	zero,724(r2)
  474498:	e0bff917 	ldw	r2,-28(fp)
  47449c:	10007515 	stw	zero,468(r2)
  4744a0:	e0bff917 	ldw	r2,-28(fp)
  4744a4:	1000b715 	stw	zero,732(r2)
  4744a8:	e0bff917 	ldw	r2,-28(fp)
  4744ac:	1000b815 	stw	zero,736(r2)
  4744b0:	e0bff917 	ldw	r2,-28(fp)
  4744b4:	1000b915 	stw	zero,740(r2)
  4744b8:	e0bff917 	ldw	r2,-28(fp)
  4744bc:	1000ba15 	stw	zero,744(r2)
  4744c0:	e0bff917 	ldw	r2,-28(fp)
  4744c4:	1080bb04 	addi	r2,r2,748
  4744c8:	1009883a 	mov	r4,r2
  4744cc:	000b883a 	mov	r5,zero
  4744d0:	01804504 	movi	r6,276
  4744d4:	04670100 	call	467010 <memset>
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
  4744d8:	e0bff917 	ldw	r2,-28(fp)
  4744dc:	e0bffa15 	stw	r2,-24(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
  4744e0:	e0bffa17 	ldw	r2,-24(fp)
  4744e4:	10bff304 	addi	r2,r2,-52
  4744e8:	e0bffb15 	stw	r2,-20(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
  4744ec:	e0bffb17 	ldw	r2,-20(fp)
  4744f0:	10800c04 	addi	r2,r2,48
  4744f4:	e0fffc17 	ldw	r3,-16(fp)
  4744f8:	10c00015 	stw	r3,0(r2)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
  4744fc:	e0bffb17 	ldw	r2,-20(fp)
  474500:	10800b04 	addi	r2,r2,44
  474504:	e0fffd17 	ldw	r3,-12(fp)
  474508:	10c00015 	stw	r3,0(r2)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
  47450c:	e0bffb17 	ldw	r2,-20(fp)
  474510:	10800a04 	addi	r2,r2,40
  474514:	e0fff917 	ldw	r3,-28(fp)
  474518:	10c00015 	stw	r3,0(r2)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
  47451c:	008011f4 	movhi	r2,71
  474520:	10908c04 	addi	r2,r2,16944
  474524:	10c00104 	addi	r3,r2,4
  474528:	e0bffb17 	ldw	r2,-20(fp)
  47452c:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
  474530:	e0bffb17 	ldw	r2,-20(fp)
}
  474534:	e037883a 	mov	sp,fp
  474538:	dfc00117 	ldw	ra,4(sp)
  47453c:	df000017 	ldw	fp,0(sp)
  474540:	dec00204 	addi	sp,sp,8
  474544:	f800283a 	ret

00474548 <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
  474548:	defffe04 	addi	sp,sp,-8
  47454c:	df000115 	stw	fp,4(sp)
  474550:	df000104 	addi	fp,sp,4
  474554:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
  474558:	e037883a 	mov	sp,fp
  47455c:	df000017 	ldw	fp,0(sp)
  474560:	dec00104 	addi	sp,sp,4
  474564:	f800283a 	ret

00474568 <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
  474568:	defffe04 	addi	sp,sp,-8
  47456c:	df000115 	stw	fp,4(sp)
  474570:	df000104 	addi	fp,sp,4
  474574:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
  474578:	e037883a 	mov	sp,fp
  47457c:	df000017 	ldw	fp,0(sp)
  474580:	dec00104 	addi	sp,sp,4
  474584:	f800283a 	ret

00474588 <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
  474588:	deffff04 	addi	sp,sp,-4
  47458c:	df000015 	stw	fp,0(sp)
  474590:	d839883a 	mov	fp,sp
}
  474594:	e037883a 	mov	sp,fp
  474598:	df000017 	ldw	fp,0(sp)
  47459c:	dec00104 	addi	sp,sp,4
  4745a0:	f800283a 	ret

004745a4 <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
  4745a4:	deffff04 	addi	sp,sp,-4
  4745a8:	df000015 	stw	fp,0(sp)
  4745ac:	d839883a 	mov	fp,sp
}
  4745b0:	e037883a 	mov	sp,fp
  4745b4:	df000017 	ldw	fp,0(sp)
  4745b8:	dec00104 	addi	sp,sp,4
  4745bc:	f800283a 	ret

004745c0 <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
  4745c0:	deffff04 	addi	sp,sp,-4
  4745c4:	df000015 	stw	fp,0(sp)
  4745c8:	d839883a 	mov	fp,sp
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
#endif
}
  4745cc:	e037883a 	mov	sp,fp
  4745d0:	df000017 	ldw	fp,0(sp)
  4745d4:	dec00104 	addi	sp,sp,4
  4745d8:	f800283a 	ret

004745dc <OSInitHookBegin>:

void OSInitHookBegin(void)
{
  4745dc:	deffff04 	addi	sp,sp,-4
  4745e0:	df000015 	stw	fp,0(sp)
  4745e4:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
#endif
}
  4745e8:	e037883a 	mov	sp,fp
  4745ec:	df000017 	ldw	fp,0(sp)
  4745f0:	dec00104 	addi	sp,sp,4
  4745f4:	f800283a 	ret

004745f8 <OSInitHookEnd>:

void OSInitHookEnd(void)
{
  4745f8:	deffff04 	addi	sp,sp,-4
  4745fc:	df000015 	stw	fp,0(sp)
  474600:	d839883a 	mov	fp,sp
}
  474604:	e037883a 	mov	sp,fp
  474608:	df000017 	ldw	fp,0(sp)
  47460c:	dec00104 	addi	sp,sp,4
  474610:	f800283a 	ret

00474614 <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
  474614:	deffff04 	addi	sp,sp,-4
  474618:	df000015 	stw	fp,0(sp)
  47461c:	d839883a 	mov	fp,sp
}
  474620:	e037883a 	mov	sp,fp
  474624:	df000017 	ldw	fp,0(sp)
  474628:	dec00104 	addi	sp,sp,4
  47462c:	f800283a 	ret

00474630 <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
  474630:	defffe04 	addi	sp,sp,-8
  474634:	df000115 	stw	fp,4(sp)
  474638:	df000104 	addi	fp,sp,4
  47463c:	e13fff15 	stw	r4,-4(fp)
}
  474640:	e037883a 	mov	sp,fp
  474644:	df000017 	ldw	fp,0(sp)
  474648:	dec00104 	addi	sp,sp,4
  47464c:	f800283a 	ret

00474650 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
  474650:	defffb04 	addi	sp,sp,-20
  474654:	dfc00415 	stw	ra,16(sp)
  474658:	df000315 	stw	fp,12(sp)
  47465c:	df000304 	addi	fp,sp,12
  474660:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
  474664:	008011f4 	movhi	r2,71
  474668:	109f3d04 	addi	r2,r2,31988
  47466c:	10800017 	ldw	r2,0(r2)
  474670:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
  474674:	00003106 	br	47473c <alt_find_file+0xec>
  {
    len = strlen(next->name);
  474678:	e0bffd17 	ldw	r2,-12(fp)
  47467c:	10800217 	ldw	r2,8(r2)
  474680:	1009883a 	mov	r4,r2
  474684:	0464b6c0 	call	464b6c <strlen>
  474688:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
  47468c:	e0bffd17 	ldw	r2,-12(fp)
  474690:	10c00217 	ldw	r3,8(r2)
  474694:	e0bffe17 	ldw	r2,-8(fp)
  474698:	10bfffc4 	addi	r2,r2,-1
  47469c:	1885883a 	add	r2,r3,r2
  4746a0:	10800003 	ldbu	r2,0(r2)
  4746a4:	10803fcc 	andi	r2,r2,255
  4746a8:	1080201c 	xori	r2,r2,128
  4746ac:	10bfe004 	addi	r2,r2,-128
  4746b0:	10800bd8 	cmpnei	r2,r2,47
  4746b4:	1000031e 	bne	r2,zero,4746c4 <alt_find_file+0x74>
    {
      len -= 1;
  4746b8:	e0bffe17 	ldw	r2,-8(fp)
  4746bc:	10bfffc4 	addi	r2,r2,-1
  4746c0:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
  4746c4:	e0bffe17 	ldw	r2,-8(fp)
  4746c8:	e0ffff17 	ldw	r3,-4(fp)
  4746cc:	1885883a 	add	r2,r3,r2
  4746d0:	10800003 	ldbu	r2,0(r2)
  4746d4:	10803fcc 	andi	r2,r2,255
  4746d8:	1080201c 	xori	r2,r2,128
  4746dc:	10bfe004 	addi	r2,r2,-128
  4746e0:	10800be0 	cmpeqi	r2,r2,47
  4746e4:	1000081e 	bne	r2,zero,474708 <alt_find_file+0xb8>
  4746e8:	e0bffe17 	ldw	r2,-8(fp)
  4746ec:	e0ffff17 	ldw	r3,-4(fp)
  4746f0:	1885883a 	add	r2,r3,r2
  4746f4:	10800003 	ldbu	r2,0(r2)
  4746f8:	10803fcc 	andi	r2,r2,255
  4746fc:	1080201c 	xori	r2,r2,128
  474700:	10bfe004 	addi	r2,r2,-128
  474704:	10000a1e 	bne	r2,zero,474730 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
  474708:	e0bffd17 	ldw	r2,-12(fp)
  47470c:	10c00217 	ldw	r3,8(r2)
  474710:	e0bffe17 	ldw	r2,-8(fp)
  474714:	1809883a 	mov	r4,r3
  474718:	e17fff17 	ldw	r5,-4(fp)
  47471c:	100d883a 	mov	r6,r2
  474720:	04749500 	call	474950 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
  474724:	1000021e 	bne	r2,zero,474730 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
  474728:	e0bffd17 	ldw	r2,-12(fp)
  47472c:	00000806 	br	474750 <alt_find_file+0x100>
    }
    next = (alt_dev*) next->llist.next;
  474730:	e0bffd17 	ldw	r2,-12(fp)
  474734:	10800017 	ldw	r2,0(r2)
  474738:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
  47473c:	e0fffd17 	ldw	r3,-12(fp)
  474740:	008011f4 	movhi	r2,71
  474744:	109f3d04 	addi	r2,r2,31988
  474748:	18bfcb1e 	bne	r3,r2,474678 <alt_find_file+0x28>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
  47474c:	0005883a 	mov	r2,zero
}
  474750:	e037883a 	mov	sp,fp
  474754:	dfc00117 	ldw	ra,4(sp)
  474758:	df000017 	ldw	fp,0(sp)
  47475c:	dec00204 	addi	sp,sp,8
  474760:	f800283a 	ret

00474764 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
  474764:	defff804 	addi	sp,sp,-32
  474768:	dfc00715 	stw	ra,28(sp)
  47476c:	df000615 	stw	fp,24(sp)
  474770:	dc000515 	stw	r16,20(sp)
  474774:	df000504 	addi	fp,sp,20
  474778:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
  47477c:	00bffa04 	movi	r2,-24
  474780:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
  474784:	00801234 	movhi	r2,72
  474788:	10a63504 	addi	r2,r2,-26412
  47478c:	10800017 	ldw	r2,0(r2)
  474790:	e0bffd15 	stw	r2,-12(fp)
  474794:	e03ffe0d 	sth	zero,-8(fp)
  474798:	e0fffe0b 	ldhu	r3,-8(fp)
  47479c:	e0bffe84 	addi	r2,fp,-6
  4747a0:	e13ffd17 	ldw	r4,-12(fp)
  4747a4:	180b883a 	mov	r5,r3
  4747a8:	100d883a 	mov	r6,r2
  4747ac:	046f0900 	call	46f090 <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
  4747b0:	e03ffb15 	stw	zero,-20(fp)
  4747b4:	00002106 	br	47483c <alt_get_fd+0xd8>
  {
    if (!alt_fd_list[i].dev)
  4747b8:	040011f4 	movhi	r16,71
  4747bc:	841ab304 	addi	r16,r16,27340
  4747c0:	e0bffb17 	ldw	r2,-20(fp)
  4747c4:	1009883a 	mov	r4,r2
  4747c8:	01400304 	movi	r5,12
  4747cc:	04675f00 	call	4675f0 <__mulsi3>
  4747d0:	8085883a 	add	r2,r16,r2
  4747d4:	10800017 	ldw	r2,0(r2)
  4747d8:	1000151e 	bne	r2,zero,474830 <alt_get_fd+0xcc>
    {
      alt_fd_list[i].dev = dev;
  4747dc:	040011f4 	movhi	r16,71
  4747e0:	841ab304 	addi	r16,r16,27340
  4747e4:	e0bffb17 	ldw	r2,-20(fp)
  4747e8:	1009883a 	mov	r4,r2
  4747ec:	01400304 	movi	r5,12
  4747f0:	04675f00 	call	4675f0 <__mulsi3>
  4747f4:	8085883a 	add	r2,r16,r2
  4747f8:	e0ffff17 	ldw	r3,-4(fp)
  4747fc:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
  474800:	008011f4 	movhi	r2,71
  474804:	109f4104 	addi	r2,r2,32004
  474808:	10c00017 	ldw	r3,0(r2)
  47480c:	e0bffb17 	ldw	r2,-20(fp)
  474810:	1880040e 	bge	r3,r2,474824 <alt_get_fd+0xc0>
      {
        alt_max_fd = i;
  474814:	008011f4 	movhi	r2,71
  474818:	109f4104 	addi	r2,r2,32004
  47481c:	e0fffb17 	ldw	r3,-20(fp)
  474820:	10c00015 	stw	r3,0(r2)
      }
      rc = i;
  474824:	e0bffb17 	ldw	r2,-20(fp)
  474828:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
  47482c:	00000606 	br	474848 <alt_get_fd+0xe4>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
  474830:	e0bffb17 	ldw	r2,-20(fp)
  474834:	10800044 	addi	r2,r2,1
  474838:	e0bffb15 	stw	r2,-20(fp)
  47483c:	e0bffb17 	ldw	r2,-20(fp)
  474840:	10800810 	cmplti	r2,r2,32
  474844:	103fdc1e 	bne	r2,zero,4747b8 <alt_get_fd+0x54>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
  474848:	00801234 	movhi	r2,72
  47484c:	10a63504 	addi	r2,r2,-26412
  474850:	10800017 	ldw	r2,0(r2)
  474854:	1009883a 	mov	r4,r2
  474858:	046f54c0 	call	46f54c <OSSemPost>

  return rc;
  47485c:	e0bffc17 	ldw	r2,-16(fp)
}
  474860:	e037883a 	mov	sp,fp
  474864:	dfc00217 	ldw	ra,8(sp)
  474868:	df000117 	ldw	fp,4(sp)
  47486c:	dc000017 	ldw	r16,0(sp)
  474870:	dec00304 	addi	sp,sp,12
  474874:	f800283a 	ret

00474878 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
  474878:	defffb04 	addi	sp,sp,-20
  47487c:	df000415 	stw	fp,16(sp)
  474880:	df000404 	addi	fp,sp,16
  474884:	e13ffe15 	stw	r4,-8(fp)
  474888:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
  47488c:	e0bfff17 	ldw	r2,-4(fp)
  474890:	10810070 	cmpltui	r2,r2,1025
  474894:	1000021e 	bne	r2,zero,4748a0 <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
  474898:	00810004 	movi	r2,1024
  47489c:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
  4748a0:	e0fffe17 	ldw	r3,-8(fp)
  4748a4:	e0bfff17 	ldw	r2,-4(fp)
  4748a8:	1885883a 	add	r2,r3,r2
  4748ac:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
  4748b0:	e0bffe17 	ldw	r2,-8(fp)
  4748b4:	e0bffc15 	stw	r2,-16(fp)
  4748b8:	00000506 	br	4748d0 <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
  4748bc:	e0bffc17 	ldw	r2,-16(fp)
  4748c0:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
  4748c4:	e0bffc17 	ldw	r2,-16(fp)
  4748c8:	10800804 	addi	r2,r2,32
  4748cc:	e0bffc15 	stw	r2,-16(fp)
  4748d0:	e0fffc17 	ldw	r3,-16(fp)
  4748d4:	e0bffd17 	ldw	r2,-12(fp)
  4748d8:	18bff836 	bltu	r3,r2,4748bc <alt_icache_flush+0x44>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
  4748dc:	e0bffe17 	ldw	r2,-8(fp)
  4748e0:	108007cc 	andi	r2,r2,31
  4748e4:	10000226 	beq	r2,zero,4748f0 <alt_icache_flush+0x78>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
  4748e8:	e0bffc17 	ldw	r2,-16(fp)
  4748ec:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
  4748f0:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
  4748f4:	e037883a 	mov	sp,fp
  4748f8:	df000017 	ldw	fp,0(sp)
  4748fc:	dec00104 	addi	sp,sp,4
  474900:	f800283a 	ret

00474904 <atexit>:
  474904:	200b883a 	mov	r5,r4
  474908:	000d883a 	mov	r6,zero
  47490c:	0009883a 	mov	r4,zero
  474910:	000f883a 	mov	r7,zero
  474914:	04749cc1 	jmpi	4749cc <__register_exitproc>

00474918 <exit>:
  474918:	defffe04 	addi	sp,sp,-8
  47491c:	000b883a 	mov	r5,zero
  474920:	dc000015 	stw	r16,0(sp)
  474924:	dfc00115 	stw	ra,4(sp)
  474928:	2021883a 	mov	r16,r4
  47492c:	0474afc0 	call	474afc <__call_exitprocs>
  474930:	008011f4 	movhi	r2,71
  474934:	109f3904 	addi	r2,r2,31972
  474938:	11000017 	ldw	r4,0(r2)
  47493c:	20800f17 	ldw	r2,60(r4)
  474940:	10000126 	beq	r2,zero,474948 <exit+0x30>
  474944:	103ee83a 	callr	r2
  474948:	8009883a 	mov	r4,r16
  47494c:	0475f800 	call	475f80 <_exit>

00474950 <memcmp>:
  474950:	01c000c4 	movi	r7,3
  474954:	3980192e 	bgeu	r7,r6,4749bc <memcmp+0x6c>
  474958:	2904b03a 	or	r2,r5,r4
  47495c:	11c4703a 	and	r2,r2,r7
  474960:	10000f26 	beq	r2,zero,4749a0 <memcmp+0x50>
  474964:	20c00003 	ldbu	r3,0(r4)
  474968:	28800003 	ldbu	r2,0(r5)
  47496c:	1880151e 	bne	r3,r2,4749c4 <memcmp+0x74>
  474970:	31bfff84 	addi	r6,r6,-2
  474974:	01ffffc4 	movi	r7,-1
  474978:	00000406 	br	47498c <memcmp+0x3c>
  47497c:	20c00003 	ldbu	r3,0(r4)
  474980:	28800003 	ldbu	r2,0(r5)
  474984:	31bfffc4 	addi	r6,r6,-1
  474988:	18800e1e 	bne	r3,r2,4749c4 <memcmp+0x74>
  47498c:	21000044 	addi	r4,r4,1
  474990:	29400044 	addi	r5,r5,1
  474994:	31fff91e 	bne	r6,r7,47497c <memcmp+0x2c>
  474998:	0005883a 	mov	r2,zero
  47499c:	f800283a 	ret
  4749a0:	20c00017 	ldw	r3,0(r4)
  4749a4:	28800017 	ldw	r2,0(r5)
  4749a8:	1880041e 	bne	r3,r2,4749bc <memcmp+0x6c>
  4749ac:	31bfff04 	addi	r6,r6,-4
  4749b0:	21000104 	addi	r4,r4,4
  4749b4:	29400104 	addi	r5,r5,4
  4749b8:	39bff936 	bltu	r7,r6,4749a0 <memcmp+0x50>
  4749bc:	303fe91e 	bne	r6,zero,474964 <memcmp+0x14>
  4749c0:	003ff506 	br	474998 <memcmp+0x48>
  4749c4:	1885c83a 	sub	r2,r3,r2
  4749c8:	f800283a 	ret

004749cc <__register_exitproc>:
  4749cc:	defffa04 	addi	sp,sp,-24
  4749d0:	008011f4 	movhi	r2,71
  4749d4:	109f3904 	addi	r2,r2,31972
  4749d8:	dc000315 	stw	r16,12(sp)
  4749dc:	14000017 	ldw	r16,0(r2)
  4749e0:	dc400415 	stw	r17,16(sp)
  4749e4:	dfc00515 	stw	ra,20(sp)
  4749e8:	80805217 	ldw	r2,328(r16)
  4749ec:	2023883a 	mov	r17,r4
  4749f0:	10003e26 	beq	r2,zero,474aec <__register_exitproc+0x120>
  4749f4:	10c00117 	ldw	r3,4(r2)
  4749f8:	020007c4 	movi	r8,31
  4749fc:	40c0180e 	bge	r8,r3,474a60 <__register_exitproc+0x94>
  474a00:	00800034 	movhi	r2,0
  474a04:	10800004 	addi	r2,r2,0
  474a08:	1000061e 	bne	r2,zero,474a24 <__register_exitproc+0x58>
  474a0c:	00bfffc4 	movi	r2,-1
  474a10:	dfc00517 	ldw	ra,20(sp)
  474a14:	dc400417 	ldw	r17,16(sp)
  474a18:	dc000317 	ldw	r16,12(sp)
  474a1c:	dec00604 	addi	sp,sp,24
  474a20:	f800283a 	ret
  474a24:	01006404 	movi	r4,400
  474a28:	d9400015 	stw	r5,0(sp)
  474a2c:	d9800115 	stw	r6,4(sp)
  474a30:	d9c00215 	stw	r7,8(sp)
  474a34:	00000000 	call	0 <OSTCBStkPtr_OFFSET>
  474a38:	d9400017 	ldw	r5,0(sp)
  474a3c:	d9800117 	ldw	r6,4(sp)
  474a40:	d9c00217 	ldw	r7,8(sp)
  474a44:	103ff126 	beq	r2,zero,474a0c <__register_exitproc+0x40>
  474a48:	80c05217 	ldw	r3,328(r16)
  474a4c:	10000115 	stw	zero,4(r2)
  474a50:	10c00015 	stw	r3,0(r2)
  474a54:	80805215 	stw	r2,328(r16)
  474a58:	10006215 	stw	zero,392(r2)
  474a5c:	10006315 	stw	zero,396(r2)
  474a60:	10c00117 	ldw	r3,4(r2)
  474a64:	88000d1e 	bne	r17,zero,474a9c <__register_exitproc+0xd0>
  474a68:	19000084 	addi	r4,r3,2
  474a6c:	2109883a 	add	r4,r4,r4
  474a70:	18c00044 	addi	r3,r3,1
  474a74:	2109883a 	add	r4,r4,r4
  474a78:	1109883a 	add	r4,r2,r4
  474a7c:	10c00115 	stw	r3,4(r2)
  474a80:	0005883a 	mov	r2,zero
  474a84:	21400015 	stw	r5,0(r4)
  474a88:	dfc00517 	ldw	ra,20(sp)
  474a8c:	dc400417 	ldw	r17,16(sp)
  474a90:	dc000317 	ldw	r16,12(sp)
  474a94:	dec00604 	addi	sp,sp,24
  474a98:	f800283a 	ret
  474a9c:	02400044 	movi	r9,1
  474aa0:	12806217 	ldw	r10,392(r2)
  474aa4:	48d2983a 	sll	r9,r9,r3
  474aa8:	19000804 	addi	r4,r3,32
  474aac:	18d1883a 	add	r8,r3,r3
  474ab0:	2109883a 	add	r4,r4,r4
  474ab4:	4211883a 	add	r8,r8,r8
  474ab8:	2109883a 	add	r4,r4,r4
  474abc:	1109883a 	add	r4,r2,r4
  474ac0:	1211883a 	add	r8,r2,r8
  474ac4:	5254b03a 	or	r10,r10,r9
  474ac8:	21c02215 	stw	r7,136(r4)
  474acc:	41802215 	stw	r6,136(r8)
  474ad0:	12806215 	stw	r10,392(r2)
  474ad4:	01000084 	movi	r4,2
  474ad8:	893fe31e 	bne	r17,r4,474a68 <__register_exitproc+0x9c>
  474adc:	11006317 	ldw	r4,396(r2)
  474ae0:	2252b03a 	or	r9,r4,r9
  474ae4:	12406315 	stw	r9,396(r2)
  474ae8:	003fdf06 	br	474a68 <__register_exitproc+0x9c>
  474aec:	00801234 	movhi	r2,72
  474af0:	10b32904 	addi	r2,r2,-13148
  474af4:	80805215 	stw	r2,328(r16)
  474af8:	003fbe06 	br	4749f4 <__register_exitproc+0x28>

00474afc <__call_exitprocs>:
  474afc:	008011f4 	movhi	r2,71
  474b00:	109f3904 	addi	r2,r2,31972
  474b04:	10800017 	ldw	r2,0(r2)
  474b08:	defff304 	addi	sp,sp,-52
  474b0c:	df000b15 	stw	fp,44(sp)
  474b10:	d8800015 	stw	r2,0(sp)
  474b14:	10805204 	addi	r2,r2,328
  474b18:	dd400815 	stw	r21,32(sp)
  474b1c:	dfc00c15 	stw	ra,48(sp)
  474b20:	ddc00a15 	stw	r23,40(sp)
  474b24:	dd800915 	stw	r22,36(sp)
  474b28:	dd000715 	stw	r20,28(sp)
  474b2c:	dcc00615 	stw	r19,24(sp)
  474b30:	dc800515 	stw	r18,20(sp)
  474b34:	dc400415 	stw	r17,16(sp)
  474b38:	dc000315 	stw	r16,12(sp)
  474b3c:	d9000115 	stw	r4,4(sp)
  474b40:	2839883a 	mov	fp,r5
  474b44:	d8800215 	stw	r2,8(sp)
  474b48:	057fffc4 	movi	r21,-1
  474b4c:	d8800017 	ldw	r2,0(sp)
  474b50:	ddc00217 	ldw	r23,8(sp)
  474b54:	14805217 	ldw	r18,328(r2)
  474b58:	90001726 	beq	r18,zero,474bb8 <__call_exitprocs+0xbc>
  474b5c:	94400117 	ldw	r17,4(r18)
  474b60:	8c3fffc4 	addi	r16,r17,-1
  474b64:	80001116 	blt	r16,zero,474bac <__call_exitprocs+0xb0>
  474b68:	8c400044 	addi	r17,r17,1
  474b6c:	8427883a 	add	r19,r16,r16
  474b70:	8c63883a 	add	r17,r17,r17
  474b74:	95802204 	addi	r22,r18,136
  474b78:	9ce7883a 	add	r19,r19,r19
  474b7c:	8c63883a 	add	r17,r17,r17
  474b80:	b4e7883a 	add	r19,r22,r19
  474b84:	9463883a 	add	r17,r18,r17
  474b88:	e0001726 	beq	fp,zero,474be8 <__call_exitprocs+0xec>
  474b8c:	8c87c83a 	sub	r3,r17,r18
  474b90:	b0c7883a 	add	r3,r22,r3
  474b94:	18c01e17 	ldw	r3,120(r3)
  474b98:	1f001326 	beq	r3,fp,474be8 <__call_exitprocs+0xec>
  474b9c:	843fffc4 	addi	r16,r16,-1
  474ba0:	9cffff04 	addi	r19,r19,-4
  474ba4:	8c7fff04 	addi	r17,r17,-4
  474ba8:	857ff71e 	bne	r16,r21,474b88 <__call_exitprocs+0x8c>
  474bac:	00800034 	movhi	r2,0
  474bb0:	10800004 	addi	r2,r2,0
  474bb4:	10002a1e 	bne	r2,zero,474c60 <__call_exitprocs+0x164>
  474bb8:	dfc00c17 	ldw	ra,48(sp)
  474bbc:	df000b17 	ldw	fp,44(sp)
  474bc0:	ddc00a17 	ldw	r23,40(sp)
  474bc4:	dd800917 	ldw	r22,36(sp)
  474bc8:	dd400817 	ldw	r21,32(sp)
  474bcc:	dd000717 	ldw	r20,28(sp)
  474bd0:	dcc00617 	ldw	r19,24(sp)
  474bd4:	dc800517 	ldw	r18,20(sp)
  474bd8:	dc400417 	ldw	r17,16(sp)
  474bdc:	dc000317 	ldw	r16,12(sp)
  474be0:	dec00d04 	addi	sp,sp,52
  474be4:	f800283a 	ret
  474be8:	91000117 	ldw	r4,4(r18)
  474bec:	88c00017 	ldw	r3,0(r17)
  474bf0:	213fffc4 	addi	r4,r4,-1
  474bf4:	24001526 	beq	r4,r16,474c4c <__call_exitprocs+0x150>
  474bf8:	88000015 	stw	zero,0(r17)
  474bfc:	183fe726 	beq	r3,zero,474b9c <__call_exitprocs+0xa0>
  474c00:	00800044 	movi	r2,1
  474c04:	1408983a 	sll	r4,r2,r16
  474c08:	91406217 	ldw	r5,392(r18)
  474c0c:	95000117 	ldw	r20,4(r18)
  474c10:	214a703a 	and	r5,r4,r5
  474c14:	28000b26 	beq	r5,zero,474c44 <__call_exitprocs+0x148>
  474c18:	91406317 	ldw	r5,396(r18)
  474c1c:	2148703a 	and	r4,r4,r5
  474c20:	20000c1e 	bne	r4,zero,474c54 <__call_exitprocs+0x158>
  474c24:	99400017 	ldw	r5,0(r19)
  474c28:	d9000117 	ldw	r4,4(sp)
  474c2c:	183ee83a 	callr	r3
  474c30:	90c00117 	ldw	r3,4(r18)
  474c34:	1d3fc51e 	bne	r3,r20,474b4c <__call_exitprocs+0x50>
  474c38:	b8c00017 	ldw	r3,0(r23)
  474c3c:	1cbfd726 	beq	r3,r18,474b9c <__call_exitprocs+0xa0>
  474c40:	003fc206 	br	474b4c <__call_exitprocs+0x50>
  474c44:	183ee83a 	callr	r3
  474c48:	003ff906 	br	474c30 <__call_exitprocs+0x134>
  474c4c:	94000115 	stw	r16,4(r18)
  474c50:	003fea06 	br	474bfc <__call_exitprocs+0x100>
  474c54:	99000017 	ldw	r4,0(r19)
  474c58:	183ee83a 	callr	r3
  474c5c:	003ff406 	br	474c30 <__call_exitprocs+0x134>
  474c60:	90c00117 	ldw	r3,4(r18)
  474c64:	1800071e 	bne	r3,zero,474c84 <__call_exitprocs+0x188>
  474c68:	90c00017 	ldw	r3,0(r18)
  474c6c:	18000926 	beq	r3,zero,474c94 <__call_exitprocs+0x198>
  474c70:	9009883a 	mov	r4,r18
  474c74:	b8c00015 	stw	r3,0(r23)
  474c78:	00000000 	call	0 <OSTCBStkPtr_OFFSET>
  474c7c:	bc800017 	ldw	r18,0(r23)
  474c80:	003fb506 	br	474b58 <__call_exitprocs+0x5c>
  474c84:	90c00017 	ldw	r3,0(r18)
  474c88:	902f883a 	mov	r23,r18
  474c8c:	1825883a 	mov	r18,r3
  474c90:	003fb106 	br	474b58 <__call_exitprocs+0x5c>
  474c94:	0007883a 	mov	r3,zero
  474c98:	003ffb06 	br	474c88 <__call_exitprocs+0x18c>

00474c9c <__fixunsdfsi>:
  474c9c:	defffd04 	addi	sp,sp,-12
  474ca0:	000d883a 	mov	r6,zero
  474ca4:	01d07834 	movhi	r7,16864
  474ca8:	dc400115 	stw	r17,4(sp)
  474cac:	dc000015 	stw	r16,0(sp)
  474cb0:	dfc00215 	stw	ra,8(sp)
  474cb4:	2023883a 	mov	r17,r4
  474cb8:	2821883a 	mov	r16,r5
  474cbc:	04755c00 	call	4755c0 <__gedf2>
  474cc0:	1000080e 	bge	r2,zero,474ce4 <__fixunsdfsi+0x48>
  474cc4:	8809883a 	mov	r4,r17
  474cc8:	800b883a 	mov	r5,r16
  474ccc:	04756240 	call	475624 <__fixdfsi>
  474cd0:	dfc00217 	ldw	ra,8(sp)
  474cd4:	dc400117 	ldw	r17,4(sp)
  474cd8:	dc000017 	ldw	r16,0(sp)
  474cdc:	dec00304 	addi	sp,sp,12
  474ce0:	f800283a 	ret
  474ce4:	000d883a 	mov	r6,zero
  474ce8:	01d07834 	movhi	r7,16864
  474cec:	8809883a 	mov	r4,r17
  474cf0:	800b883a 	mov	r5,r16
  474cf4:	04750c80 	call	4750c8 <__subdf3>
  474cf8:	180b883a 	mov	r5,r3
  474cfc:	1009883a 	mov	r4,r2
  474d00:	04756240 	call	475624 <__fixdfsi>
  474d04:	00e00034 	movhi	r3,32768
  474d08:	10c5883a 	add	r2,r2,r3
  474d0c:	dfc00217 	ldw	ra,8(sp)
  474d10:	dc400117 	ldw	r17,4(sp)
  474d14:	dc000017 	ldw	r16,0(sp)
  474d18:	dec00304 	addi	sp,sp,12
  474d1c:	f800283a 	ret

00474d20 <_fpadd_parts>:
  474d20:	2005883a 	mov	r2,r4
  474d24:	21000017 	ldw	r4,0(r4)
  474d28:	01c00044 	movi	r7,1
  474d2c:	3900622e 	bgeu	r7,r4,474eb8 <_fpadd_parts+0x198>
  474d30:	28c00017 	ldw	r3,0(r5)
  474d34:	38c05f2e 	bgeu	r7,r3,474eb4 <_fpadd_parts+0x194>
  474d38:	01c00104 	movi	r7,4
  474d3c:	21c0c626 	beq	r4,r7,475058 <_fpadd_parts+0x338>
  474d40:	19c05c26 	beq	r3,r7,474eb4 <_fpadd_parts+0x194>
  474d44:	01c00084 	movi	r7,2
  474d48:	19c06b26 	beq	r3,r7,474ef8 <_fpadd_parts+0x1d8>
  474d4c:	21c05926 	beq	r4,r7,474eb4 <_fpadd_parts+0x194>
  474d50:	11c00217 	ldw	r7,8(r2)
  474d54:	2ac00217 	ldw	r11,8(r5)
  474d58:	13000317 	ldw	r12,12(r2)
  474d5c:	13400417 	ldw	r13,16(r2)
  474d60:	3ac9c83a 	sub	r4,r7,r11
  474d64:	2a000317 	ldw	r8,12(r5)
  474d68:	2a400417 	ldw	r9,16(r5)
  474d6c:	2015883a 	mov	r10,r4
  474d70:	20007516 	blt	r4,zero,474f48 <_fpadd_parts+0x228>
  474d74:	00c00fc4 	movi	r3,63
  474d78:	1a805016 	blt	r3,r10,474ebc <_fpadd_parts+0x19c>
  474d7c:	0100870e 	bge	zero,r4,474f9c <_fpadd_parts+0x27c>
  474d80:	50fff804 	addi	r3,r10,-32
  474d84:	18009916 	blt	r3,zero,474fec <_fpadd_parts+0x2cc>
  474d88:	48d6d83a 	srl	r11,r9,r3
  474d8c:	001d883a 	mov	r14,zero
  474d90:	18009e16 	blt	r3,zero,47500c <_fpadd_parts+0x2ec>
  474d94:	01000044 	movi	r4,1
  474d98:	20c6983a 	sll	r3,r4,r3
  474d9c:	0015883a 	mov	r10,zero
  474da0:	513fffc4 	addi	r4,r10,-1
  474da4:	2295403a 	cmpgeu	r10,r4,r10
  474da8:	1a87c83a 	sub	r3,r3,r10
  474dac:	1a52703a 	and	r9,r3,r9
  474db0:	2210703a 	and	r8,r4,r8
  474db4:	4250b03a 	or	r8,r8,r9
  474db8:	4010c03a 	cmpne	r8,r8,zero
  474dbc:	42d0b03a 	or	r8,r8,r11
  474dc0:	7013883a 	mov	r9,r14
  474dc4:	11000117 	ldw	r4,4(r2)
  474dc8:	28800117 	ldw	r2,4(r5)
  474dcc:	20804126 	beq	r4,r2,474ed4 <_fpadd_parts+0x1b4>
  474dd0:	20006326 	beq	r4,zero,474f60 <_fpadd_parts+0x240>
  474dd4:	4305c83a 	sub	r2,r8,r12
  474dd8:	4091803a 	cmpltu	r8,r8,r2
  474ddc:	4b47c83a 	sub	r3,r9,r13
  474de0:	1a07c83a 	sub	r3,r3,r8
  474de4:	18006316 	blt	r3,zero,474f74 <_fpadd_parts+0x254>
  474de8:	30000115 	stw	zero,4(r6)
  474dec:	31c00215 	stw	r7,8(r6)
  474df0:	30800315 	stw	r2,12(r6)
  474df4:	30c00415 	stw	r3,16(r6)
  474df8:	11ffffc4 	addi	r7,r2,-1
  474dfc:	388b403a 	cmpgeu	r5,r7,r2
  474e00:	194bc83a 	sub	r5,r3,r5
  474e04:	01040034 	movhi	r4,4096
  474e08:	213fffc4 	addi	r4,r4,-1
  474e0c:	21401736 	bltu	r4,r5,474e6c <_fpadd_parts+0x14c>
  474e10:	29008226 	beq	r5,r4,47501c <_fpadd_parts+0x2fc>
  474e14:	31400217 	ldw	r5,8(r6)
  474e18:	02840034 	movhi	r10,4096
  474e1c:	52bfffc4 	addi	r10,r10,-1
  474e20:	033fff84 	movi	r12,-2
  474e24:	297fffc4 	addi	r5,r5,-1
  474e28:	00000106 	br	474e30 <_fpadd_parts+0x110>
  474e2c:	3a804a26 	beq	r7,r10,474f58 <_fpadd_parts+0x238>
  474e30:	1089883a 	add	r4,r2,r2
  474e34:	2091803a 	cmpltu	r8,r4,r2
  474e38:	18c7883a 	add	r3,r3,r3
  474e3c:	227fffc4 	addi	r9,r4,-1
  474e40:	40d1883a 	add	r8,r8,r3
  474e44:	490f403a 	cmpgeu	r7,r9,r4
  474e48:	41cfc83a 	sub	r7,r8,r7
  474e4c:	2817883a 	mov	r11,r5
  474e50:	2005883a 	mov	r2,r4
  474e54:	4007883a 	mov	r3,r8
  474e58:	297fffc4 	addi	r5,r5,-1
  474e5c:	51fff32e 	bgeu	r10,r7,474e2c <_fpadd_parts+0x10c>
  474e60:	31000315 	stw	r4,12(r6)
  474e64:	32000415 	stw	r8,16(r6)
  474e68:	32c00215 	stw	r11,8(r6)
  474e6c:	010000c4 	movi	r4,3
  474e70:	31000015 	stw	r4,0(r6)
  474e74:	01080034 	movhi	r4,8192
  474e78:	213fffc4 	addi	r4,r4,-1
  474e7c:	20c00b2e 	bgeu	r4,r3,474eac <_fpadd_parts+0x18c>
  474e80:	180e97fa 	slli	r7,r3,31
  474e84:	1008d07a 	srli	r4,r2,1
  474e88:	31400217 	ldw	r5,8(r6)
  474e8c:	1806d07a 	srli	r3,r3,1
  474e90:	1080004c 	andi	r2,r2,1
  474e94:	3908b03a 	or	r4,r7,r4
  474e98:	1108b03a 	or	r4,r2,r4
  474e9c:	29400044 	addi	r5,r5,1
  474ea0:	31000315 	stw	r4,12(r6)
  474ea4:	30c00415 	stw	r3,16(r6)
  474ea8:	31400215 	stw	r5,8(r6)
  474eac:	3005883a 	mov	r2,r6
  474eb0:	f800283a 	ret
  474eb4:	2805883a 	mov	r2,r5
  474eb8:	f800283a 	ret
  474ebc:	59c01e0e 	bge	r11,r7,474f38 <_fpadd_parts+0x218>
  474ec0:	11000117 	ldw	r4,4(r2)
  474ec4:	28800117 	ldw	r2,4(r5)
  474ec8:	0011883a 	mov	r8,zero
  474ecc:	0013883a 	mov	r9,zero
  474ed0:	20bfbf1e 	bne	r4,r2,474dd0 <_fpadd_parts+0xb0>
  474ed4:	4305883a 	add	r2,r8,r12
  474ed8:	1207803a 	cmpltu	r3,r2,r8
  474edc:	4b53883a 	add	r9,r9,r13
  474ee0:	1a47883a 	add	r3,r3,r9
  474ee4:	31000115 	stw	r4,4(r6)
  474ee8:	31c00215 	stw	r7,8(r6)
  474eec:	30800315 	stw	r2,12(r6)
  474ef0:	30c00415 	stw	r3,16(r6)
  474ef4:	003fdd06 	br	474e6c <_fpadd_parts+0x14c>
  474ef8:	20ffef1e 	bne	r4,r3,474eb8 <_fpadd_parts+0x198>
  474efc:	31000015 	stw	r4,0(r6)
  474f00:	10c00117 	ldw	r3,4(r2)
  474f04:	30c00115 	stw	r3,4(r6)
  474f08:	10c00217 	ldw	r3,8(r2)
  474f0c:	11000117 	ldw	r4,4(r2)
  474f10:	29400117 	ldw	r5,4(r5)
  474f14:	30c00215 	stw	r3,8(r6)
  474f18:	10c00317 	ldw	r3,12(r2)
  474f1c:	2908703a 	and	r4,r5,r4
  474f20:	30c00315 	stw	r3,12(r6)
  474f24:	10c00417 	ldw	r3,16(r2)
  474f28:	31000115 	stw	r4,4(r6)
  474f2c:	3005883a 	mov	r2,r6
  474f30:	30c00415 	stw	r3,16(r6)
  474f34:	f800283a 	ret
  474f38:	580f883a 	mov	r7,r11
  474f3c:	0019883a 	mov	r12,zero
  474f40:	001b883a 	mov	r13,zero
  474f44:	003f9f06 	br	474dc4 <_fpadd_parts+0xa4>
  474f48:	0115c83a 	sub	r10,zero,r4
  474f4c:	00c00fc4 	movi	r3,63
  474f50:	1abfda16 	blt	r3,r10,474ebc <_fpadd_parts+0x19c>
  474f54:	003f8906 	br	474d7c <_fpadd_parts+0x5c>
  474f58:	627fb52e 	bgeu	r12,r9,474e30 <_fpadd_parts+0x110>
  474f5c:	003fc006 	br	474e60 <_fpadd_parts+0x140>
  474f60:	6205c83a 	sub	r2,r12,r8
  474f64:	6099803a 	cmpltu	r12,r12,r2
  474f68:	6a47c83a 	sub	r3,r13,r9
  474f6c:	1b07c83a 	sub	r3,r3,r12
  474f70:	183f9d0e 	bge	r3,zero,474de8 <_fpadd_parts+0xc8>
  474f74:	0085c83a 	sub	r2,zero,r2
  474f78:	1008c03a 	cmpne	r4,r2,zero
  474f7c:	00c7c83a 	sub	r3,zero,r3
  474f80:	1907c83a 	sub	r3,r3,r4
  474f84:	01000044 	movi	r4,1
  474f88:	31000115 	stw	r4,4(r6)
  474f8c:	31c00215 	stw	r7,8(r6)
  474f90:	30800315 	stw	r2,12(r6)
  474f94:	30c00415 	stw	r3,16(r6)
  474f98:	003f9706 	br	474df8 <_fpadd_parts+0xd8>
  474f9c:	203f8926 	beq	r4,zero,474dc4 <_fpadd_parts+0xa4>
  474fa0:	50fff804 	addi	r3,r10,-32
  474fa4:	3a8f883a 	add	r7,r7,r10
  474fa8:	18002316 	blt	r3,zero,475038 <_fpadd_parts+0x318>
  474fac:	68d6d83a 	srl	r11,r13,r3
  474fb0:	001d883a 	mov	r14,zero
  474fb4:	18001c16 	blt	r3,zero,475028 <_fpadd_parts+0x308>
  474fb8:	01000044 	movi	r4,1
  474fbc:	20c6983a 	sll	r3,r4,r3
  474fc0:	0015883a 	mov	r10,zero
  474fc4:	513fffc4 	addi	r4,r10,-1
  474fc8:	2295403a 	cmpgeu	r10,r4,r10
  474fcc:	1a87c83a 	sub	r3,r3,r10
  474fd0:	1b5a703a 	and	r13,r3,r13
  474fd4:	2318703a 	and	r12,r4,r12
  474fd8:	6358b03a 	or	r12,r12,r13
  474fdc:	6018c03a 	cmpne	r12,r12,zero
  474fe0:	62d8b03a 	or	r12,r12,r11
  474fe4:	701b883a 	mov	r13,r14
  474fe8:	003f7606 	br	474dc4 <_fpadd_parts+0xa4>
  474fec:	4808907a 	slli	r4,r9,1
  474ff0:	02c007c4 	movi	r11,31
  474ff4:	5a97c83a 	sub	r11,r11,r10
  474ff8:	22c8983a 	sll	r4,r4,r11
  474ffc:	4296d83a 	srl	r11,r8,r10
  475000:	4a9cd83a 	srl	r14,r9,r10
  475004:	22d6b03a 	or	r11,r4,r11
  475008:	003f6106 	br	474d90 <_fpadd_parts+0x70>
  47500c:	00c00044 	movi	r3,1
  475010:	1a94983a 	sll	r10,r3,r10
  475014:	0007883a 	mov	r3,zero
  475018:	003f6106 	br	474da0 <_fpadd_parts+0x80>
  47501c:	013fff84 	movi	r4,-2
  475020:	21ff7c2e 	bgeu	r4,r7,474e14 <_fpadd_parts+0xf4>
  475024:	003f9106 	br	474e6c <_fpadd_parts+0x14c>
  475028:	00c00044 	movi	r3,1
  47502c:	1a94983a 	sll	r10,r3,r10
  475030:	0007883a 	mov	r3,zero
  475034:	003fe306 	br	474fc4 <_fpadd_parts+0x2a4>
  475038:	6816907a 	slli	r11,r13,1
  47503c:	010007c4 	movi	r4,31
  475040:	2289c83a 	sub	r4,r4,r10
  475044:	5908983a 	sll	r4,r11,r4
  475048:	6296d83a 	srl	r11,r12,r10
  47504c:	6a9cd83a 	srl	r14,r13,r10
  475050:	22d6b03a 	or	r11,r4,r11
  475054:	003fd706 	br	474fb4 <_fpadd_parts+0x294>
  475058:	193f971e 	bne	r3,r4,474eb8 <_fpadd_parts+0x198>
  47505c:	11000117 	ldw	r4,4(r2)
  475060:	28c00117 	ldw	r3,4(r5)
  475064:	20ff9426 	beq	r4,r3,474eb8 <_fpadd_parts+0x198>
  475068:	008011f4 	movhi	r2,71
  47506c:	10986204 	addi	r2,r2,24968
  475070:	f800283a 	ret

00475074 <__adddf3>:
  475074:	deffec04 	addi	sp,sp,-80
  475078:	d9001115 	stw	r4,68(sp)
  47507c:	d9401215 	stw	r5,72(sp)
  475080:	d9001104 	addi	r4,sp,68
  475084:	d9400a04 	addi	r5,sp,40
  475088:	dfc01315 	stw	ra,76(sp)
  47508c:	d9c01015 	stw	r7,64(sp)
  475090:	d9800f15 	stw	r6,60(sp)
  475094:	0475d240 	call	475d24 <__unpack_d>
  475098:	d9000f04 	addi	r4,sp,60
  47509c:	d9400504 	addi	r5,sp,20
  4750a0:	0475d240 	call	475d24 <__unpack_d>
  4750a4:	d9000a04 	addi	r4,sp,40
  4750a8:	d9400504 	addi	r5,sp,20
  4750ac:	d80d883a 	mov	r6,sp
  4750b0:	0474d200 	call	474d20 <_fpadd_parts>
  4750b4:	1009883a 	mov	r4,r2
  4750b8:	0475b000 	call	475b00 <__pack_d>
  4750bc:	dfc01317 	ldw	ra,76(sp)
  4750c0:	dec01404 	addi	sp,sp,80
  4750c4:	f800283a 	ret

004750c8 <__subdf3>:
  4750c8:	deffec04 	addi	sp,sp,-80
  4750cc:	d9001115 	stw	r4,68(sp)
  4750d0:	d9401215 	stw	r5,72(sp)
  4750d4:	d9001104 	addi	r4,sp,68
  4750d8:	d9400a04 	addi	r5,sp,40
  4750dc:	dfc01315 	stw	ra,76(sp)
  4750e0:	d9c01015 	stw	r7,64(sp)
  4750e4:	d9800f15 	stw	r6,60(sp)
  4750e8:	0475d240 	call	475d24 <__unpack_d>
  4750ec:	d9000f04 	addi	r4,sp,60
  4750f0:	d9400504 	addi	r5,sp,20
  4750f4:	0475d240 	call	475d24 <__unpack_d>
  4750f8:	d8800617 	ldw	r2,24(sp)
  4750fc:	d9000a04 	addi	r4,sp,40
  475100:	d9400504 	addi	r5,sp,20
  475104:	d80d883a 	mov	r6,sp
  475108:	1080005c 	xori	r2,r2,1
  47510c:	d8800615 	stw	r2,24(sp)
  475110:	0474d200 	call	474d20 <_fpadd_parts>
  475114:	1009883a 	mov	r4,r2
  475118:	0475b000 	call	475b00 <__pack_d>
  47511c:	dfc01317 	ldw	ra,76(sp)
  475120:	dec01404 	addi	sp,sp,80
  475124:	f800283a 	ret

00475128 <__muldf3>:
  475128:	deffe404 	addi	sp,sp,-112
  47512c:	d9001115 	stw	r4,68(sp)
  475130:	d9401215 	stw	r5,72(sp)
  475134:	d9001104 	addi	r4,sp,68
  475138:	d9400a04 	addi	r5,sp,40
  47513c:	dfc01b15 	stw	ra,108(sp)
  475140:	d9800f15 	stw	r6,60(sp)
  475144:	d9c01015 	stw	r7,64(sp)
  475148:	ddc01a15 	stw	r23,104(sp)
  47514c:	dd801915 	stw	r22,100(sp)
  475150:	dd401815 	stw	r21,96(sp)
  475154:	dd001715 	stw	r20,92(sp)
  475158:	dcc01615 	stw	r19,88(sp)
  47515c:	dc801515 	stw	r18,84(sp)
  475160:	dc401415 	stw	r17,80(sp)
  475164:	dc001315 	stw	r16,76(sp)
  475168:	0475d240 	call	475d24 <__unpack_d>
  47516c:	d9000f04 	addi	r4,sp,60
  475170:	d9400504 	addi	r5,sp,20
  475174:	0475d240 	call	475d24 <__unpack_d>
  475178:	d8c00a17 	ldw	r3,40(sp)
  47517c:	00800044 	movi	r2,1
  475180:	10c01136 	bltu	r2,r3,4751c8 <__muldf3+0xa0>
  475184:	d8c00b17 	ldw	r3,44(sp)
  475188:	d8800617 	ldw	r2,24(sp)
  47518c:	d9000a04 	addi	r4,sp,40
  475190:	1884c03a 	cmpne	r2,r3,r2
  475194:	d8800b15 	stw	r2,44(sp)
  475198:	0475b000 	call	475b00 <__pack_d>
  47519c:	dfc01b17 	ldw	ra,108(sp)
  4751a0:	ddc01a17 	ldw	r23,104(sp)
  4751a4:	dd801917 	ldw	r22,100(sp)
  4751a8:	dd401817 	ldw	r21,96(sp)
  4751ac:	dd001717 	ldw	r20,92(sp)
  4751b0:	dcc01617 	ldw	r19,88(sp)
  4751b4:	dc801517 	ldw	r18,84(sp)
  4751b8:	dc401417 	ldw	r17,80(sp)
  4751bc:	dc001317 	ldw	r16,76(sp)
  4751c0:	dec01c04 	addi	sp,sp,112
  4751c4:	f800283a 	ret
  4751c8:	d9000517 	ldw	r4,20(sp)
  4751cc:	11000636 	bltu	r2,r4,4751e8 <__muldf3+0xc0>
  4751d0:	d8800617 	ldw	r2,24(sp)
  4751d4:	d8c00b17 	ldw	r3,44(sp)
  4751d8:	d9000504 	addi	r4,sp,20
  4751dc:	1884c03a 	cmpne	r2,r3,r2
  4751e0:	d8800615 	stw	r2,24(sp)
  4751e4:	003fec06 	br	475198 <__muldf3+0x70>
  4751e8:	00800104 	movi	r2,4
  4751ec:	1880051e 	bne	r3,r2,475204 <__muldf3+0xdc>
  4751f0:	00800084 	movi	r2,2
  4751f4:	20bfe31e 	bne	r4,r2,475184 <__muldf3+0x5c>
  4751f8:	010011f4 	movhi	r4,71
  4751fc:	21186204 	addi	r4,r4,24968
  475200:	003fe506 	br	475198 <__muldf3+0x70>
  475204:	2080031e 	bne	r4,r2,475214 <__muldf3+0xec>
  475208:	00800084 	movi	r2,2
  47520c:	18bffa26 	beq	r3,r2,4751f8 <__muldf3+0xd0>
  475210:	003fef06 	br	4751d0 <__muldf3+0xa8>
  475214:	00800084 	movi	r2,2
  475218:	18bfda26 	beq	r3,r2,475184 <__muldf3+0x5c>
  47521c:	20bfec26 	beq	r4,r2,4751d0 <__muldf3+0xa8>
  475220:	dc000d17 	ldw	r16,52(sp)
  475224:	dd000817 	ldw	r20,32(sp)
  475228:	dc800917 	ldw	r18,36(sp)
  47522c:	8009883a 	mov	r4,r16
  475230:	000b883a 	mov	r5,zero
  475234:	a00d883a 	mov	r6,r20
  475238:	000f883a 	mov	r7,zero
  47523c:	04759440 	call	475944 <__muldi3>
  475240:	dc400e17 	ldw	r17,56(sp)
  475244:	9009883a 	mov	r4,r18
  475248:	800d883a 	mov	r6,r16
  47524c:	000b883a 	mov	r5,zero
  475250:	000f883a 	mov	r7,zero
  475254:	102f883a 	mov	r23,r2
  475258:	1827883a 	mov	r19,r3
  47525c:	04759440 	call	475944 <__muldi3>
  475260:	900d883a 	mov	r6,r18
  475264:	8809883a 	mov	r4,r17
  475268:	000b883a 	mov	r5,zero
  47526c:	000f883a 	mov	r7,zero
  475270:	102b883a 	mov	r21,r2
  475274:	1821883a 	mov	r16,r3
  475278:	04759440 	call	475944 <__muldi3>
  47527c:	8809883a 	mov	r4,r17
  475280:	000b883a 	mov	r5,zero
  475284:	a00d883a 	mov	r6,r20
  475288:	000f883a 	mov	r7,zero
  47528c:	102d883a 	mov	r22,r2
  475290:	1825883a 	mov	r18,r3
  475294:	04759440 	call	475944 <__muldi3>
  475298:	154b883a 	add	r5,r2,r21
  47529c:	2889803a 	cmpltu	r4,r5,r2
  4752a0:	1c07883a 	add	r3,r3,r16
  4752a4:	20c9883a 	add	r4,r4,r3
  4752a8:	24004b36 	bltu	r4,r16,4753d8 <__muldf3+0x2b0>
  4752ac:	8100011e 	bne	r16,r4,4752b4 <__muldf3+0x18c>
  4752b0:	2d404936 	bltu	r5,r21,4753d8 <__muldf3+0x2b0>
  4752b4:	0011883a 	mov	r8,zero
  4752b8:	0007883a 	mov	r3,zero
  4752bc:	2ccb883a 	add	r5,r5,r19
  4752c0:	b80d883a 	mov	r6,r23
  4752c4:	2cc0012e 	bgeu	r5,r19,4752cc <__muldf3+0x1a4>
  4752c8:	02000044 	movi	r8,1
  4752cc:	258f883a 	add	r7,r4,r22
  4752d0:	3909803a 	cmpltu	r4,r7,r4
  4752d4:	da400c17 	ldw	r9,48(sp)
  4752d8:	2489883a 	add	r4,r4,r18
  4752dc:	d8800717 	ldw	r2,28(sp)
  4752e0:	20c9883a 	add	r4,r4,r3
  4752e4:	da800b17 	ldw	r10,44(sp)
  4752e8:	d8c00617 	ldw	r3,24(sp)
  4752ec:	3a11883a 	add	r8,r7,r8
  4752f0:	4885883a 	add	r2,r9,r2
  4752f4:	50c6c03a 	cmpne	r3,r10,r3
  4752f8:	41cf803a 	cmpltu	r7,r8,r7
  4752fc:	12400104 	addi	r9,r2,4
  475300:	d8c00115 	stw	r3,4(sp)
  475304:	3909883a 	add	r4,r7,r4
  475308:	da400215 	stw	r9,8(sp)
  47530c:	03480034 	movhi	r13,8192
  475310:	6b7fffc4 	addi	r13,r13,-1
  475314:	4007883a 	mov	r3,r8
  475318:	6900102e 	bgeu	r13,r4,47535c <__muldf3+0x234>
  47531c:	10800144 	addi	r2,r2,5
  475320:	180ed07a 	srli	r7,r3,1
  475324:	18c0004c 	andi	r3,r3,1
  475328:	201097fa 	slli	r8,r4,31
  47532c:	281697fa 	slli	r11,r5,31
  475330:	2008d07a 	srli	r4,r4,1
  475334:	3014d07a 	srli	r10,r6,1
  475338:	2812d07a 	srli	r9,r5,1
  47533c:	1019883a 	mov	r12,r2
  475340:	18000226 	beq	r3,zero,47534c <__muldf3+0x224>
  475344:	5a8cb03a 	or	r6,r11,r10
  475348:	49600034 	orhi	r5,r9,32768
  47534c:	41c6b03a 	or	r3,r8,r7
  475350:	10800044 	addi	r2,r2,1
  475354:	693ff236 	bltu	r13,r4,475320 <__muldf3+0x1f8>
  475358:	db000215 	stw	r12,8(sp)
  47535c:	03440034 	movhi	r13,4096
  475360:	6b7fffc4 	addi	r13,r13,-1
  475364:	69001336 	bltu	r13,r4,4753b4 <__muldf3+0x28c>
  475368:	d8800217 	ldw	r2,8(sp)
  47536c:	10bfffc4 	addi	r2,r2,-1
  475370:	18d3883a 	add	r9,r3,r3
  475374:	48c7803a 	cmpltu	r3,r9,r3
  475378:	2109883a 	add	r4,r4,r4
  47537c:	190f883a 	add	r7,r3,r4
  475380:	3191883a 	add	r8,r6,r6
  475384:	4197803a 	cmpltu	r11,r8,r6
  475388:	2955883a 	add	r10,r5,r5
  47538c:	1019883a 	mov	r12,r2
  475390:	4807883a 	mov	r3,r9
  475394:	3809883a 	mov	r4,r7
  475398:	2800010e 	bge	r5,zero,4753a0 <__muldf3+0x278>
  47539c:	48c00054 	ori	r3,r9,1
  4753a0:	400d883a 	mov	r6,r8
  4753a4:	5a8b883a 	add	r5,r11,r10
  4753a8:	10bfffc4 	addi	r2,r2,-1
  4753ac:	69fff02e 	bgeu	r13,r7,475370 <__muldf3+0x248>
  4753b0:	db000215 	stw	r12,8(sp)
  4753b4:	18803fcc 	andi	r2,r3,255
  4753b8:	01c02004 	movi	r7,128
  4753bc:	11c00926 	beq	r2,r7,4753e4 <__muldf3+0x2bc>
  4753c0:	008000c4 	movi	r2,3
  4753c4:	d9000415 	stw	r4,16(sp)
  4753c8:	d8c00315 	stw	r3,12(sp)
  4753cc:	d8800015 	stw	r2,0(sp)
  4753d0:	d809883a 	mov	r4,sp
  4753d4:	003f7006 	br	475198 <__muldf3+0x70>
  4753d8:	0011883a 	mov	r8,zero
  4753dc:	00c00044 	movi	r3,1
  4753e0:	003fb606 	br	4752bc <__muldf3+0x194>
  4753e4:	19c0400c 	andi	r7,r3,256
  4753e8:	383ff51e 	bne	r7,zero,4753c0 <__muldf3+0x298>
  4753ec:	314ab03a 	or	r5,r6,r5
  4753f0:	283ff326 	beq	r5,zero,4753c0 <__muldf3+0x298>
  4753f4:	1885883a 	add	r2,r3,r2
  4753f8:	10cb803a 	cmpltu	r5,r2,r3
  4753fc:	00ffc004 	movi	r3,-256
  475400:	10c6703a 	and	r3,r2,r3
  475404:	2909883a 	add	r4,r5,r4
  475408:	003fed06 	br	4753c0 <__muldf3+0x298>

0047540c <__divdf3>:
  47540c:	defff104 	addi	sp,sp,-60
  475410:	d9000c15 	stw	r4,48(sp)
  475414:	d9400d15 	stw	r5,52(sp)
  475418:	d9000c04 	addi	r4,sp,48
  47541c:	d9400504 	addi	r5,sp,20
  475420:	dfc00e15 	stw	ra,56(sp)
  475424:	d9800a15 	stw	r6,40(sp)
  475428:	d9c00b15 	stw	r7,44(sp)
  47542c:	0475d240 	call	475d24 <__unpack_d>
  475430:	d9000a04 	addi	r4,sp,40
  475434:	d80b883a 	mov	r5,sp
  475438:	0475d240 	call	475d24 <__unpack_d>
  47543c:	d8c00517 	ldw	r3,20(sp)
  475440:	00800044 	movi	r2,1
  475444:	10c00536 	bltu	r2,r3,47545c <__divdf3+0x50>
  475448:	d9000504 	addi	r4,sp,20
  47544c:	0475b000 	call	475b00 <__pack_d>
  475450:	dfc00e17 	ldw	ra,56(sp)
  475454:	dec00f04 	addi	sp,sp,60
  475458:	f800283a 	ret
  47545c:	d9000017 	ldw	r4,0(sp)
  475460:	11000536 	bltu	r2,r4,475478 <__divdf3+0x6c>
  475464:	d809883a 	mov	r4,sp
  475468:	0475b000 	call	475b00 <__pack_d>
  47546c:	dfc00e17 	ldw	ra,56(sp)
  475470:	dec00f04 	addi	sp,sp,60
  475474:	f800283a 	ret
  475478:	d9800617 	ldw	r6,24(sp)
  47547c:	d9400117 	ldw	r5,4(sp)
  475480:	00800104 	movi	r2,4
  475484:	314af03a 	xor	r5,r6,r5
  475488:	d9400615 	stw	r5,24(sp)
  47548c:	18800226 	beq	r3,r2,475498 <__divdf3+0x8c>
  475490:	01400084 	movi	r5,2
  475494:	1940041e 	bne	r3,r5,4754a8 <__divdf3+0x9c>
  475498:	193feb1e 	bne	r3,r4,475448 <__divdf3+0x3c>
  47549c:	010011f4 	movhi	r4,71
  4754a0:	21186204 	addi	r4,r4,24968
  4754a4:	003fe906 	br	47544c <__divdf3+0x40>
  4754a8:	20803326 	beq	r4,r2,475578 <__divdf3+0x16c>
  4754ac:	21403726 	beq	r4,r5,47558c <__divdf3+0x180>
  4754b0:	d8800217 	ldw	r2,8(sp)
  4754b4:	d9000717 	ldw	r4,28(sp)
  4754b8:	d8c00917 	ldw	r3,36(sp)
  4754bc:	da000417 	ldw	r8,16(sp)
  4754c0:	2089c83a 	sub	r4,r4,r2
  4754c4:	d9000715 	stw	r4,28(sp)
  4754c8:	d8800817 	ldw	r2,32(sp)
  4754cc:	dbc00317 	ldw	r15,12(sp)
  4754d0:	1a000236 	bltu	r3,r8,4754dc <__divdf3+0xd0>
  4754d4:	40c0081e 	bne	r8,r3,4754f8 <__divdf3+0xec>
  4754d8:	13c0072e 	bgeu	r2,r15,4754f8 <__divdf3+0xec>
  4754dc:	108b883a 	add	r5,r2,r2
  4754e0:	288d803a 	cmpltu	r6,r5,r2
  4754e4:	18c7883a 	add	r3,r3,r3
  4754e8:	213fffc4 	addi	r4,r4,-1
  4754ec:	2805883a 	mov	r2,r5
  4754f0:	30c7883a 	add	r3,r6,r3
  4754f4:	d9000715 	stw	r4,28(sp)
  4754f8:	01400f44 	movi	r5,61
  4754fc:	000f883a 	mov	r7,zero
  475500:	01040034 	movhi	r4,4096
  475504:	0019883a 	mov	r12,zero
  475508:	001b883a 	mov	r13,zero
  47550c:	201697fa 	slli	r11,r4,31
  475510:	3814d07a 	srli	r10,r7,1
  475514:	297fffc4 	addi	r5,r5,-1
  475518:	1a000936 	bltu	r3,r8,475540 <__divdf3+0x134>
  47551c:	13cdc83a 	sub	r6,r2,r15
  475520:	1193803a 	cmpltu	r9,r2,r6
  475524:	1a1dc83a 	sub	r14,r3,r8
  475528:	40c0011e 	bne	r8,r3,475530 <__divdf3+0x124>
  47552c:	13c00436 	bltu	r2,r15,475540 <__divdf3+0x134>
  475530:	3005883a 	mov	r2,r6
  475534:	7247c83a 	sub	r3,r14,r9
  475538:	61d8b03a 	or	r12,r12,r7
  47553c:	691ab03a 	or	r13,r13,r4
  475540:	108d883a 	add	r6,r2,r2
  475544:	3093803a 	cmpltu	r9,r6,r2
  475548:	18c7883a 	add	r3,r3,r3
  47554c:	5a8eb03a 	or	r7,r11,r10
  475550:	2008d07a 	srli	r4,r4,1
  475554:	3005883a 	mov	r2,r6
  475558:	48c7883a 	add	r3,r9,r3
  47555c:	283feb1e 	bne	r5,zero,47550c <__divdf3+0x100>
  475560:	61003fcc 	andi	r4,r12,255
  475564:	01402004 	movi	r5,128
  475568:	21400b26 	beq	r4,r5,475598 <__divdf3+0x18c>
  47556c:	db000815 	stw	r12,32(sp)
  475570:	db400915 	stw	r13,36(sp)
  475574:	003fb406 	br	475448 <__divdf3+0x3c>
  475578:	d8000815 	stw	zero,32(sp)
  47557c:	d8000915 	stw	zero,36(sp)
  475580:	d8000715 	stw	zero,28(sp)
  475584:	d9000504 	addi	r4,sp,20
  475588:	003fb006 	br	47544c <__divdf3+0x40>
  47558c:	d8800515 	stw	r2,20(sp)
  475590:	d9000504 	addi	r4,sp,20
  475594:	003fad06 	br	47544c <__divdf3+0x40>
  475598:	6140400c 	andi	r5,r12,256
  47559c:	283ff31e 	bne	r5,zero,47556c <__divdf3+0x160>
  4755a0:	30c4b03a 	or	r2,r6,r3
  4755a4:	103ff126 	beq	r2,zero,47556c <__divdf3+0x160>
  4755a8:	6109883a 	add	r4,r12,r4
  4755ac:	2305803a 	cmpltu	r2,r4,r12
  4755b0:	033fc004 	movi	r12,-256
  4755b4:	2318703a 	and	r12,r4,r12
  4755b8:	135b883a 	add	r13,r2,r13
  4755bc:	003feb06 	br	47556c <__divdf3+0x160>

004755c0 <__gedf2>:
  4755c0:	defff104 	addi	sp,sp,-60
  4755c4:	d9000c15 	stw	r4,48(sp)
  4755c8:	d9400d15 	stw	r5,52(sp)
  4755cc:	d9000c04 	addi	r4,sp,48
  4755d0:	d9400504 	addi	r5,sp,20
  4755d4:	dfc00e15 	stw	ra,56(sp)
  4755d8:	d9800a15 	stw	r6,40(sp)
  4755dc:	d9c00b15 	stw	r7,44(sp)
  4755e0:	0475d240 	call	475d24 <__unpack_d>
  4755e4:	d9000a04 	addi	r4,sp,40
  4755e8:	d80b883a 	mov	r5,sp
  4755ec:	0475d240 	call	475d24 <__unpack_d>
  4755f0:	d8c00517 	ldw	r3,20(sp)
  4755f4:	00800044 	movi	r2,1
  4755f8:	10c0082e 	bgeu	r2,r3,47561c <__gedf2+0x5c>
  4755fc:	d8c00017 	ldw	r3,0(sp)
  475600:	10c0062e 	bgeu	r2,r3,47561c <__gedf2+0x5c>
  475604:	d9000504 	addi	r4,sp,20
  475608:	d80b883a 	mov	r5,sp
  47560c:	0475e280 	call	475e28 <__fpcmp_parts_d>
  475610:	dfc00e17 	ldw	ra,56(sp)
  475614:	dec00f04 	addi	sp,sp,60
  475618:	f800283a 	ret
  47561c:	00bfffc4 	movi	r2,-1
  475620:	003ffb06 	br	475610 <__gedf2+0x50>

00475624 <__fixdfsi>:
  475624:	defff804 	addi	sp,sp,-32
  475628:	d9000515 	stw	r4,20(sp)
  47562c:	d9400615 	stw	r5,24(sp)
  475630:	d9000504 	addi	r4,sp,20
  475634:	d80b883a 	mov	r5,sp
  475638:	dfc00715 	stw	ra,28(sp)
  47563c:	0475d240 	call	475d24 <__unpack_d>
  475640:	d8800017 	ldw	r2,0(sp)
  475644:	00c00084 	movi	r3,2
  475648:	10c01c26 	beq	r2,r3,4756bc <__fixdfsi+0x98>
  47564c:	00c00044 	movi	r3,1
  475650:	18801a2e 	bgeu	r3,r2,4756bc <__fixdfsi+0x98>
  475654:	00c00104 	movi	r3,4
  475658:	10c01126 	beq	r2,r3,4756a0 <__fixdfsi+0x7c>
  47565c:	d8800217 	ldw	r2,8(sp)
  475660:	10001616 	blt	r2,zero,4756bc <__fixdfsi+0x98>
  475664:	00c00784 	movi	r3,30
  475668:	18800d16 	blt	r3,r2,4756a0 <__fixdfsi+0x7c>
  47566c:	00c00f04 	movi	r3,60
  475670:	1885c83a 	sub	r2,r3,r2
  475674:	10fff804 	addi	r3,r2,-32
  475678:	d9400317 	ldw	r5,12(sp)
  47567c:	d9000417 	ldw	r4,16(sp)
  475680:	18001616 	blt	r3,zero,4756dc <__fixdfsi+0xb8>
  475684:	20c4d83a 	srl	r2,r4,r3
  475688:	d8c00117 	ldw	r3,4(sp)
  47568c:	18000126 	beq	r3,zero,475694 <__fixdfsi+0x70>
  475690:	0085c83a 	sub	r2,zero,r2
  475694:	dfc00717 	ldw	ra,28(sp)
  475698:	dec00804 	addi	sp,sp,32
  47569c:	f800283a 	ret
  4756a0:	d8800117 	ldw	r2,4(sp)
  4756a4:	1000091e 	bne	r2,zero,4756cc <__fixdfsi+0xa8>
  4756a8:	00a00034 	movhi	r2,32768
  4756ac:	10bfffc4 	addi	r2,r2,-1
  4756b0:	dfc00717 	ldw	ra,28(sp)
  4756b4:	dec00804 	addi	sp,sp,32
  4756b8:	f800283a 	ret
  4756bc:	0005883a 	mov	r2,zero
  4756c0:	dfc00717 	ldw	ra,28(sp)
  4756c4:	dec00804 	addi	sp,sp,32
  4756c8:	f800283a 	ret
  4756cc:	00a00034 	movhi	r2,32768
  4756d0:	dfc00717 	ldw	ra,28(sp)
  4756d4:	dec00804 	addi	sp,sp,32
  4756d8:	f800283a 	ret
  4756dc:	2008907a 	slli	r4,r4,1
  4756e0:	018007c4 	movi	r6,31
  4756e4:	308dc83a 	sub	r6,r6,r2
  4756e8:	2188983a 	sll	r4,r4,r6
  4756ec:	2884d83a 	srl	r2,r5,r2
  4756f0:	2084b03a 	or	r2,r4,r2
  4756f4:	003fe406 	br	475688 <__fixdfsi+0x64>

004756f8 <__floatunsidf>:
  4756f8:	defff904 	addi	sp,sp,-28
  4756fc:	dc000515 	stw	r16,20(sp)
  475700:	dfc00615 	stw	ra,24(sp)
  475704:	d8000115 	stw	zero,4(sp)
  475708:	2021883a 	mov	r16,r4
  47570c:	20001726 	beq	r4,zero,47576c <__floatunsidf+0x74>
  475710:	008000c4 	movi	r2,3
  475714:	d8800015 	stw	r2,0(sp)
  475718:	00800f04 	movi	r2,60
  47571c:	d8800215 	stw	r2,8(sp)
  475720:	0475a540 	call	475a54 <__clzsi2>
  475724:	10c00744 	addi	r3,r2,29
  475728:	18001816 	blt	r3,zero,47578c <__floatunsidf+0x94>
  47572c:	18002d26 	beq	r3,zero,4757e4 <__floatunsidf+0xec>
  475730:	113fff44 	addi	r4,r2,-3
  475734:	20002e16 	blt	r4,zero,4757f0 <__floatunsidf+0xf8>
  475738:	8108983a 	sll	r4,r16,r4
  47573c:	0021883a 	mov	r16,zero
  475740:	014007c4 	movi	r5,31
  475744:	2885c83a 	sub	r2,r5,r2
  475748:	dc000315 	stw	r16,12(sp)
  47574c:	d9000415 	stw	r4,16(sp)
  475750:	d8800215 	stw	r2,8(sp)
  475754:	d809883a 	mov	r4,sp
  475758:	0475b000 	call	475b00 <__pack_d>
  47575c:	dfc00617 	ldw	ra,24(sp)
  475760:	dc000517 	ldw	r16,20(sp)
  475764:	dec00704 	addi	sp,sp,28
  475768:	f800283a 	ret
  47576c:	00800084 	movi	r2,2
  475770:	d809883a 	mov	r4,sp
  475774:	d8800015 	stw	r2,0(sp)
  475778:	0475b000 	call	475b00 <__pack_d>
  47577c:	dfc00617 	ldw	ra,24(sp)
  475780:	dc000517 	ldw	r16,20(sp)
  475784:	dec00704 	addi	sp,sp,28
  475788:	f800283a 	ret
  47578c:	00c7c83a 	sub	r3,zero,r3
  475790:	193ff804 	addi	r4,r3,-32
  475794:	20001c16 	blt	r4,zero,475808 <__floatunsidf+0x110>
  475798:	000b883a 	mov	r5,zero
  47579c:	2009d7fa 	srai	r4,r4,31
  4757a0:	80c6d83a 	srl	r3,r16,r3
  4757a4:	297fffc4 	addi	r5,r5,-1
  4757a8:	2c20703a 	and	r16,r5,r16
  4757ac:	8020c03a 	cmpne	r16,r16,zero
  4757b0:	1906703a 	and	r3,r3,r4
  4757b4:	010007c4 	movi	r4,31
  4757b8:	80c6b03a 	or	r3,r16,r3
  4757bc:	2085c83a 	sub	r2,r4,r2
  4757c0:	d809883a 	mov	r4,sp
  4757c4:	d8c00315 	stw	r3,12(sp)
  4757c8:	d8000415 	stw	zero,16(sp)
  4757cc:	d8800215 	stw	r2,8(sp)
  4757d0:	0475b000 	call	475b00 <__pack_d>
  4757d4:	dfc00617 	ldw	ra,24(sp)
  4757d8:	dc000517 	ldw	r16,20(sp)
  4757dc:	dec00704 	addi	sp,sp,28
  4757e0:	f800283a 	ret
  4757e4:	dc000315 	stw	r16,12(sp)
  4757e8:	d8000415 	stw	zero,16(sp)
  4757ec:	003fd906 	br	475754 <__floatunsidf+0x5c>
  4757f0:	800ad07a 	srli	r5,r16,1
  4757f4:	010007c4 	movi	r4,31
  4757f8:	20c9c83a 	sub	r4,r4,r3
  4757fc:	2908d83a 	srl	r4,r5,r4
  475800:	80e0983a 	sll	r16,r16,r3
  475804:	003fce06 	br	475740 <__floatunsidf+0x48>
  475808:	01400044 	movi	r5,1
  47580c:	28ca983a 	sll	r5,r5,r3
  475810:	003fe206 	br	47579c <__floatunsidf+0xa4>

00475814 <udivmodsi4>:
  475814:	2005883a 	mov	r2,r4
  475818:	2900182e 	bgeu	r5,r4,47587c <udivmodsi4+0x68>
  47581c:	28001716 	blt	r5,zero,47587c <udivmodsi4+0x68>
  475820:	01000804 	movi	r4,32
  475824:	00c00044 	movi	r3,1
  475828:	00000206 	br	475834 <udivmodsi4+0x20>
  47582c:	20001126 	beq	r4,zero,475874 <udivmodsi4+0x60>
  475830:	28000516 	blt	r5,zero,475848 <udivmodsi4+0x34>
  475834:	294b883a 	add	r5,r5,r5
  475838:	213fffc4 	addi	r4,r4,-1
  47583c:	18c7883a 	add	r3,r3,r3
  475840:	28bffa36 	bltu	r5,r2,47582c <udivmodsi4+0x18>
  475844:	18000b26 	beq	r3,zero,475874 <udivmodsi4+0x60>
  475848:	0009883a 	mov	r4,zero
  47584c:	11400236 	bltu	r2,r5,475858 <udivmodsi4+0x44>
  475850:	1145c83a 	sub	r2,r2,r5
  475854:	20c8b03a 	or	r4,r4,r3
  475858:	1806d07a 	srli	r3,r3,1
  47585c:	280ad07a 	srli	r5,r5,1
  475860:	183ffa1e 	bne	r3,zero,47584c <udivmodsi4+0x38>
  475864:	3000021e 	bne	r6,zero,475870 <udivmodsi4+0x5c>
  475868:	2005883a 	mov	r2,r4
  47586c:	f800283a 	ret
  475870:	f800283a 	ret
  475874:	0009883a 	mov	r4,zero
  475878:	003ffa06 	br	475864 <udivmodsi4+0x50>
  47587c:	00c00044 	movi	r3,1
  475880:	0009883a 	mov	r4,zero
  475884:	003ff106 	br	47584c <udivmodsi4+0x38>

00475888 <__divsi3>:
  475888:	defffe04 	addi	sp,sp,-8
  47588c:	dfc00115 	stw	ra,4(sp)
  475890:	dc000015 	stw	r16,0(sp)
  475894:	20000a16 	blt	r4,zero,4758c0 <__divsi3+0x38>
  475898:	0021883a 	mov	r16,zero
  47589c:	28000b16 	blt	r5,zero,4758cc <__divsi3+0x44>
  4758a0:	000d883a 	mov	r6,zero
  4758a4:	04758140 	call	475814 <udivmodsi4>
  4758a8:	80000126 	beq	r16,zero,4758b0 <__divsi3+0x28>
  4758ac:	0085c83a 	sub	r2,zero,r2
  4758b0:	dfc00117 	ldw	ra,4(sp)
  4758b4:	dc000017 	ldw	r16,0(sp)
  4758b8:	dec00204 	addi	sp,sp,8
  4758bc:	f800283a 	ret
  4758c0:	0109c83a 	sub	r4,zero,r4
  4758c4:	04000044 	movi	r16,1
  4758c8:	283ff50e 	bge	r5,zero,4758a0 <__divsi3+0x18>
  4758cc:	014bc83a 	sub	r5,zero,r5
  4758d0:	8400005c 	xori	r16,r16,1
  4758d4:	003ff206 	br	4758a0 <__divsi3+0x18>

004758d8 <__modsi3>:
  4758d8:	deffff04 	addi	sp,sp,-4
  4758dc:	dfc00015 	stw	ra,0(sp)
  4758e0:	20000516 	blt	r4,zero,4758f8 <__modsi3+0x20>
  4758e4:	28000c16 	blt	r5,zero,475918 <__modsi3+0x40>
  4758e8:	01800044 	movi	r6,1
  4758ec:	dfc00017 	ldw	ra,0(sp)
  4758f0:	dec00104 	addi	sp,sp,4
  4758f4:	04758141 	jmpi	475814 <udivmodsi4>
  4758f8:	0109c83a 	sub	r4,zero,r4
  4758fc:	28000b16 	blt	r5,zero,47592c <__modsi3+0x54>
  475900:	01800044 	movi	r6,1
  475904:	04758140 	call	475814 <udivmodsi4>
  475908:	0085c83a 	sub	r2,zero,r2
  47590c:	dfc00017 	ldw	ra,0(sp)
  475910:	dec00104 	addi	sp,sp,4
  475914:	f800283a 	ret
  475918:	014bc83a 	sub	r5,zero,r5
  47591c:	01800044 	movi	r6,1
  475920:	dfc00017 	ldw	ra,0(sp)
  475924:	dec00104 	addi	sp,sp,4
  475928:	04758141 	jmpi	475814 <udivmodsi4>
  47592c:	014bc83a 	sub	r5,zero,r5
  475930:	003ff306 	br	475900 <__modsi3+0x28>

00475934 <__udivsi3>:
  475934:	000d883a 	mov	r6,zero
  475938:	04758141 	jmpi	475814 <udivmodsi4>

0047593c <__umodsi3>:
  47593c:	01800044 	movi	r6,1
  475940:	04758141 	jmpi	475814 <udivmodsi4>

00475944 <__muldi3>:
  475944:	defff604 	addi	sp,sp,-40
  475948:	dd400515 	stw	r21,20(sp)
  47594c:	dd000415 	stw	r20,16(sp)
  475950:	257fffcc 	andi	r21,r4,65535
  475954:	353fffcc 	andi	r20,r6,65535
  475958:	dcc00315 	stw	r19,12(sp)
  47595c:	3026d43a 	srli	r19,r6,16
  475960:	dd800615 	stw	r22,24(sp)
  475964:	dc800215 	stw	r18,8(sp)
  475968:	dc400115 	stw	r17,4(sp)
  47596c:	2024d43a 	srli	r18,r4,16
  475970:	2023883a 	mov	r17,r4
  475974:	282d883a 	mov	r22,r5
  475978:	a009883a 	mov	r4,r20
  47597c:	a80b883a 	mov	r5,r21
  475980:	dfc00915 	stw	ra,36(sp)
  475984:	df000815 	stw	fp,32(sp)
  475988:	ddc00715 	stw	r23,28(sp)
  47598c:	3839883a 	mov	fp,r7
  475990:	dc000015 	stw	r16,0(sp)
  475994:	3021883a 	mov	r16,r6
  475998:	04675f00 	call	4675f0 <__mulsi3>
  47599c:	a80b883a 	mov	r5,r21
  4759a0:	9809883a 	mov	r4,r19
  4759a4:	102f883a 	mov	r23,r2
  4759a8:	04675f00 	call	4675f0 <__mulsi3>
  4759ac:	a009883a 	mov	r4,r20
  4759b0:	900b883a 	mov	r5,r18
  4759b4:	102b883a 	mov	r21,r2
  4759b8:	04675f00 	call	4675f0 <__mulsi3>
  4759bc:	9809883a 	mov	r4,r19
  4759c0:	900b883a 	mov	r5,r18
  4759c4:	1029883a 	mov	r20,r2
  4759c8:	04675f00 	call	4675f0 <__mulsi3>
  4759cc:	1007883a 	mov	r3,r2
  4759d0:	b804d43a 	srli	r2,r23,16
  4759d4:	a549883a 	add	r4,r20,r21
  4759d8:	2089883a 	add	r4,r4,r2
  4759dc:	2500022e 	bgeu	r4,r20,4759e8 <__muldi3+0xa4>
  4759e0:	00800074 	movhi	r2,1
  4759e4:	1887883a 	add	r3,r3,r2
  4759e8:	200cd43a 	srli	r6,r4,16
  4759ec:	2004943a 	slli	r2,r4,16
  4759f0:	e00b883a 	mov	r5,fp
  4759f4:	8809883a 	mov	r4,r17
  4759f8:	bdffffcc 	andi	r23,r23,65535
  4759fc:	19a3883a 	add	r17,r3,r6
  475a00:	15ef883a 	add	r23,r2,r23
  475a04:	04675f00 	call	4675f0 <__mulsi3>
  475a08:	8009883a 	mov	r4,r16
  475a0c:	b00b883a 	mov	r5,r22
  475a10:	1025883a 	mov	r18,r2
  475a14:	04675f00 	call	4675f0 <__mulsi3>
  475a18:	9085883a 	add	r2,r18,r2
  475a1c:	1447883a 	add	r3,r2,r17
  475a20:	b805883a 	mov	r2,r23
  475a24:	dfc00917 	ldw	ra,36(sp)
  475a28:	df000817 	ldw	fp,32(sp)
  475a2c:	ddc00717 	ldw	r23,28(sp)
  475a30:	dd800617 	ldw	r22,24(sp)
  475a34:	dd400517 	ldw	r21,20(sp)
  475a38:	dd000417 	ldw	r20,16(sp)
  475a3c:	dcc00317 	ldw	r19,12(sp)
  475a40:	dc800217 	ldw	r18,8(sp)
  475a44:	dc400117 	ldw	r17,4(sp)
  475a48:	dc000017 	ldw	r16,0(sp)
  475a4c:	dec00a04 	addi	sp,sp,40
  475a50:	f800283a 	ret

00475a54 <__clzsi2>:
  475a54:	00bfffd4 	movui	r2,65535
  475a58:	11000b36 	bltu	r2,r4,475a88 <__clzsi2+0x34>
  475a5c:	00803fc4 	movi	r2,255
  475a60:	11001e2e 	bgeu	r2,r4,475adc <__clzsi2+0x88>
  475a64:	00c00204 	movi	r3,8
  475a68:	20c8d83a 	srl	r4,r4,r3
  475a6c:	00c011f4 	movhi	r3,71
  475a70:	18d86704 	addi	r3,r3,24988
  475a74:	00800604 	movi	r2,24
  475a78:	1909883a 	add	r4,r3,r4
  475a7c:	20c00003 	ldbu	r3,0(r4)
  475a80:	10c5c83a 	sub	r2,r2,r3
  475a84:	f800283a 	ret
  475a88:	00804034 	movhi	r2,256
  475a8c:	10bfffc4 	addi	r2,r2,-1
  475a90:	11000936 	bltu	r2,r4,475ab8 <__clzsi2+0x64>
  475a94:	00800404 	movi	r2,16
  475a98:	1007883a 	mov	r3,r2
  475a9c:	20c8d83a 	srl	r4,r4,r3
  475aa0:	00c011f4 	movhi	r3,71
  475aa4:	18d86704 	addi	r3,r3,24988
  475aa8:	1909883a 	add	r4,r3,r4
  475aac:	20c00003 	ldbu	r3,0(r4)
  475ab0:	10c5c83a 	sub	r2,r2,r3
  475ab4:	f800283a 	ret
  475ab8:	00c00604 	movi	r3,24
  475abc:	20c8d83a 	srl	r4,r4,r3
  475ac0:	00c011f4 	movhi	r3,71
  475ac4:	18d86704 	addi	r3,r3,24988
  475ac8:	00800204 	movi	r2,8
  475acc:	1909883a 	add	r4,r3,r4
  475ad0:	20c00003 	ldbu	r3,0(r4)
  475ad4:	10c5c83a 	sub	r2,r2,r3
  475ad8:	f800283a 	ret
  475adc:	0007883a 	mov	r3,zero
  475ae0:	20c8d83a 	srl	r4,r4,r3
  475ae4:	00c011f4 	movhi	r3,71
  475ae8:	18d86704 	addi	r3,r3,24988
  475aec:	00800804 	movi	r2,32
  475af0:	1909883a 	add	r4,r3,r4
  475af4:	20c00003 	ldbu	r3,0(r4)
  475af8:	10c5c83a 	sub	r2,r2,r3
  475afc:	f800283a 	ret

00475b00 <__pack_d>:
  475b00:	20800017 	ldw	r2,0(r4)
  475b04:	defff804 	addi	sp,sp,-32
  475b08:	dcc00315 	stw	r19,12(sp)
  475b0c:	dc800215 	stw	r18,8(sp)
  475b10:	dfc00715 	stw	ra,28(sp)
  475b14:	dd800615 	stw	r22,24(sp)
  475b18:	dd400515 	stw	r21,20(sp)
  475b1c:	dd000415 	stw	r20,16(sp)
  475b20:	dc400115 	stw	r17,4(sp)
  475b24:	dc000015 	stw	r16,0(sp)
  475b28:	04800044 	movi	r18,1
  475b2c:	24400317 	ldw	r17,12(r4)
  475b30:	24000417 	ldw	r16,16(r4)
  475b34:	24c00117 	ldw	r19,4(r4)
  475b38:	9080422e 	bgeu	r18,r2,475c44 <__pack_d+0x144>
  475b3c:	00c00104 	movi	r3,4
  475b40:	10c03c26 	beq	r2,r3,475c34 <__pack_d+0x134>
  475b44:	00c00084 	movi	r3,2
  475b48:	10c01926 	beq	r2,r3,475bb0 <__pack_d+0xb0>
  475b4c:	8c04b03a 	or	r2,r17,r16
  475b50:	10001726 	beq	r2,zero,475bb0 <__pack_d+0xb0>
  475b54:	21000217 	ldw	r4,8(r4)
  475b58:	00bf0084 	movi	r2,-1022
  475b5c:	20804016 	blt	r4,r2,475c60 <__pack_d+0x160>
  475b60:	0080ffc4 	movi	r2,1023
  475b64:	11003316 	blt	r2,r4,475c34 <__pack_d+0x134>
  475b68:	88803fcc 	andi	r2,r17,255
  475b6c:	00c02004 	movi	r3,128
  475b70:	10c02926 	beq	r2,r3,475c18 <__pack_d+0x118>
  475b74:	88801fc4 	addi	r2,r17,127
  475b78:	1463803a 	cmpltu	r17,r2,r17
  475b7c:	8c21883a 	add	r16,r17,r16
  475b80:	1023883a 	mov	r17,r2
  475b84:	00880034 	movhi	r2,8192
  475b88:	10bfffc4 	addi	r2,r2,-1
  475b8c:	14001c36 	bltu	r2,r16,475c00 <__pack_d+0x100>
  475b90:	2100ffc4 	addi	r4,r4,1023
  475b94:	8006963a 	slli	r3,r16,24
  475b98:	8804d23a 	srli	r2,r17,8
  475b9c:	8020913a 	slli	r16,r16,4
  475ba0:	2101ffcc 	andi	r4,r4,2047
  475ba4:	1884b03a 	or	r2,r3,r2
  475ba8:	8020d33a 	srli	r16,r16,12
  475bac:	00000306 	br	475bbc <__pack_d+0xbc>
  475bb0:	0009883a 	mov	r4,zero
  475bb4:	0005883a 	mov	r2,zero
  475bb8:	0021883a 	mov	r16,zero
  475bbc:	2008953a 	slli	r4,r4,20
  475bc0:	982697fa 	slli	r19,r19,31
  475bc4:	00c00434 	movhi	r3,16
  475bc8:	18ffffc4 	addi	r3,r3,-1
  475bcc:	80e0703a 	and	r16,r16,r3
  475bd0:	8106b03a 	or	r3,r16,r4
  475bd4:	1cc6b03a 	or	r3,r3,r19
  475bd8:	dfc00717 	ldw	ra,28(sp)
  475bdc:	dd800617 	ldw	r22,24(sp)
  475be0:	dd400517 	ldw	r21,20(sp)
  475be4:	dd000417 	ldw	r20,16(sp)
  475be8:	dcc00317 	ldw	r19,12(sp)
  475bec:	dc800217 	ldw	r18,8(sp)
  475bf0:	dc400117 	ldw	r17,4(sp)
  475bf4:	dc000017 	ldw	r16,0(sp)
  475bf8:	dec00804 	addi	sp,sp,32
  475bfc:	f800283a 	ret
  475c00:	800697fa 	slli	r3,r16,31
  475c04:	8804d07a 	srli	r2,r17,1
  475c08:	21010004 	addi	r4,r4,1024
  475c0c:	8020d07a 	srli	r16,r16,1
  475c10:	18a2b03a 	or	r17,r3,r2
  475c14:	003fdf06 	br	475b94 <__pack_d+0x94>
  475c18:	88c0400c 	andi	r3,r17,256
  475c1c:	183fd926 	beq	r3,zero,475b84 <__pack_d+0x84>
  475c20:	8885883a 	add	r2,r17,r2
  475c24:	1463803a 	cmpltu	r17,r2,r17
  475c28:	8c21883a 	add	r16,r17,r16
  475c2c:	1023883a 	mov	r17,r2
  475c30:	003fd406 	br	475b84 <__pack_d+0x84>
  475c34:	0101ffc4 	movi	r4,2047
  475c38:	0005883a 	mov	r2,zero
  475c3c:	0021883a 	mov	r16,zero
  475c40:	003fde06 	br	475bbc <__pack_d+0xbc>
  475c44:	84000234 	orhi	r16,r16,8
  475c48:	00c00434 	movhi	r3,16
  475c4c:	18ffffc4 	addi	r3,r3,-1
  475c50:	8805883a 	mov	r2,r17
  475c54:	80e0703a 	and	r16,r16,r3
  475c58:	0101ffc4 	movi	r4,2047
  475c5c:	003fd706 	br	475bbc <__pack_d+0xbc>
  475c60:	1129c83a 	sub	r20,r2,r4
  475c64:	00800e04 	movi	r2,56
  475c68:	15002716 	blt	r2,r20,475d08 <__pack_d+0x208>
  475c6c:	800b883a 	mov	r5,r16
  475c70:	a00d883a 	mov	r6,r20
  475c74:	8809883a 	mov	r4,r17
  475c78:	0475ef80 	call	475ef8 <__lshrdi3>
  475c7c:	9009883a 	mov	r4,r18
  475c80:	000b883a 	mov	r5,zero
  475c84:	a00d883a 	mov	r6,r20
  475c88:	102d883a 	mov	r22,r2
  475c8c:	182b883a 	mov	r21,r3
  475c90:	0475f3c0 	call	475f3c <__ashldi3>
  475c94:	1009003a 	cmpeq	r4,r2,zero
  475c98:	1907c83a 	sub	r3,r3,r4
  475c9c:	10bfffc4 	addi	r2,r2,-1
  475ca0:	1c20703a 	and	r16,r3,r16
  475ca4:	1444703a 	and	r2,r2,r17
  475ca8:	1404b03a 	or	r2,r2,r16
  475cac:	1004c03a 	cmpne	r2,r2,zero
  475cb0:	1584b03a 	or	r2,r2,r22
  475cb4:	11003fcc 	andi	r4,r2,255
  475cb8:	01402004 	movi	r5,128
  475cbc:	a807883a 	mov	r3,r21
  475cc0:	2140131e 	bne	r4,r5,475d10 <__pack_d+0x210>
  475cc4:	1140400c 	andi	r5,r2,256
  475cc8:	28000426 	beq	r5,zero,475cdc <__pack_d+0x1dc>
  475ccc:	1109883a 	add	r4,r2,r4
  475cd0:	2085803a 	cmpltu	r2,r4,r2
  475cd4:	1547883a 	add	r3,r2,r21
  475cd8:	2005883a 	mov	r2,r4
  475cdc:	1808963a 	slli	r4,r3,24
  475ce0:	1004d23a 	srli	r2,r2,8
  475ce4:	1820913a 	slli	r16,r3,4
  475ce8:	01440034 	movhi	r5,4096
  475cec:	297fffc4 	addi	r5,r5,-1
  475cf0:	2084b03a 	or	r2,r4,r2
  475cf4:	8020d33a 	srli	r16,r16,12
  475cf8:	01000044 	movi	r4,1
  475cfc:	28ffaf36 	bltu	r5,r3,475bbc <__pack_d+0xbc>
  475d00:	0009883a 	mov	r4,zero
  475d04:	003fad06 	br	475bbc <__pack_d+0xbc>
  475d08:	0005883a 	mov	r2,zero
  475d0c:	0007883a 	mov	r3,zero
  475d10:	11001fc4 	addi	r4,r2,127
  475d14:	2085803a 	cmpltu	r2,r4,r2
  475d18:	10c7883a 	add	r3,r2,r3
  475d1c:	2005883a 	mov	r2,r4
  475d20:	003fee06 	br	475cdc <__pack_d+0x1dc>

00475d24 <__unpack_d>:
  475d24:	21800117 	ldw	r6,4(r4)
  475d28:	20c00017 	ldw	r3,0(r4)
  475d2c:	3004d7fa 	srli	r2,r6,31
  475d30:	3008d53a 	srli	r4,r6,20
  475d34:	28800115 	stw	r2,4(r5)
  475d38:	2101ffcc 	andi	r4,r4,2047
  475d3c:	00800434 	movhi	r2,16
  475d40:	10bfffc4 	addi	r2,r2,-1
  475d44:	3084703a 	and	r2,r6,r2
  475d48:	20001a1e 	bne	r4,zero,475db4 <__unpack_d+0x90>
  475d4c:	1888b03a 	or	r4,r3,r2
  475d50:	20002626 	beq	r4,zero,475dec <__unpack_d+0xc8>
  475d54:	1808d63a 	srli	r4,r3,24
  475d58:	1004923a 	slli	r2,r2,8
  475d5c:	01bf0084 	movi	r6,-1022
  475d60:	29800215 	stw	r6,8(r5)
  475d64:	2084b03a 	or	r2,r4,r2
  475d68:	010000c4 	movi	r4,3
  475d6c:	29000015 	stw	r4,0(r5)
  475d70:	02040034 	movhi	r8,4096
  475d74:	423fffc4 	addi	r8,r8,-1
  475d78:	1806923a 	slli	r3,r3,8
  475d7c:	40801836 	bltu	r8,r2,475de0 <__unpack_d+0xbc>
  475d80:	013f0044 	movi	r4,-1023
  475d84:	18cd883a 	add	r6,r3,r3
  475d88:	30c7803a 	cmpltu	r3,r6,r3
  475d8c:	1085883a 	add	r2,r2,r2
  475d90:	1885883a 	add	r2,r3,r2
  475d94:	200f883a 	mov	r7,r4
  475d98:	3007883a 	mov	r3,r6
  475d9c:	213fffc4 	addi	r4,r4,-1
  475da0:	40bff82e 	bgeu	r8,r2,475d84 <__unpack_d+0x60>
  475da4:	29c00215 	stw	r7,8(r5)
  475da8:	28c00315 	stw	r3,12(r5)
  475dac:	28800415 	stw	r2,16(r5)
  475db0:	f800283a 	ret
  475db4:	01c1ffc4 	movi	r7,2047
  475db8:	21c00f26 	beq	r4,r7,475df8 <__unpack_d+0xd4>
  475dbc:	180cd63a 	srli	r6,r3,24
  475dc0:	1004923a 	slli	r2,r2,8
  475dc4:	213f0044 	addi	r4,r4,-1023
  475dc8:	1806923a 	slli	r3,r3,8
  475dcc:	3084b03a 	or	r2,r6,r2
  475dd0:	29000215 	stw	r4,8(r5)
  475dd4:	010000c4 	movi	r4,3
  475dd8:	10840034 	orhi	r2,r2,4096
  475ddc:	29000015 	stw	r4,0(r5)
  475de0:	28c00315 	stw	r3,12(r5)
  475de4:	28800415 	stw	r2,16(r5)
  475de8:	f800283a 	ret
  475dec:	00800084 	movi	r2,2
  475df0:	28800015 	stw	r2,0(r5)
  475df4:	f800283a 	ret
  475df8:	1888b03a 	or	r4,r3,r2
  475dfc:	20000526 	beq	r4,zero,475e14 <__unpack_d+0xf0>
  475e00:	3180022c 	andhi	r6,r6,8
  475e04:	30000626 	beq	r6,zero,475e20 <__unpack_d+0xfc>
  475e08:	01000044 	movi	r4,1
  475e0c:	29000015 	stw	r4,0(r5)
  475e10:	003ff306 	br	475de0 <__unpack_d+0xbc>
  475e14:	00800104 	movi	r2,4
  475e18:	28800015 	stw	r2,0(r5)
  475e1c:	f800283a 	ret
  475e20:	28000015 	stw	zero,0(r5)
  475e24:	003fee06 	br	475de0 <__unpack_d+0xbc>

00475e28 <__fpcmp_parts_d>:
  475e28:	20c00017 	ldw	r3,0(r4)
  475e2c:	00800044 	movi	r2,1
  475e30:	10c0142e 	bgeu	r2,r3,475e84 <__fpcmp_parts_d+0x5c>
  475e34:	29800017 	ldw	r6,0(r5)
  475e38:	1180122e 	bgeu	r2,r6,475e84 <__fpcmp_parts_d+0x5c>
  475e3c:	01c00104 	movi	r7,4
  475e40:	19c02826 	beq	r3,r7,475ee4 <__fpcmp_parts_d+0xbc>
  475e44:	31c00926 	beq	r6,r7,475e6c <__fpcmp_parts_d+0x44>
  475e48:	01c00084 	movi	r7,2
  475e4c:	19c00626 	beq	r3,r7,475e68 <__fpcmp_parts_d+0x40>
  475e50:	31c00a26 	beq	r6,r7,475e7c <__fpcmp_parts_d+0x54>
  475e54:	20c00117 	ldw	r3,4(r4)
  475e58:	29800117 	ldw	r6,4(r5)
  475e5c:	19800b26 	beq	r3,r6,475e8c <__fpcmp_parts_d+0x64>
  475e60:	1800041e 	bne	r3,zero,475e74 <__fpcmp_parts_d+0x4c>
  475e64:	f800283a 	ret
  475e68:	30c01a26 	beq	r6,r3,475ed4 <__fpcmp_parts_d+0xac>
  475e6c:	28800117 	ldw	r2,4(r5)
  475e70:	1000041e 	bne	r2,zero,475e84 <__fpcmp_parts_d+0x5c>
  475e74:	00bfffc4 	movi	r2,-1
  475e78:	f800283a 	ret
  475e7c:	20800117 	ldw	r2,4(r4)
  475e80:	103ffc1e 	bne	r2,zero,475e74 <__fpcmp_parts_d+0x4c>
  475e84:	00800044 	movi	r2,1
  475e88:	f800283a 	ret
  475e8c:	21c00217 	ldw	r7,8(r4)
  475e90:	29800217 	ldw	r6,8(r5)
  475e94:	31c0020e 	bge	r6,r7,475ea0 <__fpcmp_parts_d+0x78>
  475e98:	183ff61e 	bne	r3,zero,475e74 <__fpcmp_parts_d+0x4c>
  475e9c:	f800283a 	ret
  475ea0:	39800a16 	blt	r7,r6,475ecc <__fpcmp_parts_d+0xa4>
  475ea4:	20800417 	ldw	r2,16(r4)
  475ea8:	29800417 	ldw	r6,16(r5)
  475eac:	21c00317 	ldw	r7,12(r4)
  475eb0:	29000317 	ldw	r4,12(r5)
  475eb4:	30800936 	bltu	r6,r2,475edc <__fpcmp_parts_d+0xb4>
  475eb8:	1180011e 	bne	r2,r6,475ec0 <__fpcmp_parts_d+0x98>
  475ebc:	21c00736 	bltu	r4,r7,475edc <__fpcmp_parts_d+0xb4>
  475ec0:	11800236 	bltu	r2,r6,475ecc <__fpcmp_parts_d+0xa4>
  475ec4:	3080031e 	bne	r6,r2,475ed4 <__fpcmp_parts_d+0xac>
  475ec8:	3900022e 	bgeu	r7,r4,475ed4 <__fpcmp_parts_d+0xac>
  475ecc:	183fe926 	beq	r3,zero,475e74 <__fpcmp_parts_d+0x4c>
  475ed0:	003fec06 	br	475e84 <__fpcmp_parts_d+0x5c>
  475ed4:	0005883a 	mov	r2,zero
  475ed8:	f800283a 	ret
  475edc:	183fe926 	beq	r3,zero,475e84 <__fpcmp_parts_d+0x5c>
  475ee0:	003fe406 	br	475e74 <__fpcmp_parts_d+0x4c>
  475ee4:	30ffe51e 	bne	r6,r3,475e7c <__fpcmp_parts_d+0x54>
  475ee8:	28c00117 	ldw	r3,4(r5)
  475eec:	20800117 	ldw	r2,4(r4)
  475ef0:	1885c83a 	sub	r2,r3,r2
  475ef4:	f800283a 	ret

00475ef8 <__lshrdi3>:
  475ef8:	2005883a 	mov	r2,r4
  475efc:	2807883a 	mov	r3,r5
  475f00:	30000826 	beq	r6,zero,475f24 <__lshrdi3+0x2c>
  475f04:	01000804 	movi	r4,32
  475f08:	2189c83a 	sub	r4,r4,r6
  475f0c:	0100060e 	bge	zero,r4,475f28 <__lshrdi3+0x30>
  475f10:	1184d83a 	srl	r2,r2,r6
  475f14:	2908983a 	sll	r4,r5,r4
  475f18:	298cd83a 	srl	r6,r5,r6
  475f1c:	2084b03a 	or	r2,r4,r2
  475f20:	3007883a 	mov	r3,r6
  475f24:	f800283a 	ret
  475f28:	0105c83a 	sub	r2,zero,r4
  475f2c:	000d883a 	mov	r6,zero
  475f30:	2884d83a 	srl	r2,r5,r2
  475f34:	3007883a 	mov	r3,r6
  475f38:	003ffa06 	br	475f24 <__lshrdi3+0x2c>

00475f3c <__ashldi3>:
  475f3c:	2005883a 	mov	r2,r4
  475f40:	2807883a 	mov	r3,r5
  475f44:	30000826 	beq	r6,zero,475f68 <__ashldi3+0x2c>
  475f48:	01000804 	movi	r4,32
  475f4c:	2189c83a 	sub	r4,r4,r6
  475f50:	0100060e 	bge	zero,r4,475f6c <__ashldi3+0x30>
  475f54:	1108d83a 	srl	r4,r2,r4
  475f58:	2986983a 	sll	r3,r5,r6
  475f5c:	118c983a 	sll	r6,r2,r6
  475f60:	20c6b03a 	or	r3,r4,r3
  475f64:	3005883a 	mov	r2,r6
  475f68:	f800283a 	ret
  475f6c:	0107c83a 	sub	r3,zero,r4
  475f70:	000d883a 	mov	r6,zero
  475f74:	10c6983a 	sll	r3,r2,r3
  475f78:	3005883a 	mov	r2,r6
  475f7c:	003ffa06 	br	475f68 <__ashldi3+0x2c>

00475f80 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
  475f80:	defffc04 	addi	sp,sp,-16
  475f84:	df000315 	stw	fp,12(sp)
  475f88:	df000304 	addi	fp,sp,12
  475f8c:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
  475f90:	00801234 	movhi	r2,72
  475f94:	10a63e44 	addi	r2,r2,-26375
  475f98:	10000005 	stb	zero,0(r2)
  475f9c:	e0bfff17 	ldw	r2,-4(fp)
  475fa0:	e0bffd15 	stw	r2,-12(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  int r2 = exit_code;
  475fa4:	e0bffd17 	ldw	r2,-12(fp)
  475fa8:	e0bffe15 	stw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "D02"(r2), "D03"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
  475fac:	e0bffe17 	ldw	r2,-8(fp)
  475fb0:	10000226 	beq	r2,zero,475fbc <_exit+0x3c>
    ALT_SIM_FAIL();
  475fb4:	002af070 	cmpltui	zero,zero,43969
  475fb8:	00000106 	br	475fc0 <_exit+0x40>
  } else {
    ALT_SIM_PASS();
  475fbc:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
  475fc0:	003fff06 	br	475fc0 <_exit+0x40>
